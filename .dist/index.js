!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports["@micelord/grider"]=e():t["@micelord/grider"]=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function n(i){if(e[i])return e[i].exports;var s=e[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)n.d(i,s,function(e){return t[e]}.bind(null,s));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=33)}([function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(39);e.CenterPoint=i.CenterPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(16),s=n(6);class o{constructor(t,e){this.lat=t,this.lng=e}static createFormatted(t,e){return t=i.formatLat(t),e=i.formatLng(e),new o(t,e)}static fromUnsafeCoords(t,e){return t=i.reduceLat(t),e=i.reduceLng(e),new o(t,e)}static fromMerc(t){const{lat:e,lng:n}=t.toSphereLiteral();return new o(e,n)}isEqual(t){const e=this.toFormatted(),n=t.toFormatted();return e.lat===n.lat&&e.lng===n.lng}isCloserThroughAntiMeridian(t){const e=Math.min(this.lng,t.lng);return Math.max(this.lng,t.lng)-e>180}toOppositeHemisphere(){const t=i.reduceLng(this.lng-180);return new o(this.lat,t)}calcMercDistance(t){let e=this;this.isCloserThroughAntiMeridian(t)&&(e=this.toOppositeHemisphere(),t=t.toOppositeHemisphere());const n=e.toMerc(),i=t.toMerc();return n.distanceToPoint(i)}toMerc(){const t=i.lngToX(this.lng),e=i.latToY(this.lat);return new s.MercPoint(t,e)}toSemiSphere(){const{lat:t,lng:e}=this.toMerc().toSemiSphereLiteral();return new o(t,e)}fromSemiSphere(){const t=i.semiLngToX(this.lng),e=i.semiLatToY(this.lat),{lat:n,lng:r}=new s.MercPoint(t,e).toSphereLiteral();return new o(n,r)}toFormatted(){const t=i.formatLat(this.lat),e=i.formatLng(this.lng);return new o(t,e)}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng<t.lng:this.lng>t.lng}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng>t.lng:this.lng<t.lng}isNorthernTo(t){return this.lat>t.lat}isSouthernTo(t){return this.lat<t.lat}toPlain(){const{lat:t,lng:e}=this;return{lat:t,lng:e}}toGeoJSON(){return{type:"Point",coordinates:[this.lng,this.lat]}}static fromPlain({lat:t,lng:e}){return new o(t,e)}static fromGeoJSON({coordinates:[t,e]}){return o.fromPlain({lat:e,lng:t})}}e.GeoPoint=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class i{constructor(t,e){this.x=t,this.y=e}distanceToPoint({x:t,y:e}){return Math.sqrt(Math.pow(t-this.x,2)+Math.pow(e-this.y,2))}toFormatted(){return this}toPlain(){return{x:this.x,y:this.y}}static fromPlain({x:t,y:e}){return new i(t,e)}containedByLine(t){return t.hasPoint(this)}containedBySegment(t){return t.hasPoint(this)}isEqual(t){const e=this.toFormatted(),n=t.toFormatted();return e.x===n.x&&e.y===n.y}distanceToLine(t){return t.distanceToPoint(this)}closestOnLine(t){return t.closestToPoint(this)}closestOnSegment(t){return t.closestToPoint(this)}}e.Point=i},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(50);e.Cell=i.Cell},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calcNearestIndexes=function(t,e,n){const i=[[t+1,e],[t,e+1],[t-1,e],[t,e-1]];return"hex"!==n.type?i:(i.push([t-1,e+1],[t+1,e-1]),i)},e.calcNearestAndTouchedIndexes=function(t,e,n){const i=[[t+1,e],[t,e+1],[t-1,e],[t,e-1],[t-1,e+1],[t+1,e-1]];return"rect"!==n.type?i:(i.push([t+1,e+1],[t-1,e-1]),i)}},function(t,e,n){"use strict";function i(t){return t*Math.PI/180}Object.defineProperty(e,"__esModule",{value:!0}),e.floorNumStrByOrder=function(t){const e=t.length;if(t.split("").every(t=>"0"===t))return t;if(t.lastIndexOf(".")===e-2)return Math.floor(+t)+"";if(-1!==t.indexOf("."))return t.slice(0,-1);if(-1===t.indexOf("0"))return t.slice(0,-1)+"0";{const n=t.lastIndexOf("0");return t.slice(0,n-1)+"0".repeat(e-n+1)}},e.calcClosestMultiple=function(t,e){let n=t,i=t;for(;e%n!=0&&e%i!=0;)n+=1,i-=1;return e%n==0?n:i},e.cosDeg=function(t){const e=i(t);return Math.cos(e)},e.sinDeg=function(t){const e=i(t);return Math.sin(e)},e.findPrimeFactors=function(t){if(t<2)return[];let e=t,n=2;const i=[];for(;n*n<=e;)e%n==0?(i.push(n),e/=n):n+=1;return 1!==e&&i.push(e),i},e.degToRad=i,e.radToDeg=function(t){return 180*t/Math.PI},e.decRemain=function(t){return t-Math.floor(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2),s=n(24);class o extends i.Point{constructor(t,e){super(t=s.reduceX(t),e)}toFormatted(){return new o(+this.x.toFixed(10),+this.y.toFixed(10))}toOppositeHemisphere(){const t=s.reduceX(this.x-.5);return new o(t,this.y)}calcMercDistance(t){return(this.isCloserThroughAntiMeridian(t)?this.toOppositeHemisphere():this).distanceToPoint(t)}isCloserThroughAntiMeridian(t){const e=Math.min(this.x,t.x);return Math.max(this.x,t.x)-e>1}toSphereLiteral(){return{lat:s.yToLat(this.y),lng:s.xToLng(this.x)}}toSemiSphereLiteral(){return{lat:s.yToSemiLat(this.y),lng:s.xToSemiLng(this.x)}}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x<t.x:this.x>t.x}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x>t.x:this.x<t.x}isNorthernTo(t){return this.y>t.y}isSouthernTo(t){return this.y<t.y}}e.MercPoint=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(40);e.GridPoint=i.GridPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(0);e.CenterPoint=i.CenterPoint;var s=n(7);e.GridPoint=s.GridPoint;var o=n(1);e.GeoPoint=o.GeoPoint;var r=n(6);e.MercPoint=r.MercPoint;var a=n(26);e.PeakPoint=a.PeakPoint;var c=n(2);e.Point=c.Point;var u=n(10);e.TileMercPoint=u.TileMercPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(16),s=n(23),o=n(1),r=n(18);class a{constructor(t,e){this.pointA=t,this.pointB=e,this.rhumbLine=s.RhumbLine.fromTwoGeoPoints(t,e)}get points(){return[this.pointA,this.pointB]}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallel(){return this.pointA.lat===this.pointB.lat}get isMeridian(){return this.pointA.lat===this.pointB.lat}get easternPoint(){return this.isMeridian?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isMeridian?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallel?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallel?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}static segmentsFromPointsByLng(t){const e=t.sort(({lng:t},{lng:e})=>t-e),n=e.reduce((t,n,i)=>e[t].isEasternTo(n)?i:t,0);return[...e.slice(n),...e.slice(0,n)].reduce((t,e,n,i)=>{if(n%2)return t;const s=new a(i[n+1],e);return t.push(s),t},[])}static segmentsFromPointsByLat(t){return t.sort(({lat:t},{lat:e})=>t-e).reduce((t,e,n,i)=>{if(n%2)return t;const s=new a(i[n+1],e);return t.push(s),t},[])}toMerc(){const t=this.pointA.toMerc(),e=this.pointB.toMerc();return new r.MercSegment(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new a(t,e)}intersectsWithPoly(t){return t.intersectsWithSegment(this)}intersects(t){return!!this.intersectionPoint(t)}intersectionPoint(t){let e=this,n=t;const i=this.isAntiMeridian||t.isAntiMeridian;i&&(e=e.toOppositeHemisphere(),n=n.toOppositeHemisphere());const s=e.toMerc(),r=n.toMerc(),a=s.intersectionPoint(r);if(!a)return;const c=o.GeoPoint.fromMerc(a);return i?c.toOppositeHemisphere():c}closestToPoint(t){const{isAntiMeridian:e}=this;let n=this;e&&(n=n.toOppositeHemisphere(),t=t.toOppositeHemisphere());const i=t.toMerc(),s=n.toMerc().closestToPoint(i),r=o.GeoPoint.fromMerc(s);return e?r.toOppositeHemisphere():r}isEqual({pointA:t,pointB:e}){return this.pointA.isEqual(t)&&this.pointB.isEqual(e)||this.pointA.isEqual(e)&&this.pointB.isEqual(t)}mercDistanceToPoint(t){const e=this.closestToPoint(t);return t.calcMercDistance(e)}latByLng(t){if(!this.containsLng(t))return;const e=this.rhumbLine.latByLng(t);return void 0===e||0!==this.rhumbLine.a&&!this.containsLat(e)?void 0:e}lngByLat(t){if(!this.containsLat(t))return;const e=this.rhumbLine.lngByLat(t);return void 0===e||0!==this.rhumbLine.b&&!this.containsLng(e)?void 0:e}containsLat(t){t=i.formatLat(t);const{lat:e}=this.pointA.toFormatted(),{lat:n}=this.pointB.toFormatted();return Math.max(e,n)>=t&&Math.min(e,n)<=t}containsLng(t){t=i.formatLng(t);const{lng:e}=this.pointA.toFormatted(),{lng:n}=this.pointB.toFormatted(),s=Math.max(e,n),o=Math.min(e,n);return this.isAntiMeridian?s<=t&&t<180||o>=t&&t>=-180:s>=t&&o<=t}containsPoint({lat:t,lng:e}){return this.containsLat(t)&&this.containsLng(e)}containsSegment({pointA:t,pointB:e}){return this.containsPoint(t)&&this.containsPoint(e)}overlapsSegment(t){const{pointA:e,pointB:n}=t;return this.containsPoint(e)||this.containsPoint(n)||t.containsPoint(this.pointB)||t.containsPoint(this.pointB)}}e.GeoSegment=a},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(22),s=n(11),o=n(9),r=n(0),a=n(1),c=n(6),u=n(2);class h extends c.MercPoint{get zoomCoofX(){return 2**this.zoom*i.constants.googleTileSize/this.tileWidth}get zoomCoofY(){return 2**this.zoom*i.constants.googleTileSize/this.tileHeight}get northTile(){const{tileX:t,tileY:e,tileHeight:n,tileWidth:i,zoom:s}=this;return h.fromTile(t,e-1,i,n,s)}get southTile(){const{tileX:t,tileY:e,tileHeight:n,tileWidth:i,zoom:s}=this;return h.fromTile(t,e+1,i,n,s)}get eastTile(){const{tileX:t,tileY:e,tileHeight:n,tileWidth:i,zoom:s}=this;return h.fromTile(t+1,e,i,n,s)}get westTile(){const{tileX:t,tileY:e,tileHeight:n,tileWidth:i,zoom:s}=this;return h.fromTile(t-1,e,i,n,s)}get northBound(){return a.GeoPoint.fromMerc(this).lat}get southBound(){return a.GeoPoint.fromMerc(this.southTile).lat}get eastBound(){return a.GeoPoint.fromMerc(this.eastTile).lng}get westBound(){return a.GeoPoint.fromMerc(this).lng}get north(){return new o.GeoSegment(a.GeoPoint.fromMerc(this),a.GeoPoint.fromMerc(this.eastTile))}get south(){const t=this.southTile;return new o.GeoSegment(a.GeoPoint.fromMerc(t.eastTile),a.GeoPoint.fromMerc(t))}get east(){const t=this.eastTile;return new o.GeoSegment(a.GeoPoint.fromMerc(t),a.GeoPoint.fromMerc(t.southTile))}get west(){return new o.GeoSegment(a.GeoPoint.fromMerc(this.southTile),a.GeoPoint.fromMerc(this))}static fromTile(t,e,n,s,o){const r=t/(2**o*(i.constants.googleTileSize/n)),a=e/(2**o*(i.constants.googleTileSize/s));return new h(r,a,t,e,n,s,o)}static fromPlain({x:t,y:e,tileX:n,tileY:i,tileWidth:s,tileHeight:o,zoom:r}){return new h(t,e,n,i,s,o,r)}static fromMerc(t,e,n,s){const o=t.x*(2**s*(i.constants.googleTileSize/e)),r=t.y*(2**s*(i.constants.googleTileSize/n));return new h(t.x,t.y,o,r,e,n,s)}constructor(t,e,n,i,s,o,r){super(t,e),this.tileX=n,this.tileY=i,this.tileWidth=s,this.tileHeight=o,this.zoom=r}gridPatternStartPoint(t){const e=a.GeoPoint.fromMerc(this),n=r.CenterPoint.fromGeo(e,t),{northWest:i}=n.northWestNeighbors,s=i.toGeo().toMerc(),o=h.fromMerc(s,this.tileWidth,this.tileHeight,this.zoom);return this.startPointDiff(o)}startPointDiff(t){let e=t.tileX-this.tileX;const n=t.tileY-this.tileY;return e>this.tileX&&(e-=Math.ceil(e)),new u.Point(e,n)}toPoly(){const t=this.eastTile;return new s.GeoPolygon([a.GeoPoint.fromMerc(this),a.GeoPoint.fromMerc(t),a.GeoPoint.fromMerc(t.southTile),a.GeoPoint.fromMerc(this.southTile)])}containsPoint({lat:t,lng:e}){return t<=this.northBound&&t>=this.southBound&&e<=this.eastBound&&e>=this.westBound}projectGeoPoints(t){return t.map(t=>{const e=t.toMerc(),{tileX:n,tileY:i}=h.fromMerc(e,this.tileWidth,this.tileHeight,this.zoom),s=Math.round((n-this.tileX)*this.tileWidth),o=Math.round((i-this.tileY)*this.tileHeight);return new u.Point(s,o)})}toPlain(){return{x:this.x,y:this.y,tileX:this.tileX,tileY:this.tileY,zoom:this.zoom,tileHeight:this.tileHeight,tileWidth:this.tileWidth}}}e.TileMercPoint=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(20);e.GeoPolygon=i.GeoPolygon},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.GenericPolygon=class{constructor(t){this.points=t}intersectsPoly(t){return this.reduceSides((e,n,i)=>t.reduceSides((t,e,i)=>{const s=n.intersectionPoint(e);return s&&t.push(s),t},e),[])}intersectsSegment(t){return this.reduceSides((e,n)=>!!e||!!n.intersectionPoint(t),!1)}intersectsWithSegment(t){return this.reduceSides((e,n)=>{const i=n.intersectionPoint(t);return i&&e.push(i),e},[])}get selfIntersections(){return this.reduceOppositeSidesPairs((t,e,n)=>{const i=e.intersectionPoint(n);return i&&t.push(i),t},[])}sideByIndex(t){return{pointA:this.points[t],pointB:this.nextPointByIndex(t)}}sideByIndexInversed(t){return{pointA:this.points[t],pointB:this.prevPointByIndex(t)}}nextIndex(t){return t===this.points.length-1?0:t+1}prevIndex(t){const{length:e}=this.points;return 0===t?e-1:t-1}nextPointByIndex(t){const e=this.nextIndex(t);return this.points[e]}prevPointByIndex(t){const e=this.prevIndex(t);return this.points[e]}forEachSide(t){this.points.forEach((e,n)=>{const i=this.sideByIndex(n);t(i,n)})}mapSides(t){return this.points.map((e,n)=>{const i=this.sideByIndex(n);return t(i,n)})}reduceSides(t,e){return this.points.reduce((e,n,i)=>{const s=this.sideByIndex(i);return t(e,s,i)},e)}forEachSidesPair(t){this.forEachSide((e,n)=>{this.forEachSide((i,s)=>{s<=n||t(e,i)})})}reduceSidesPairs(t,e){return this.reduceSides((e,n,i)=>this.reduceSides((e,s,o)=>o<=i?e:t(e,n,s),e),e)}reduceNeighboringSidesPairs(t,e){return this.points.reduce((e,n,i)=>{const s=this.sideByIndexInversed(i),o=this.sideByIndex(i);return t(e,s,o)},e)}reduceOppositeSidesPairs(t,e){const n=this.points.length-1;return this.reduceSides((e,i,s)=>this.reduceSides((e,o,r)=>0===s&&r===n||r-1<=s?e:t(e,i,o),e),e)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(56);class s extends i.CtxService{constructor(){super(...arguments),this.postQueue=[],this.runningTaskMessage=null,this.resolves=new Map,this.rejects=new Map,this.messageHandler=t=>{const e=this.runningTaskMessage,n=this.resolves.get(e);n&&n(t),this.clearMessage(e),this.nextTask()},this.errorHandler=t=>{const e=this.runningTaskMessage,n=this.rejects.get(e);n&&n(t),this.clearMessage(e),this.nextTask()}}post(t){return this.runningTaskMessage?this.postQueue.push(t):(this.runningTaskMessage=t,super.post(t)),new Promise((e,n)=>{this.resolves.set(t,e),this.rejects.set(t,n)})}nextTask(){if(0===this.postQueue.length)this.runningTaskMessage=null;else{const t=this.postQueue[0];this.runningTaskMessage=t,this.postQueue.shift(),super.post(t)}}clearMessage(t){this.resolves.delete(t),this.rejects.delete(t)}terminate(){this.worker.terminate()}unmount(){this.resolves=new Map,this.rejects=new Map,this.postQueue=[],this.runningTaskMessage=null,super.unmount()}}e.WorkerService=s},function(t,e,n){"use strict";var i=window.URL||window.webkitURL;t.exports=function(t,e){try{try{var n;try{(n=new(window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder)).append(t),n=n.getBlob()}catch(e){n=new Blob([t])}return new Worker(i.createObjectURL(n))}catch(e){return new Worker("data:application/javascript,"+encodeURIComponent(t))}}catch(t){if(!e)throw Error("Inline worker is not supported");return new Worker(e)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2),s=n(38);class o{constructor(t,e,n){this.a=t,this.b=e,this.c=n}get isParallelToAxisX(){return 0===this.b}get isParallelToAxisY(){return 0===this.a}static fromTwoPoints({x:t,y:e},{x:n,y:i}){return new o(e-i,n-t,-(t*i-e*n))}calcAlikePoint(t){const e=this.xByY(t.y),n=this.yByX(t.x);return new i.Point(void 0===e?t.x:e,void 0===n?t.y:n)}hasPoint(t){return this.calcAlikePoint(t).isEqual(t)}xByY(t){if(!this.isParallelToAxisY)return(this.c-this.b*t)/this.a}yByX(t){if(!this.isParallelToAxisX)return(this.c-this.a*t)/this.b}distanceToPoint(t){const e=this.closestToPoint(t);return t.distanceToPoint(e)}getNormalVector(){return new s.Vector(this.a,this.b)}closestToPoint(t){const{x:e,y:n}=t;if(this.isParallelToAxisX)return new i.Point(this.c/this.a,n);if(this.isParallelToAxisY)return new i.Point(e,this.c/this.b);const s=this.perpendicularByPoint(t);return this.intersectionPoint(s)}perpendicularByPoint({x:t,y:e}){const{x:n,y:i}=this.getNormalVector();return new o(1/n,-1/i,t/n-e/i)}intersectionX({a:t,b:e,c:n}){const i=this.a*e-this.b*t,s=this.c*e-this.b*n;if(i)return s/i}intersectionY({a:t,b:e,c:n}){const i=this.a*e-this.b*t,s=this.a*n-this.c*t;if(i)return s/i}intersectionPoint(t){if(t.isParallelToAxisX&&this.isParallelToAxisX||t.isParallelToAxisY&&this.isParallelToAxisY)return;const{a:e,b:n,c:s}=t;let o,r;return o=t.isParallelToAxisX?s/e:this.isParallelToAxisX?this.c/this.a:this.intersectionX(t),r=t.isParallelToAxisY?s/n:this.isParallelToAxisY?this.c/this.b:this.intersectionY(t),void 0===o&&void 0!==r&&(o=this.xByY(r)||t.xByY(r)),void 0!==o&&void 0===r&&(r=this.yByX(o)||t.yByX(o)),void 0!==o&&void 0!==r?new i.Point(o,r):void 0}}e.Line=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(5);function s(t){return(t>360||t<-360)&&(t%=360),t>=180?t-360:t<-180?t+360:t}e.semiLatToY=function(t){return-t/180+.5},e.semiLngToX=function(t){return t/360+.5},e.latToY=function(t){return(-Math.log(Math.tan(Math.PI/4+i.degToRad(t)/2))/Math.PI+1)/2},e.lngToX=function(t){return(i.degToRad(t)/Math.PI+1)/2},e.formatLat=function(t){return t>90&&(t=90),t<-90&&(t=-90),+t.toFixed(7)},e.formatLng=function(t){return+(t=s(t)).toFixed(7)},e.reduceLat=function(t){return(t>360||t<-360)&&(t%=360),t>90?180-t:t<-90?-180+t:t},e.reduceLng=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(7),s=n(9);class o extends s.GeoSegment{constructor(t,e,n,i,s){super(t,e),this.peakA=n,this.peakB=i,this.params=s}get averagePoint(){const{i:t,j:e,k:n,params:s}=this.peakA,{i:o,j:r,k:a}=this.peakB;return new i.GridPoint(s,(t+o)/2,(e+r)/2,void 0!==n&&void 0!==a?(n+a)/2:void 0)}static fromPeaks(t,e){const n=t.toGeo(),i=e.toGeo();return new o(n,i,t,e,t.params)}}e.CellSide=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(25),s=n(6),o=n(19);class r extends o.Segment{constructor(t,e){super(t,e),this.pointA=t,this.pointB=e,this.line=i.MercLine.fromTwoPoints(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new r(t,e)}intersectionPoint(t){if(!this.isAntiMeridian&&!t.isAntiMeridian){const e=super.intersectionPoint(t);return e&&new s.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere(),n=t.toOppositeHemisphere(),i=e.intersectionPoint(n);return i&&i.toOppositeHemisphere()}closestToPoint(t){if(!this.isAntiMeridian){const e=super.closestToPoint(t);return new s.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere();return t=t.toOppositeHemisphere(),e.closestToPoint(t).toOppositeHemisphere()}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallelToAxisX(){return this.line.isParallelToAxisX}get isParallelToAxisY(){return this.line.isParallelToAxisY}get easternPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}}e.MercSegment=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(15);e.Segment=class{constructor(t,e){this.pointA=t,this.pointB=e,this.line=i.Line.fromTwoPoints(t,e)}get minX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.min(t,e)}get maxX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.max(t,e)}get minY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.min(t,e)}get maxY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.max(t,e)}get minXPoint(){const{x:t}=this.pointA;return this.minX===t?this.pointA:this.pointB}get maxXPoint(){const{x:t}=this.pointA;return this.maxX===t?this.pointA:this.pointB}get minYPoint(){const{y:t}=this.pointA;return this.minY===t?this.pointA:this.pointB}get maxYPoint(){const{y:t}=this.pointA;return this.maxY===t?this.pointA:this.pointB}closestToPoint(t){const e=this.line.closestToPoint(t).toFormatted(),{x:n,y:i}=this.pointA.toFormatted(),{x:s,y:o}=this.pointB.toFormatted();return e.x<Math.min(n,s)?this.minXPoint:e.x>Math.max(n,s)?this.maxXPoint:e.y<Math.min(i,o)?this.minYPoint:e.y>Math.max(i,o)?this.maxYPoint:e}hasPoint(t){const{pointA:e,pointB:n}=this,{x:i,y:s}=t.toFormatted(),{x:o,y:r}=e.toFormatted(),{x:a,y:c}=n.toFormatted();return this.line.hasPoint(t)&&Math.max(o,a)>=i&&Math.min(o,a)<=i&&Math.max(r,c)>=s&&Math.min(r,c)<=s}intersectionPoint(t){if(this.line.a===t.line.a||this.line.b===t.line.b)return;const e=this.line.intersectionPoint(t.line);if(!e)return;let n,i;const s=Math.max(this.pointA.x,this.pointB.x),o=Math.min(this.pointA.x,this.pointB.x),r=Math.max(this.pointA.y,this.pointB.y),a=Math.min(this.pointA.y,this.pointB.y),c=Math.max(t.pointA.x,t.pointB.x),u=Math.min(t.pointA.x,t.pointB.x),h=Math.max(t.pointA.y,t.pointB.y),l=Math.min(t.pointA.y,t.pointB.y);return n=0===this.line.a?e.x<=s&&e.x>=o&&h>=r&&l<=a:0===this.line.b?e.y<=r&&e.y>=a&&c>=s&&u<=o:this.hasPoint(e),i=0===t.line.a?e.x<=c&&e.x>=u&&r>=h&&a<=l:0===t.line.b?e.y<=h&&e.y>=l&&s>=c&&o<=u:t.hasPoint(e),n&&i?e:void 0}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1),s=n(9),o=n(12);class r extends o.GenericPolygon{sideByIndex(t){const{pointA:e,pointB:n}=super.sideByIndex(t);return new s.GeoSegment(e,n)}sideByIndexInversed(t){const{pointA:e,pointB:n}=super.sideByIndexInversed(t);return new s.GeoSegment(e,n)}splitSectionsByLng(t){const e=this.reduceSides((e,n)=>{const s=n.latByLng(t);if(void 0===s)return e;const o=new i.GeoPoint(s,t);return e.find(t=>t.isEqual(o))||e.push(o),e},[]);return s.GeoSegment.segmentsFromPointsByLat(e)}splitSectionsByLat(t){const e=this.reduceSides((e,n)=>{const s=n.lngByLat(t);if(void 0!==s){const n=new i.GeoPoint(t,s);e.push(n)}return e},[]);return s.GeoSegment.segmentsFromPointsByLng(e)}intersectsSegment(t){return super.intersectsSegment(t)}intersectsWithSegment(t){return super.intersectsWithSegment(t)}closestSideToSegment(t){const[e,n]=this.pointsByDistanceToSegment(t),i=this.points.indexOf(e),s=this.points.indexOf(n);return this.sideByIndex(Math.min(i,s))}pointsByDistanceToSegment(t){return[...this.points].sort((e,n)=>{return t.mercDistanceToPoint(e)-t.mercDistanceToPoint(n)})}pointsInsidePoly(t){return this.points.filter(e=>t.containsPoint(e))}pointsOutsidePoly(t){return this.points.filter(e=>!t.containsPoint(e))}arePointsInsidePoly(t){return this.points.every(e=>t.containsPoint(e))}arePointsOutsidePoly(t){return this.points.every(e=>!t.containsPoint(e))}containsPoint(t){return this.splitSectionsByLat(t.lat).reduce((e,n)=>e||n.containsLng(t.lng),!1)}isValidForFigure(t){if(this.outmapPoints.length>0)return!1;if(this.points.length<3)return!1;const{selfIntersections:e}=this;return!(e.length>0)}get outmapPoints(){return this.points.filter(t=>{const{y:e}=t.toMerc();return e>1||e<0})}get easternPoint(){return this.points.reduce((t,e)=>e.isEasternTo(t)?e:t,this.points[0])}get westernPoint(){return this.points.reduce((t,e)=>e.isWesternTo(t)?e:t,this.points[0])}get northernPoint(){return this.points.reduce((t,e)=>e.isNorthernTo(t)?e:t,this.points[0])}get southernPoint(){return this.points.reduce((t,e)=>e.isSouthernTo(t)?e:t,this.points[0])}toPlain(){return this.points.map(t=>t.toPlain())}toGeoJSON(){return{type:"Polygon",coordinates:[[...this.points,this.points[0]].map(({lat:t,lng:e})=>[e,t])]}}static fromGeoJSON({coordinates:[t]}){const e=i.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[0]}),n=i.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[t.length-1]});if(!e.isEqual(n))throw new Error("Loop is not closed");return r.fromPlain(t.slice(0,-1).map(([t,e])=>({lat:e,lng:t})))}static fromPlain(t){return new r(t.map(({lat:t,lng:e})=>new i.GeoPoint(t,e)))}}e.GeoPolygon=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0);e.calcTopLeft=function(t){const e=t.findIndex(t=>t.some(t=>t instanceof i.CenterPoint)),n=t[e].findIndex(t=>t instanceof i.CenterPoint);return t[e][n].moveByDiff(-e,-n)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.constants={equatorLength:40075696,radius:6370997,meridianLength:40007860,googleTileSize:256}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(16),s=n(24),o=n(25);class r extends o.MercLine{static fromTwoGeoPoints(t,e){const n=t.isCloserThroughAntiMeridian(e);n&&(t=t.toOppositeHemisphere(),e=e.toOppositeHemisphere());const{a:i,b:s,c:a}=o.MercLine.fromTwoPoints(t.toMerc(),e.toMerc());return new r(i,s,a,n)}constructor(t,e,n,i){super(t,e,n),this.isAntiMeridian=i}lngByLat(t){const e=i.latToY(t),n=this.xByY(e);if(void 0===n)return;let o=s.xToLng(n);return this.isAntiMeridian&&(o=i.reduceLng(o-180)),o}latByLng(t){this.isAntiMeridian&&(t=i.reduceLng(t-180));const e=i.lngToX(t),n=this.yByX(e);if(void 0!==n)return s.yToLat(n)}}e.RhumbLine=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(5);e.yToLat=function(t){const e=Math.atan(Math.E**(-(2*t-1)*Math.PI))-Math.PI/4;return 2*i.radToDeg(e)},e.xToLng=function(t){const e=(2*t-1)*Math.PI;return i.radToDeg(e)},e.yToSemiLat=function(t){return 180*-(t-.5)},e.xToSemiLng=function(t){return 360*(t-.5)},e.reduceX=function(t){return t%=1}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(6),s=n(15);class o extends s.Line{static fromTwoPoints(t,e){const{a:n,b:i,c:r}=s.Line.fromTwoPoints(t,e);return new o(n,i,r)}calcAlikePoint(t){const{x:e,y:n}=super.calcAlikePoint(t);return new i.MercPoint(e,n)}closestToPoint(t){const{x:e,y:n}=super.closestToPoint(t);return new i.MercPoint(e,n)}perpendicularByPoint(t){const{a:e,b:n,c:i}=super.perpendicularByPoint(t);return new o(e,n,i)}intersectionPoint(t){const e=super.intersectionPoint(t);if(!e)return;const{x:n,y:s}=e;return new i.MercPoint(n,s)}}e.MercLine=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(47);e.PeakPoint=i.PeakPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(54);e.Figure=i.Figure},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(70);e.CentersMatrix=i.CentersMatrix},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(76);e.PolyMatrix=i.PolyMatrix},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(17);e.CellSide=i.CellSide;var s=n(9);e.GeoSegment=s.GeoSegment;var o=n(18);e.MercSegment=o.MercSegment;var r=n(19);e.Segment=r.Segment},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2),s=n(32);class o{constructor(t,e,n,i,s){this.tilePoint=t,this.tile=e,this.start=n,this.end=i,this.params=s}static fromTileCoords(t,e,n){const r=s.GridTile.fromTileCoords(t,e,n);let a,c;"merc"===n.correction?(a=1,c=1):(a=1,c=e.y+r.tileHeight);const u=new i.Point(a,c);return new o(t,r,e,u,n)}toPlain(){return{start:this.start.toPlain(),end:this.end.toPlain(),tile:this.tile.toPlain()}}static fromPlain({start:t,end:e,tile:n},r,a){return new o(r,s.GridTile.fromPlain(n,r,a),i.Point.fromPlain(t),i.Point.fromPlain(e),a)}}e.GridPattern=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),s=n(1),o=n(2),r=n(10),a=n(88);class c{constructor(t,e,n,i,s){this.points=t,this.tilePoint=e,this.tileWidth=n,this.tileHeight=i,this.params=s}static fromTileCoords(t,e,n){const{tileX:o,tileY:u,tileHeight:h,tileWidth:l,zoom:p}=t,d=r.TileMercPoint.fromTile(o+e.x,u+e.y,l,h,p),m=s.GeoPoint.fromMerc(d),f=i.CenterPoint.fromGeo(m,n),{southEast:g}=f.southEastNeighbors,{southEast:P}=g.southEastNeighbors,y=P.toGeo().toMerc(),{tileY:x}=d;let{tileX:M}=d;const{tileX:j,tileY:b}=r.TileMercPoint.fromMerc(y,l,h,p);j<M&&(M-=Math.ceil(M));const T=g.toGeo(),v=j-M,O=b-x,w=a.expandTile(T,d,v,O,n);return new c(w,t,v,O,n)}static fromPlain({points:t,tileHeight:e,tileWidth:n},i,s){return new c(t.map(t=>t.map(({x:t,y:e})=>new o.Point(t,e))),i,n,e,s)}toPlain(){return{points:this.points.map(t=>t.map(({x:t,y:e})=>({x:t,y:e}))),tileHeight:this.tileHeight,tileWidth:this.tileWidth}}}e.GridTile=c},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(34);e.GridParams=i.GridParams;var s=n(37);e.Line=s.Line,e.RhumbLine=s.RhumbLine;var o=n(8);e.PeakPoint=o.PeakPoint,e.Point=o.Point,e.GeoPoint=o.GeoPoint,e.GridPoint=o.GridPoint,e.CenterPoint=o.CenterPoint,e.TileMercPoint=o.TileMercPoint;var r=n(49);e.Cell=r.Cell,e.Figure=r.Figure,e.IndexatedFigure=r.IndexatedFigure,e.GeoPolygon=r.GeoPolygon,e.GenericPolygon=r.GenericPolygon,e.MercPolygon=r.MercPolygon,e.Polygon=r.Polygon,e.Area=r.Area;var a=n(30);e.CellSide=a.CellSide,e.GeoSegment=a.GeoSegment,e.MercSegment=a.MercSegment,e.Segment=a.Segment;var c=n(87);e.GridPattern=c.GridPattern,e.GridTile=c.GridTile,e.MapGridTile=c.MapGridTile;var u=n(94);e.CellConnection=u.CellConnection},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(35);e.GridParams=i.GridParams},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(36);class s{static fromConfig({isHorizontal:t=!1,type:e,correction:n,cellSize:o}){const r=t?"horizontal":"vertical",a=i.initCoofs[e][n][r],c=i.axesParams[e],u=i.calcAxesParams(t,e),h=i.calcInitialCellWidth(o,a),l=i.calcInitialCellHeight(o);return new s({isHorizontal:t,type:e,axes:c,geoAxes:u,initSize:h,initHeight:l,correction:n})}constructor({isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:s,initHeight:o,correction:r}){this.isHorizontal=t,this.type=e,this.axes=n,this.geoAxes=i,this.initSize=s,this.initHeight=o,this.correction=r}minCellSize(t){const{tileWidth:e,zoomCoofX:n}=t,{initSize:i,initHeight:s,isHorizontal:o}=this;return(o?i:s)/1e7*e*n/360}isEqual(t){return this.isHorizontal===t.isHorizontal&&this.type===t.type&&this.correction===t.correction&&this.initSize===t.initSize}toPlain(){const{isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:s,initHeight:o,correction:r}=this;return{isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:s,initHeight:o,correction:r}}static fromPlain(t){return new s(t)}}e.GridParams=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(22),s=n(5),o=Math.sqrt(3)/2;e.axesParams={get hex(){return[{name:"i",angle:0},{name:"j",angle:120},{name:"k",angle:240}]},get rect(){return[{name:"i",angle:0},{name:"j",angle:90}]}},e.initCoofs={hex:{get merc(){return{vertical:.5*o,horizontal:.5}},get none(){return{vertical:o,horizontal:1}},get area(){return{vertical:o,horizontal:1}}},rect:{get merc(){return{vertical:.5,horizontal:.5}},get none(){return{vertical:1,horizontal:1}},get area(){return{vertical:2,horizontal:.5}}}},e.calcAxesParams=function(t,e){let n;switch(e){case"hex":n=120;break;case"rect":default:n=90}return[{name:t?"lng":"lat",angle:0},{name:t?"lat":"lng",angle:n}]},e.calcInitialCellWidth=function(t,e){const n=i.constants.equatorLength/36e8,o=Math.round(t/n);let r=s.calcClosestMultiple(o,36e8);return r>18e8&&(r=18e8),r<1&&(r=1),r*e},e.calcInitialCellHeight=function(t){const e=i.constants.meridianLength/36e8,n=Math.round(t/e);let o=s.calcClosestMultiple(n,18e8);return o>18e8&&(o=18e8),o<1&&(o=1),o}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(15);e.Line=i.Line;var s=n(23);e.RhumbLine=s.RhumbLine},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Vector=class{constructor(t,e){this.x=t,this.y=e}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(7),s=n(43),o=n(44),r=n(45),a=n(46);class c extends i.GridPoint{get neighbors(){const{south:t,north:e,west:n,east:i,southEast:s,southWest:o,northEast:a,northWest:u}=r.getAll(this);return{south:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),west:n&&c.fromObject(n,this.params),east:i&&c.fromObject(i,this.params),southEast:c.fromObject(s,this.params),southWest:c.fromObject(o,this.params),northEast:c.fromObject(a,this.params),northWest:c.fromObject(u,this.params)}}get northNeighbors(){const{northWest:t,north:e,northEast:n}=r.getNorth(this);return{northWest:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),northEast:n&&c.fromObject(n,this.params)}}get southNeighbors(){const{southWest:t,south:e,southEast:n}=r.getSouth(this);return{southWest:t&&c.fromObject(t,this.params),south:e&&c.fromObject(e,this.params),southEast:n&&c.fromObject(n,this.params)}}get westNeighbors(){const{southWest:t,west:e,northWest:n}=r.getWest(this);return{southWest:t&&c.fromObject(t,this.params),west:e&&c.fromObject(e,this.params),northWest:n&&c.fromObject(n,this.params)}}get eastNeighbors(){const{southEast:t,east:e,northEast:n}=r.getEast(this);return{southEast:t&&c.fromObject(t,this.params),east:e&&c.fromObject(e,this.params),northEast:n&&c.fromObject(n,this.params)}}get northEastNeighbors(){const{northEast:t}=r.getNorthEast(this);return{northEast:c.fromObject(t,this.params)}}get southWestNeighbors(){const{southWest:t}=r.getSouthWest(this);return{southWest:c.fromObject(t,this.params)}}get northWestNeighbors(){const{northWest:t}=r.getNorthWest(this);return{northWest:c.fromObject(t,this.params)}}get southEastNeighbors(){const{southEast:t}=r.getSouthEast(this);return{southEast:c.fromObject(t,this.params)}}static fromObject({i:t,j:e,k:n},i){return new c(i,t,e,n)}static fromGeo(t,e){const n=i.GridPoint.fromGeo(t,e);return c.fromGrid(n)}static fromGrid(t){const{i:e,j:n,k:s}=a.round(t),o=new i.GridPoint(t.params,e,n,s).toGeo(),r=i.GridPoint.fromGeo(o,t.params),{i:u,j:h,k:l}=a.round(r);return new c(t.params,u,h,l)}nextCenterByCellSide(t){const{i:e,j:n,k:o}=s.getNextCenterByCellSide(this,t),r=new i.GridPoint(this.params,e,n,o).toGeo();return c.fromGeo(r,this.params)}isNeighbor(t){let e=this,n=t;return this.isCloserThroughAntiMeridian(t)&&(e=e.toOppositeHemishpere(),n=n.toOppositeHemishpere()),o.isNeighbor(e,n)}isCloserThroughAntiMeridian(t){return this.toGeo().isCloserThroughAntiMeridian(t.toGeo())}toOppositeHemishpere(){const t=this.toGeo().toOppositeHemisphere();return c.fromGeo(t,this.params)}moveByDiff(t,e){const n=this.i+t,i=this.j+e,s=void 0===this.k?void 0:this.k-(t+e),o=new c(this.params,n,i,s).toGeo();return c.fromGeo(o,this.params)}toPlain(){return{i:this.i,j:this.j,k:this.k}}static fromPlain({i:t,j:e,k:n},i){return new c(i,t,e,n)}}e.CenterPoint=c},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1),s=n(41),o=n(42);class r{static fromGeo(t,e){const n=s.correctForGrid(t,e),{axes:i}=e,{i:a,j:c,k:u}=i.reduce((t,i)=>(t[i.name]=o.toGrid(n,i,e),t),{});return new r(e,a,c,u)}constructor(t,e,n,i){this.params=t,this.i=e,this.j=n,this.k=i}toFormatted(){return this}isEasternTo(t){return this.toGeo().isEasternTo(t.toGeo())}isWesternTo(t){return this.toGeo().isWesternTo(t.toGeo())}isNorthernTo(t){return this.toGeo().isNorthernTo(t.toGeo())}isSouthernTo(t){return this.toGeo().isSouthernTo(t.toGeo())}isEqual(t){const{i:e,j:n,k:i}=this.toFormatted(),{i:s,j:o,k:r}=t.toFormatted();return e===s&&n===o&&i===r}toGeo(){const{geoAxes:t}=this.params,{lat:e,lng:n}=t.reduce((t,e)=>(t[e.name]=o.toGeo(this,e),t),{}),r=new i.GeoPoint(e,n);return s.correctForGeo(r,this.params)}onSameAxis(t,e){let n=(this.i-t.i)*(this.j-e.j)-(this.i-e.i)*(this.j-t.j);return"hex"===this.params.type&&(n*=3),0===Math.round(n)}}e.GridPoint=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1);e.correctForGrid=function(t,{correction:e}){if("merc"===e){const{lat:e,lng:n}=t.toSemiSphere();return new i.GeoPoint(e,n/2)}return t},e.correctForGeo=function(t,e){const{correction:n}=e;if("merc"===n){const{lat:e,lng:n}=t;return new i.GeoPoint(e,2*n).fromSemiSphere().toFormatted()}return t.toFormatted()},e.correctPoly=function(t,{correction:e}){return t}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(5);e.toGrid=function(t,e,n){return function(t,e){const n=e.initSize;return 1e7*t/n}(function(t,e,n){const s=n?"lat":"lng",o=t[n?"lng":"lat"],r=t[s],a=e.angle,c=i.sinDeg(a),u=i.cosDeg(a);return r*c+o*u}(t,e,n.isHorizontal),n)},e.toGeo=function(t,e){return function(t,e){const n=e.initSize;return t*n/1e7}(function(t,e){const{isHorizontal:n}=t.params,s=n?"lng":"lat",o=n?"lat":"lng",r=e.angle,a=i.sinDeg(r),c=i.cosDeg(r);let u;switch(e.name){case s:u=(t.i-t.j*a)/c;break;case o:u=(t.j-t.i*c)/a;break;default:u=t.j*a+t.i*c}return u}(t,e),t.params)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getNextCenterByCellSide=function(t,e){const{i:n,j:i,k:s}=t,{averagePoint:{i:o,j:r,k:a}}=e;return{i:Math.round(n+2*(o-n)),j:Math.round(i+2*(r-i)),k:void 0!==s&&void 0!==a?Math.round(s+2*(a-s)):void 0}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNeighbor=function(t,e){const{type:n}=t.params;return"hex"===n?function({i:t,j:e,k:n},{i:i,j:s,k:o}){const r=[t-i,e-s,n-o];return r.includes(0)&&r.includes(1)&&r.includes(-1)}(t,e):function({i:t,j:e},{i:n,j:i}){const s=[Math.abs(t-n),Math.abs(e-i)];return s.includes(0)&&s.includes(1)}(t,e)}},function(t,e,n){"use strict";function i(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:s,j:o}=t;const{k:r}=t;return"rect"===e&&"lat"===i?(s+=1,o-=1):"rect"===e&&"lng"===i?(s-=1,o+=1):"hex"===e&&"lat"===i?(s+=1,o-=1):"hex"===e&&"lng"===i&&(s-=1,o+=1),{northWest:{i:s,j:o,k:r}}}function s(t){const{type:e}=t.params;let{i:n,j:i,k:s}=t;return"rect"===e?(n+=1,i+=1):"hex"===e&&(n+=1,s-=1),{northEast:{i:n,j:i,k:s}}}function o(t){const{type:e}=t.params;let{i:n,j:i,k:s}=t;return"rect"===e?(n-=1,i-=1):"hex"===e&&(n-=1,s+=1),{southWest:{i:n,j:i,k:s}}}function r(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:s,j:o}=t;const{k:r}=t;return"rect"===e&&"lat"===i?(s-=1,o+=1):"rect"===e&&"lng"===i?(s+=1,o-=1):"hex"===e&&"lat"===i?(s-=1,o+=1):"hex"===e&&"lng"===i&&(s+=1,o-=1),{southEast:{i:s,j:o,k:r}}}function a(t){const{type:e,geoAxes:n}=t.params,o=n[0].name;let{i:r,j:a,k:c}=t;if("rect"===e&&"lat"===o)r+=1;else if("rect"===e&&"lng"===o)a+=1;else if("hex"===e&&"lat"===o)a+=1,c-=1;else if("hex"===e&&"lng"===o)return Object.assign({},s(t),i(t));return{north:{i:r,j:a,k:c}}}function c(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:s,j:a,k:c}=t;if("rect"===e&&"lat"===i)s-=1;else if("rect"===e&&"lng"===i)a-=1;else if("hex"===e&&"lng"===i)a-=1,c+=1;else if("hex"===e&&"lat"===i)return Object.assign({},r(t),o(t));return{south:{i:s,j:a,k:c}}}function u(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:o,j:a,k:c}=t;if("rect"===e&&"lat"===i)a+=1;else if("rect"===e&&"lng"===i)o-=1;else{if("hex"===e&&"lng"===i)return Object.assign({},r(t),s(t));"hex"===e&&"lat"===i&&(a+=1,c-=1)}return{east:{i:o,j:a,k:c}}}function h(t){const{type:e,geoAxes:n}=t.params,s=n[0].name;let{i:r,j:a,k:c}=t;if("rect"===e&&"lat"===s)a-=1;else if("rect"===e&&"lng"===s)r+=1;else{if("hex"===e&&"lng"===s)return Object.assign({},o(t),i(t));"hex"===e&&"lat"===s&&(a-=1,c+=1)}return{west:{i:r,j:a,k:c}}}Object.defineProperty(e,"__esModule",{value:!0}),e.getAll=function(t){const{type:e,geoAxes:n}=t.params,l=n[0].name;return"hex"===e&&"lat"===l?Object.assign({},a(t),c(t),r(t),o(t),s(t),i(t)):"hex"===e&&"lng"===l?Object.assign({},u(t),h(t),r(t),o(t),s(t),i(t)):Object.assign({},a(t),c(t),u(t),h(t),r(t),o(t),s(t),i(t))},e.getNorthWest=i,e.getNorthEast=s,e.getSouthWest=o,e.getSouthEast=r,e.getNorth=a,e.getSouth=c,e.getEast=u,e.getWest=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(5);e.round=function(t){const{type:e}=t.params;if("hex"===e){const{i:e,j:n,k:s}=t;return function(t){const e=function(t){return Object.keys(t).reduce((e,n)=>{const s=t[n],o=i.decRemain(s);return e[n]=o,e},{})}(t),n=Object.keys(e).sort((t,n)=>e[n]-e[t]);let s=Object.values(e).reduce((t,e)=>t+e,0);return s=Math.round(s),n.reduce((e,n)=>(s>0?(e[n]=Math.ceil(t[n]),s-=1):e[n]=Math.floor(t[n]),e),{})}({i:e,j:n,k:s})}{const{i:e,j:n}=t;return function(t){return Object.keys(t).reduce((e,n)=>(e[n]=Math.round(t[n]),e),{})}({i:e,j:n})}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(17),s=n(7),o=n(48);class r extends s.GridPoint{get nearestPeaks(){return o.calcNearestPeaks(this).map(({i:t,j:e,k:n})=>{const i=new r(this.params,t,e,n).toGeo(),o=s.GridPoint.fromGeo(i,this.params);return new r(this.params,o.i,o.j,o.k)})}get nearestPeaksGeo(){return this.nearestPeaks.map(t=>t.toGeo())}static fromGeo(t,e){const{i:n,j:i,k:o}=s.GridPoint.fromGeo(t,e);return new r(e,n,i,o)}toFormatted(){const{params:t,i:e,j:n,k:i}=this;return new r(t,+e.toFixed(6),+n.toFixed(6),i&&+i.toFixed(6))}nearestNotSeparatedByPoly(t){const{nearestPeaks:e}=this;return e.reduce((e,n)=>{const s=i.CellSide.fromPeaks(this,n);return!t.intersectsSegment(s)&&e.push(n),e},[])}}e.PeakPoint=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calcNearestPeaks=function(t){const{type:e}=t.params;return"hex"===e?function({i:t,j:e,k:n}){return 2===Math.round(t%1*3)?[{i:t+2/3,j:e-1/3,k:n-1/3},{i:t-1/3,j:e+2/3,k:n-1/3},{i:t-1/3,j:e-1/3,k:n+2/3}]:[{i:t-2/3,j:e+1/3,k:n+1/3},{i:t+1/3,j:e-2/3,k:n+1/3},{i:t+1/3,j:e+1/3,k:n-2/3}]}(t):function({i:t,j:e}){return[{i:t+1,j:e-1},{i:t+1,j:e+1},{i:t-1,j:e+1},{i:t-1,j:e-1}]}(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(3);e.Cell=i.Cell;var s=n(27);e.Figure=s.Figure;var o=n(59);e.IndexatedFigure=o.IndexatedFigure;var r=n(11);e.GeoPolygon=r.GeoPolygon;var a=n(12);e.GenericPolygon=a.GenericPolygon;var c=n(63);e.MercPolygon=c.MercPolygon;var u=n(64);e.Polygon=u.Polygon;var h=n(65);e.Area=h.Area},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),s=n(26),o=n(17),r=n(20),a=n(51),c=n(52),u=n(53);class h extends r.GeoPolygon{get neighbors(){const{west:t,southWest:e,east:n,southEast:i,south:s,northEast:o,north:r,northWest:a}=this.center.neighbors;return{west:t&&new h(t),southWest:new h(e),east:n&&new h(n),southEast:new h(i),south:s&&new h(s),northEast:new h(o),north:r&&new h(r),northWest:new h(a)}}get northNeighbors(){const{northEast:t,north:e,northWest:n}=this.center.northNeighbors;return{northEast:t&&new h(t),north:e&&new h(e),northWest:n&&new h(n)}}get southNeighbors(){const{southWest:t,southEast:e,south:n}=this.center.southNeighbors;return{southWest:t&&new h(t),southEast:e&&new h(e),south:n&&new h(n)}}get westNeighbors(){const{west:t,southWest:e,northWest:n}=this.center.westNeighbors;return{west:t&&new h(t),southWest:e&&new h(e),northWest:n&&new h(n)}}get eastNeighbors(){const{east:t,southEast:e,northEast:n}=this.center.eastNeighbors;return{east:t&&new h(t),southEast:e&&new h(e),northEast:n&&new h(n)}}get northEastNeighbors(){const{northEast:t}=this.center.northEastNeighbors;return{northEast:new h(t)}}get southWestNeighbors(){const{southWest:t}=this.center.southWestNeighbors;return{southWest:new h(t)}}get northWestNeighbors(){const{northWest:t}=this.center.northWestNeighbors;return{northWest:new h(t)}}get southEastNeighbors(){const{southEast:t}=this.center.southEastNeighbors;return{southEast:new h(t)}}static fromCenter(t){return new h(t)}static fromGeoPoint(t,e){const n=i.CenterPoint.fromGeo(t,e);return new h(n)}static fromGridPoint(t){const e=i.CenterPoint.fromGrid(t);return new h(e)}static fromCenterPoint(t){return new h(t)}constructor(t){const e=a.expand(t).map(({i:e,j:n,k:i})=>new s.PeakPoint(t.params,e,n,i));super(e.map(t=>t.toGeo().toFormatted())),this.peaks=e,this.center=t}findEqualGeoPoint(t){return this.points.find(e=>e.isEqual(t))}intersectedWithSegmentNeighbor(t){return u.getIntersectedWithSegmentNeighbor(this,t)}intersectedWithSegmentsNeighbors(t){return t.reduce((t,e)=>{const n=this.intersectedWithSegmentNeighbor(e);return n&&!t.find(t=>t.isEqual(n))&&t.push(n),t},[])}nearestPeaks(t){const e=[],n=this.prevPeak(t),i=this.nextPeak(t);return n&&e.push(n),i&&e.push(i),e}nearestPeaksGeo(t){const e=[],n=this.prevPeakGeo(t),i=this.nextPeakGeo(t);return n&&e.push(n),i&&e.push(i),e}prevPeak(t){const e=this.peaks.findIndex(e=>t.isEqual(e));if(-1!==e)return this.prevPeakByIndex(e)}nextPeak(t){const e=this.peaks.findIndex(e=>t.isEqual(e));if(-1!==e)return this.nextPeakByIndex(e)}prevPeakGeo(t){const e=this.points.findIndex(e=>t.isEqual(e));if(-1!==e)return this.prevPointByIndex(e)}nextPeakGeo(t){const e=this.points.findIndex(e=>t.isEqual(e));if(-1!==e)return this.nextPointByIndex(e)}nextPeakByIndex(t){const e=this.nextIndex(t);return this.peaks[e]}prevPeakByIndex(t){const e=this.prevIndex(t);return this.peaks[e]}isEqual(t){return this.center.isEqual(t.center)}sideByIndex(t){const{pointA:e,pointB:n}=super.sideByIndex(t),i=this.points.indexOf(e),s=this.points.indexOf(n);return new o.CellSide(e,n,this.peaks[i],this.peaks[s],this.center.params)}nextCellBySide(t){const e=this.center.nextCenterByCellSide(t);return new h(e)}containsPoint(t){const e=i.CenterPoint.fromGeo(t,this.center.params);return this.center.isEqual(e)}nearestToEndIntersectedSide(t){const{pointB:e}=t;if(this.containsPoint(e))return;const n=this.reduceSides((n,i)=>{const s=i.intersectionPoint(t);if(s){n[e.calcMercDistance(s)]=i}return n},{}),i=Object.keys(n).map(t=>+t);return 0!==i.length?n[Math.min(...i)]:void 0}nextCellOnSegment(t){const{pointA:e,pointB:n}=t,s=i.CenterPoint.fromGeo(e,this.center.params),o=i.CenterPoint.fromGeo(n,this.center.params);if(s.isEqual(o))return;const r=this.nearestToEndIntersectedSide(t);return r?this.nextCellBySide(r):void 0}isNeighbor(t){return this.center.isNeighbor(t.center)}commonPoints(t){return c.getCommonPoints(this,t)}moveByDiff(t,e){const n=this.center.moveByDiff(t,e);return h.fromCenter(n)}}e.Cell=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.expand=function(t){const{type:e}=t.params;return"hex"===e?function({i:t,j:e,k:n}){return[{i:t-2/3,j:e+1/3,k:n+1/3},{i:t-1/3,j:e-1/3,k:n+2/3},{i:t+1/3,j:e-2/3,k:n+1/3},{i:t+2/3,j:e-1/3,k:n-1/3},{i:t+1/3,j:e+1/3,k:n-2/3},{i:t-1/3,j:e+2/3,k:n-1/3}]}(t):function({i:t,j:e}){return[{i:t+.5,j:e-.5},{i:t+.5,j:e+.5},{i:t-.5,j:e+.5},{i:t-.5,j:e-.5}]}(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getCommonPoints=function(t,e){const{params:n}=t.center;let i,s;if(t.center.isCloserThroughAntiMeridian(e.center)){const n=t.center.toOppositeHemishpere(),o=e.center.toOppositeHemishpere();i=o.i-n.i,s=o.j-n.j}else i=e.center.i-t.center.i,s=e.center.j-t.center.j;return("hex"===n.type?function(t,e){return 0===t&&0===e?[0,1,2,3,4,5]:1===t&&0===e?[3,4]:-1===t&&0===e?[0,1]:0===t&&1===e?[4,5]:0===t&&-1===e?[1,2]:-1===t&&1===e?[5,0]:1===t&&-1===e?[2,3]:[]}(i,s):function(t,e){return 0===t&&0===e?[0,1,2,3]:1===t&&0===e?[0,1]:-1===t&&0===e?[2,3]:0===t&&1===e?[1,2]:0===t&&-1===e?[3,0]:1===t&&1===e?[1]:-1===t&&1===e?[2]:-1===t&&-1===e?[3]:1===t&&-1===e?[0]:[]}(i,s)).map(e=>t.points[e])}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getIntersectedWithSegmentNeighbor=function(t,e){if(t.intersectsWithSegment(e).length>0)return t;const n=t.closestSideToSegment(e),i=t.nextCellBySide(n);return i.intersectsWithSegment(e).length>0?i:void 0}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(20),s=n(55),o=n(58);class r extends i.GeoPolygon{constructor(t,e,n,i){super(t),this.shape=e,this.params=n,this.isInner=i}static resetWorker(){r.worker&&(r.worker.terminate(),r.worker=void 0)}static async setGridParams(t){r.worker||(r.worker=new s.FigureWorker),await r.worker.postParams(t)}static async fromShape(t,e,n=!0){r.worker||(r.worker=new s.FigureWorker),await r.worker.postParams(e);const i=await r.worker.buildPoly(t,n);return new r(i,t,e,n)}static async validateShape(t,e){let n;return r.worker||"undefined"==typeof window||(r.worker=new s.FigureWorker),n=r.worker?await r.worker.validateShape(t,e):{points:t.selfIntersections,cells:o.getInvalidCells(t,e)},n}}e.Figure=r},function(t,e,n){"use strict";var i=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const s=n(13),o=i(n(57)),r=n(8),a=n(3);e.FigureWorker=class{constructor(){this.worker=new s.WorkerService(new o.default)}terminate(){this.worker.terminate()}async postParams(t){await this.worker.post({type:"params",payload:{params:t.toPlain()}})}async buildPoly(t,e){const{data:n}=await this.worker.post({type:"build-poly",payload:{shape:t.toPlain(),isInner:e}});return n.points.map(t=>r.GeoPoint.fromPlain(t))}async validateShape(t,e){const{data:{centers:n,points:i}}=await this.worker.post({type:"validate",payload:{shape:t.toPlain(),params:e.toPlain()}});return{points:i.map(t=>r.GeoPoint.fromPlain(t)),cells:n.map(t=>a.Cell.fromCenter(r.CenterPoint.fromPlain(t,e)))}}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.CtxService=class{constructor(t){this.worker=t,this.handleMessage=t=>{"terminate"!==t.data?this.messageHandler&&this.messageHandler(t):this.close()},this.handleError=t=>{this.errorHandler&&this.errorHandler(t)},this.worker.addEventListener("message",this.handleMessage),this.worker.addEventListener("error",this.handleError)}post(t){this.worker.postMessage(t)}onMessage(t){this.messageHandler=t}onError(t){this.errorHandler=t}close(){this.unmount(),close()}unmount(){this.worker.removeEventListener("message",this.handleMessage),this.worker.removeEventListener("error",this.handleError)}}},function(t,e,n){t.exports=function(){return n(14)('!function(t){var e={};function n(i){if(e[i])return e[i].exports;var s=e[i]={i:i,l:!1,exports:{}};return t[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var s in t)n.d(i,s,function(e){return t[e]}.bind(null,s));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=15)}([function(t,e,n){"use strict";function i(t){return t*Math.PI/180}Object.defineProperty(e,"__esModule",{value:!0}),e.floorNumStrByOrder=function(t){const e=t.length;if(t.split("").every(t=>"0"===t))return t;if(t.lastIndexOf(".")===e-2)return Math.floor(+t)+"";if(-1!==t.indexOf("."))return t.slice(0,-1);if(-1===t.indexOf("0"))return t.slice(0,-1)+"0";{const n=t.lastIndexOf("0");return t.slice(0,n-1)+"0".repeat(e-n+1)}},e.calcClosestMultiple=function(t,e){let n=t,i=t;for(;e%n!=0&&e%i!=0;)n+=1,i-=1;return e%n==0?n:i},e.cosDeg=function(t){const e=i(t);return Math.cos(e)},e.sinDeg=function(t){const e=i(t);return Math.sin(e)},e.findPrimeFactors=function(t){if(t<2)return[];let e=t,n=2;const i=[];for(;n*n<=e;)e%n==0?(i.push(n),e/=n):n+=1;return 1!==e&&i.push(e),i},e.degToRad=i,e.radToDeg=function(t){return 180*t/Math.PI},e.decRemain=function(t){return t-Math.floor(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2),s=n(3);class r{constructor(t,e){this.lat=t,this.lng=e}static createFormatted(t,e){return t=i.formatLat(t),e=i.formatLng(e),new r(t,e)}static fromUnsafeCoords(t,e){return t=i.reduceLat(t),e=i.reduceLng(e),new r(t,e)}static fromMerc(t){const{lat:e,lng:n}=t.toSphereLiteral();return new r(e,n)}isEqual(t){const e=this.toFormatted(),n=t.toFormatted();return e.lat===n.lat&&e.lng===n.lng}isCloserThroughAntiMeridian(t){const e=Math.min(this.lng,t.lng);return Math.max(this.lng,t.lng)-e>180}toOppositeHemisphere(){const t=i.reduceLng(this.lng-180);return new r(this.lat,t)}calcMercDistance(t){let e=this;this.isCloserThroughAntiMeridian(t)&&(e=this.toOppositeHemisphere(),t=t.toOppositeHemisphere());const n=e.toMerc(),i=t.toMerc();return n.distanceToPoint(i)}toMerc(){const t=i.lngToX(this.lng),e=i.latToY(this.lat);return new s.MercPoint(t,e)}toSemiSphere(){const{lat:t,lng:e}=this.toMerc().toSemiSphereLiteral();return new r(t,e)}fromSemiSphere(){const t=i.semiLngToX(this.lng),e=i.semiLatToY(this.lat),{lat:n,lng:o}=new s.MercPoint(t,e).toSphereLiteral();return new r(n,o)}toFormatted(){const t=i.formatLat(this.lat),e=i.formatLng(this.lng);return new r(t,e)}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng<t.lng:this.lng>t.lng}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng>t.lng:this.lng<t.lng}isNorthernTo(t){return this.lat>t.lat}isSouthernTo(t){return this.lat<t.lat}toPlain(){const{lat:t,lng:e}=this;return{lat:t,lng:e}}toGeoJSON(){return{type:"Point",coordinates:[this.lng,this.lat]}}static fromPlain({lat:t,lng:e}){return new r(t,e)}static fromGeoJSON({coordinates:[t,e]}){return r.fromPlain({lat:e,lng:t})}}e.GeoPoint=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0);function s(t){return(t>360||t<-360)&&(t%=360),t>=180?t-360:t<-180?t+360:t}e.semiLatToY=function(t){return-t/180+.5},e.semiLngToX=function(t){return t/360+.5},e.latToY=function(t){return(-Math.log(Math.tan(Math.PI/4+i.degToRad(t)/2))/Math.PI+1)/2},e.lngToX=function(t){return(i.degToRad(t)/Math.PI+1)/2},e.formatLat=function(t){return t>90&&(t=90),t<-90&&(t=-90),+t.toFixed(7)},e.formatLng=function(t){return+(t=s(t)).toFixed(7)},e.reduceLat=function(t){return(t>360||t<-360)&&(t%=360),t>90?180-t:t<-90?-180+t:t},e.reduceLng=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(7),s=n(8);class r extends i.Point{constructor(t,e){super(t=s.reduceX(t),e)}toFormatted(){return new r(+this.x.toFixed(10),+this.y.toFixed(10))}toOppositeHemisphere(){const t=s.reduceX(this.x-.5);return new r(t,this.y)}calcMercDistance(t){return(this.isCloserThroughAntiMeridian(t)?this.toOppositeHemisphere():this).distanceToPoint(t)}isCloserThroughAntiMeridian(t){const e=Math.min(this.x,t.x);return Math.max(this.x,t.x)-e>1}toSphereLiteral(){return{lat:s.yToLat(this.y),lng:s.xToLng(this.x)}}toSemiSphereLiteral(){return{lat:s.yToSemiLat(this.y),lng:s.xToSemiLng(this.x)}}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x<t.x:this.x>t.x}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x>t.x:this.x<t.x}isNorthernTo(t){return this.y>t.y}isSouthernTo(t){return this.y<t.y}}e.MercPoint=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(28);e.Cell=i.Cell},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(31);e.GridPoint=i.GridPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1),s=n(9),r=n(26);class o extends r.GenericPolygon{sideByIndex(t){const{pointA:e,pointB:n}=super.sideByIndex(t);return new s.GeoSegment(e,n)}sideByIndexInversed(t){const{pointA:e,pointB:n}=super.sideByIndexInversed(t);return new s.GeoSegment(e,n)}splitSectionsByLng(t){const e=this.reduceSides((e,n)=>{const s=n.latByLng(t);if(void 0===s)return e;const r=new i.GeoPoint(s,t);return e.find(t=>t.isEqual(r))||e.push(r),e},[]);return s.GeoSegment.segmentsFromPointsByLat(e)}splitSectionsByLat(t){const e=this.reduceSides((e,n)=>{const s=n.lngByLat(t);if(void 0!==s){const n=new i.GeoPoint(t,s);e.push(n)}return e},[]);return s.GeoSegment.segmentsFromPointsByLng(e)}intersectsSegment(t){return super.intersectsSegment(t)}intersectsWithSegment(t){return super.intersectsWithSegment(t)}closestSideToSegment(t){const[e,n]=this.pointsByDistanceToSegment(t),i=this.points.indexOf(e),s=this.points.indexOf(n);return this.sideByIndex(Math.min(i,s))}pointsByDistanceToSegment(t){return[...this.points].sort((e,n)=>{return t.mercDistanceToPoint(e)-t.mercDistanceToPoint(n)})}pointsInsidePoly(t){return this.points.filter(e=>t.containsPoint(e))}pointsOutsidePoly(t){return this.points.filter(e=>!t.containsPoint(e))}arePointsInsidePoly(t){return this.points.every(e=>t.containsPoint(e))}arePointsOutsidePoly(t){return this.points.every(e=>!t.containsPoint(e))}containsPoint(t){return this.splitSectionsByLat(t.lat).reduce((e,n)=>e||n.containsLng(t.lng),!1)}isValidForFigure(t){if(this.outmapPoints.length>0)return!1;if(this.points.length<3)return!1;const{selfIntersections:e}=this;return!(e.length>0)}get outmapPoints(){return this.points.filter(t=>{const{y:e}=t.toMerc();return e>1||e<0})}get easternPoint(){return this.points.reduce((t,e)=>e.isEasternTo(t)?e:t,this.points[0])}get westernPoint(){return this.points.reduce((t,e)=>e.isWesternTo(t)?e:t,this.points[0])}get northernPoint(){return this.points.reduce((t,e)=>e.isNorthernTo(t)?e:t,this.points[0])}get southernPoint(){return this.points.reduce((t,e)=>e.isSouthernTo(t)?e:t,this.points[0])}toPlain(){return this.points.map(t=>t.toPlain())}toGeoJSON(){return{type:"Polygon",coordinates:[[...this.points,this.points[0]].map(({lat:t,lng:e})=>[e,t])]}}static fromGeoJSON({coordinates:[t]}){const e=i.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[0]}),n=i.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[t.length-1]});if(!e.isEqual(n))throw new Error("Loop is not closed");return o.fromPlain(t.slice(0,-1).map(([t,e])=>({lat:e,lng:t})))}static fromPlain(t){return new o(t.map(({lat:t,lng:e})=>new i.GeoPoint(t,e)))}}e.GeoPolygon=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class i{constructor(t,e){this.x=t,this.y=e}distanceToPoint({x:t,y:e}){return Math.sqrt(Math.pow(t-this.x,2)+Math.pow(e-this.y,2))}toFormatted(){return this}toPlain(){return{x:this.x,y:this.y}}static fromPlain({x:t,y:e}){return new i(t,e)}containedByLine(t){return t.hasPoint(this)}containedBySegment(t){return t.hasPoint(this)}isEqual(t){const e=this.toFormatted(),n=t.toFormatted();return e.x===n.x&&e.y===n.y}distanceToLine(t){return t.distanceToPoint(this)}closestOnLine(t){return t.closestToPoint(this)}closestOnSegment(t){return t.closestToPoint(this)}}e.Point=i},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0);e.yToLat=function(t){const e=Math.atan(Math.E**(-(2*t-1)*Math.PI))-Math.PI/4;return 2*i.radToDeg(e)},e.xToLng=function(t){const e=(2*t-1)*Math.PI;return i.radToDeg(e)},e.yToSemiLat=function(t){return 180*-(t-.5)},e.xToSemiLng=function(t){return 360*(t-.5)},e.reduceX=function(t){return t%=1}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2),s=n(22),r=n(1),o=n(24);class a{constructor(t,e){this.pointA=t,this.pointB=e,this.rhumbLine=s.RhumbLine.fromTwoGeoPoints(t,e)}get points(){return[this.pointA,this.pointB]}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallel(){return this.pointA.lat===this.pointB.lat}get isMeridian(){return this.pointA.lat===this.pointB.lat}get easternPoint(){return this.isMeridian?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isMeridian?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallel?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallel?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}static segmentsFromPointsByLng(t){const e=t.sort(({lng:t},{lng:e})=>t-e),n=e.reduce((t,n,i)=>e[t].isEasternTo(n)?i:t,0);return[...e.slice(n),...e.slice(0,n)].reduce((t,e,n,i)=>{if(n%2)return t;const s=new a(i[n+1],e);return t.push(s),t},[])}static segmentsFromPointsByLat(t){return t.sort(({lat:t},{lat:e})=>t-e).reduce((t,e,n,i)=>{if(n%2)return t;const s=new a(i[n+1],e);return t.push(s),t},[])}toMerc(){const t=this.pointA.toMerc(),e=this.pointB.toMerc();return new o.MercSegment(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new a(t,e)}intersectsWithPoly(t){return t.intersectsWithSegment(this)}intersects(t){return!!this.intersectionPoint(t)}intersectionPoint(t){let e=this,n=t;const i=this.isAntiMeridian||t.isAntiMeridian;i&&(e=e.toOppositeHemisphere(),n=n.toOppositeHemisphere());const s=e.toMerc(),o=n.toMerc(),a=s.intersectionPoint(o);if(!a)return;const c=r.GeoPoint.fromMerc(a);return i?c.toOppositeHemisphere():c}closestToPoint(t){const{isAntiMeridian:e}=this;let n=this;e&&(n=n.toOppositeHemisphere(),t=t.toOppositeHemisphere());const i=t.toMerc(),s=n.toMerc().closestToPoint(i),o=r.GeoPoint.fromMerc(s);return e?o.toOppositeHemisphere():o}isEqual({pointA:t,pointB:e}){return this.pointA.isEqual(t)&&this.pointB.isEqual(e)||this.pointA.isEqual(e)&&this.pointB.isEqual(t)}mercDistanceToPoint(t){const e=this.closestToPoint(t);return t.calcMercDistance(e)}latByLng(t){if(!this.containsLng(t))return;const e=this.rhumbLine.latByLng(t);return void 0===e||0!==this.rhumbLine.a&&!this.containsLat(e)?void 0:e}lngByLat(t){if(!this.containsLat(t))return;const e=this.rhumbLine.lngByLat(t);return void 0===e||0!==this.rhumbLine.b&&!this.containsLng(e)?void 0:e}containsLat(t){t=i.formatLat(t);const{lat:e}=this.pointA.toFormatted(),{lat:n}=this.pointB.toFormatted();return Math.max(e,n)>=t&&Math.min(e,n)<=t}containsLng(t){t=i.formatLng(t);const{lng:e}=this.pointA.toFormatted(),{lng:n}=this.pointB.toFormatted(),s=Math.max(e,n),r=Math.min(e,n);return this.isAntiMeridian?s<=t&&t<180||r>=t&&t>=-180:s>=t&&r<=t}containsPoint({lat:t,lng:e}){return this.containsLat(t)&&this.containsLng(e)}containsSegment({pointA:t,pointB:e}){return this.containsPoint(t)&&this.containsPoint(e)}overlapsSegment(t){const{pointA:e,pointB:n}=t;return this.containsPoint(e)||this.containsPoint(n)||t.containsPoint(this.pointB)||t.containsPoint(this.pointB)}}e.GeoSegment=a},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(3),s=n(11);class r extends s.Line{static fromTwoPoints(t,e){const{a:n,b:i,c:o}=s.Line.fromTwoPoints(t,e);return new r(n,i,o)}calcAlikePoint(t){const{x:e,y:n}=super.calcAlikePoint(t);return new i.MercPoint(e,n)}closestToPoint(t){const{x:e,y:n}=super.closestToPoint(t);return new i.MercPoint(e,n)}perpendicularByPoint(t){const{a:e,b:n,c:i}=super.perpendicularByPoint(t);return new r(e,n,i)}intersectionPoint(t){const e=super.intersectionPoint(t);if(!e)return;const{x:n,y:s}=e;return new i.MercPoint(n,s)}}e.MercLine=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(7),s=n(23);class r{constructor(t,e,n){this.a=t,this.b=e,this.c=n}get isParallelToAxisX(){return 0===this.b}get isParallelToAxisY(){return 0===this.a}static fromTwoPoints({x:t,y:e},{x:n,y:i}){return new r(e-i,n-t,-(t*i-e*n))}calcAlikePoint(t){const e=this.xByY(t.y),n=this.yByX(t.x);return new i.Point(void 0===e?t.x:e,void 0===n?t.y:n)}hasPoint(t){return this.calcAlikePoint(t).isEqual(t)}xByY(t){if(!this.isParallelToAxisY)return(this.c-this.b*t)/this.a}yByX(t){if(!this.isParallelToAxisX)return(this.c-this.a*t)/this.b}distanceToPoint(t){const e=this.closestToPoint(t);return t.distanceToPoint(e)}getNormalVector(){return new s.Vector(this.a,this.b)}closestToPoint(t){const{x:e,y:n}=t;if(this.isParallelToAxisX)return new i.Point(this.c/this.a,n);if(this.isParallelToAxisY)return new i.Point(e,this.c/this.b);const s=this.perpendicularByPoint(t);return this.intersectionPoint(s)}perpendicularByPoint({x:t,y:e}){const{x:n,y:i}=this.getNormalVector();return new r(1/n,-1/i,t/n-e/i)}intersectionX({a:t,b:e,c:n}){const i=this.a*e-this.b*t,s=this.c*e-this.b*n;if(i)return s/i}intersectionY({a:t,b:e,c:n}){const i=this.a*e-this.b*t,s=this.a*n-this.c*t;if(i)return s/i}intersectionPoint(t){if(t.isParallelToAxisX&&this.isParallelToAxisX||t.isParallelToAxisY&&this.isParallelToAxisY)return;const{a:e,b:n,c:s}=t;let r,o;return r=t.isParallelToAxisX?s/e:this.isParallelToAxisX?this.c/this.a:this.intersectionX(t),o=t.isParallelToAxisY?s/n:this.isParallelToAxisY?this.c/this.b:this.intersectionY(t),void 0===r&&void 0!==o&&(r=this.xByY(o)||t.xByY(o)),void 0!==r&&void 0===o&&(o=this.yByX(r)||t.yByX(r)),void 0!==r&&void 0!==o?new i.Point(r,o):void 0}}e.Line=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(38);e.PeakPoint=i.PeakPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(5),s=n(9);class r extends s.GeoSegment{constructor(t,e,n,i,s){super(t,e),this.peakA=n,this.peakB=i,this.params=s}get averagePoint(){const{i:t,j:e,k:n,params:s}=this.peakA,{i:r,j:o,k:a}=this.peakB;return new i.GridPoint(s,(t+r)/2,(e+o)/2,void 0!==n&&void 0!==a?(n+a)/2:void 0)}static fromPeaks(t,e){const n=t.toGeo(),i=e.toGeo();return new r(n,i,t,e,t.params)}}e.CellSide=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(4);e.getInvalidCells=function(t,e){return t.reduceNeighboringSidesPairs((n,s,r)=>{const o=function(t,e,n,s=3){const r=i.Cell.fromGeoPoint(t.pointA,n),o=[];let a,c;for(let n=0;n<s;n+=1){c=c?c.nextCellOnSegment(t):r,a=a?a.nextCellOnSegment(e):r;const n=!!o.find(t=>!!c&&t.isEqual(c)),i=!!o.find(t=>!!a&&t.isEqual(a));c&&!n&&o.push(c),a&&!i&&o.push(a)}return o}(s,r,e),a=t.reduceSides((t,e)=>(e.isEqual(s)||e.isEqual(r)||t.push(e),t),[]),c=o.reduce((t,e)=>{const n=e.intersectedWithSegmentsNeighbors(a).filter(e=>!t.find(t=>t.isEqual(e)));return t.push(...n),t},[]).filter(t=>!n.find(e=>e.isEqual(t)));return n.push(...c),n},[])}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(16),s=n(17),r=n(21),o=n(27),a=n(14),c=self,u=new i.CtxService(c);let h;u.onMessage(t=>{const{type:e}=t.data;if("params"===e){const{params:e}=t.data.payload;return h=s.GridParams.fromPlain(e),void u.post("")}if("build-poly"===e){if(!h)throw new Error("Grid Params wasn\'t defined");const{shape:e,isInner:n}=t.data.payload,i=o.buildFigurePoints(r.GeoPolygon.fromPlain(e),h,n);u.post({points:i.map(t=>t.toPlain())})}if("validate"===e){const{shape:e,params:n}=t.data.payload,i=r.GeoPolygon.fromPlain(e),o=i.selfIntersections,c=a.getInvalidCells(i,s.GridParams.fromPlain(n));u.post({centers:c.map(({center:t})=>t.toPlain()),points:o.map(t=>t.toPlain())})}}),e.default={}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.CtxService=class{constructor(t){this.worker=t,this.handleMessage=t=>{"terminate"!==t.data?this.messageHandler&&this.messageHandler(t):this.close()},this.handleError=t=>{this.errorHandler&&this.errorHandler(t)},this.worker.addEventListener("message",this.handleMessage),this.worker.addEventListener("error",this.handleError)}post(t){this.worker.postMessage(t)}onMessage(t){this.messageHandler=t}onError(t){this.errorHandler=t}close(){this.unmount(),close()}unmount(){this.worker.removeEventListener("message",this.handleMessage),this.worker.removeEventListener("error",this.handleError)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(18);e.GridParams=i.GridParams},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(19);class s{static fromConfig({isHorizontal:t=!1,type:e,correction:n,cellSize:r}){const o=t?"horizontal":"vertical",a=i.initCoofs[e][n][o],c=i.axesParams[e],u=i.calcAxesParams(t,e),h=i.calcInitialCellWidth(r,a),l=i.calcInitialCellHeight(r);return new s({isHorizontal:t,type:e,axes:c,geoAxes:u,initSize:h,initHeight:l,correction:n})}constructor({isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:s,initHeight:r,correction:o}){this.isHorizontal=t,this.type=e,this.axes=n,this.geoAxes=i,this.initSize=s,this.initHeight=r,this.correction=o}minCellSize(t){const{tileWidth:e,zoomCoofX:n}=t,{initSize:i,initHeight:s,isHorizontal:r}=this;return(r?i:s)/1e7*e*n/360}isEqual(t){return this.isHorizontal===t.isHorizontal&&this.type===t.type&&this.correction===t.correction&&this.initSize===t.initSize}toPlain(){const{isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:s,initHeight:r,correction:o}=this;return{isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:s,initHeight:r,correction:o}}static fromPlain(t){return new s(t)}}e.GridParams=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(20),s=n(0),r=Math.sqrt(3)/2;e.axesParams={get hex(){return[{name:"i",angle:0},{name:"j",angle:120},{name:"k",angle:240}]},get rect(){return[{name:"i",angle:0},{name:"j",angle:90}]}},e.initCoofs={hex:{get merc(){return{vertical:.5*r,horizontal:.5}},get none(){return{vertical:r,horizontal:1}},get area(){return{vertical:r,horizontal:1}}},rect:{get merc(){return{vertical:.5,horizontal:.5}},get none(){return{vertical:1,horizontal:1}},get area(){return{vertical:2,horizontal:.5}}}},e.calcAxesParams=function(t,e){let n;switch(e){case"hex":n=120;break;case"rect":default:n=90}return[{name:t?"lng":"lat",angle:0},{name:t?"lat":"lng",angle:n}]},e.calcInitialCellWidth=function(t,e){const n=i.constants.equatorLength/36e8,r=Math.round(t/n);let o=s.calcClosestMultiple(r,36e8);return o>18e8&&(o=18e8),o<1&&(o=1),o*e},e.calcInitialCellHeight=function(t){const e=i.constants.meridianLength/36e8,n=Math.round(t/e);let r=s.calcClosestMultiple(n,18e8);return r>18e8&&(r=18e8),r<1&&(r=1),r}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.constants={equatorLength:40075696,radius:6370997,meridianLength:40007860,googleTileSize:256}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(6);e.GeoPolygon=i.GeoPolygon},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2),s=n(8),r=n(10);class o extends r.MercLine{static fromTwoGeoPoints(t,e){const n=t.isCloserThroughAntiMeridian(e);n&&(t=t.toOppositeHemisphere(),e=e.toOppositeHemisphere());const{a:i,b:s,c:a}=r.MercLine.fromTwoPoints(t.toMerc(),e.toMerc());return new o(i,s,a,n)}constructor(t,e,n,i){super(t,e,n),this.isAntiMeridian=i}lngByLat(t){const e=i.latToY(t),n=this.xByY(e);if(void 0===n)return;let r=s.xToLng(n);return this.isAntiMeridian&&(r=i.reduceLng(r-180)),r}latByLng(t){this.isAntiMeridian&&(t=i.reduceLng(t-180));const e=i.lngToX(t),n=this.yByX(e);if(void 0!==n)return s.yToLat(n)}}e.RhumbLine=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Vector=class{constructor(t,e){this.x=t,this.y=e}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(10),s=n(3),r=n(25);class o extends r.Segment{constructor(t,e){super(t,e),this.pointA=t,this.pointB=e,this.line=i.MercLine.fromTwoPoints(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new o(t,e)}intersectionPoint(t){if(!this.isAntiMeridian&&!t.isAntiMeridian){const e=super.intersectionPoint(t);return e&&new s.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere(),n=t.toOppositeHemisphere(),i=e.intersectionPoint(n);return i&&i.toOppositeHemisphere()}closestToPoint(t){if(!this.isAntiMeridian){const e=super.closestToPoint(t);return new s.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere();return t=t.toOppositeHemisphere(),e.closestToPoint(t).toOppositeHemisphere()}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallelToAxisX(){return this.line.isParallelToAxisX}get isParallelToAxisY(){return this.line.isParallelToAxisY}get easternPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}}e.MercSegment=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(11);e.Segment=class{constructor(t,e){this.pointA=t,this.pointB=e,this.line=i.Line.fromTwoPoints(t,e)}get minX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.min(t,e)}get maxX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.max(t,e)}get minY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.min(t,e)}get maxY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.max(t,e)}get minXPoint(){const{x:t}=this.pointA;return this.minX===t?this.pointA:this.pointB}get maxXPoint(){const{x:t}=this.pointA;return this.maxX===t?this.pointA:this.pointB}get minYPoint(){const{y:t}=this.pointA;return this.minY===t?this.pointA:this.pointB}get maxYPoint(){const{y:t}=this.pointA;return this.maxY===t?this.pointA:this.pointB}closestToPoint(t){const e=this.line.closestToPoint(t).toFormatted(),{x:n,y:i}=this.pointA.toFormatted(),{x:s,y:r}=this.pointB.toFormatted();return e.x<Math.min(n,s)?this.minXPoint:e.x>Math.max(n,s)?this.maxXPoint:e.y<Math.min(i,r)?this.minYPoint:e.y>Math.max(i,r)?this.maxYPoint:e}hasPoint(t){const{pointA:e,pointB:n}=this,{x:i,y:s}=t.toFormatted(),{x:r,y:o}=e.toFormatted(),{x:a,y:c}=n.toFormatted();return this.line.hasPoint(t)&&Math.max(r,a)>=i&&Math.min(r,a)<=i&&Math.max(o,c)>=s&&Math.min(o,c)<=s}intersectionPoint(t){if(this.line.a===t.line.a||this.line.b===t.line.b)return;const e=this.line.intersectionPoint(t.line);if(!e)return;let n,i;const s=Math.max(this.pointA.x,this.pointB.x),r=Math.min(this.pointA.x,this.pointB.x),o=Math.max(this.pointA.y,this.pointB.y),a=Math.min(this.pointA.y,this.pointB.y),c=Math.max(t.pointA.x,t.pointB.x),u=Math.min(t.pointA.x,t.pointB.x),h=Math.max(t.pointA.y,t.pointB.y),l=Math.min(t.pointA.y,t.pointB.y);return n=0===this.line.a?e.x<=s&&e.x>=r&&h>=o&&l<=a:0===this.line.b?e.y<=o&&e.y>=a&&c>=s&&u<=r:this.hasPoint(e),i=0===t.line.a?e.x<=c&&e.x>=u&&o>=h&&a<=l:0===t.line.b?e.y<=h&&e.y>=l&&s>=c&&r<=u:t.hasPoint(e),n&&i?e:void 0}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.GenericPolygon=class{constructor(t){this.points=t}intersectsPoly(t){return this.reduceSides((e,n,i)=>t.reduceSides((t,e,i)=>{const s=n.intersectionPoint(e);return s&&t.push(s),t},e),[])}intersectsSegment(t){return this.reduceSides((e,n)=>!!e||!!n.intersectionPoint(t),!1)}intersectsWithSegment(t){return this.reduceSides((e,n)=>{const i=n.intersectionPoint(t);return i&&e.push(i),e},[])}get selfIntersections(){return this.reduceOppositeSidesPairs((t,e,n)=>{const i=e.intersectionPoint(n);return i&&t.push(i),t},[])}sideByIndex(t){return{pointA:this.points[t],pointB:this.nextPointByIndex(t)}}sideByIndexInversed(t){return{pointA:this.points[t],pointB:this.prevPointByIndex(t)}}nextIndex(t){return t===this.points.length-1?0:t+1}prevIndex(t){const{length:e}=this.points;return 0===t?e-1:t-1}nextPointByIndex(t){const e=this.nextIndex(t);return this.points[e]}prevPointByIndex(t){const e=this.prevIndex(t);return this.points[e]}forEachSide(t){this.points.forEach((e,n)=>{const i=this.sideByIndex(n);t(i,n)})}mapSides(t){return this.points.map((e,n)=>{const i=this.sideByIndex(n);return t(i,n)})}reduceSides(t,e){return this.points.reduce((e,n,i)=>{const s=this.sideByIndex(i);return t(e,s,i)},e)}forEachSidesPair(t){this.forEachSide((e,n)=>{this.forEachSide((i,s)=>{s<=n||t(e,i)})})}reduceSidesPairs(t,e){return this.reduceSides((e,n,i)=>this.reduceSides((e,s,r)=>r<=i?e:t(e,n,s),e),e)}reduceNeighboringSidesPairs(t,e){return this.points.reduce((e,n,i)=>{const s=this.sideByIndexInversed(i),r=this.sideByIndex(i);return t(e,s,r)},e)}reduceOppositeSidesPairs(t,e){const n=this.points.length-1;return this.reduceSides((e,i,s)=>this.reduceSides((e,r,o)=>0===s&&o===n||o-1<=s?e:t(e,i,r),e),e)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(4),s=n(14),r=n(43),o=n(44);function a(t,e,n,i,s){let r=n.points.indexOf(i),o=n.nextPointByIndex(r),a=n.sideByIndex(r),c=a.intersects(t),u=e.containsPoint(o);const h=c||u!==s,l=[];for(h&&(o=n.prevPointByIndex(r),u=e.containsPoint(o),a=n.sideByIndex(n.prevIndex(r)),c=e.intersectsSegment(a));!c&&u===s;){const s=l[l.length-1]||i,a=n.points[r];s.isEqual(a)||l.push(a),c=(h?n.sideByIndexInversed(r):n.sideByIndex(r)).intersects(t),r=h?n.prevIndex(r):n.nextIndex(r),o=n.points[r],u=e.containsPoint(o)}return l}e.buildFigurePoints=function(t,e,n){if(!t.isValidForFigure(e))return[];if(s.getInvalidCells(t,e).length>0)return[];const c=t.reduceSides((s,r)=>(function(t,e,n,s,r){let c,u=!1,h=i.Cell.fromGeoPoint(t.pointA,s);0===n.length?(c=o.findStartPointForSide(t,e,s,r),c&&n.push(c)):c=n[n.length-1];if(!c)return[];const l=i.Cell.fromGeoPoint(t.pointB,s);for(;h&&!h.isEqual(l)&&(u||(h=o.recalcStartCell(n,t,s)),h);){const i=n[n.length-1],s=h.findEqualGeoPoint(i);if(!s)break;!u&&s&&(u=!0);const o=a(t,e,h,s,r);if(n.push(...o),h=h.nextCellOnSegment(t),!h)break}return n})(r,t,s,e,n),[]);return r.cleanFigure(c)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(29),s=n(12),r=n(13),o=n(6),a=n(40),c=n(41),u=n(42);class h extends o.GeoPolygon{get neighbors(){const{west:t,southWest:e,east:n,southEast:i,south:s,northEast:r,north:o,northWest:a}=this.center.neighbors;return{west:t&&new h(t),southWest:new h(e),east:n&&new h(n),southEast:new h(i),south:s&&new h(s),northEast:new h(r),north:o&&new h(o),northWest:new h(a)}}get northNeighbors(){const{northEast:t,north:e,northWest:n}=this.center.northNeighbors;return{northEast:t&&new h(t),north:e&&new h(e),northWest:n&&new h(n)}}get southNeighbors(){const{southWest:t,southEast:e,south:n}=this.center.southNeighbors;return{southWest:t&&new h(t),southEast:e&&new h(e),south:n&&new h(n)}}get westNeighbors(){const{west:t,southWest:e,northWest:n}=this.center.westNeighbors;return{west:t&&new h(t),southWest:e&&new h(e),northWest:n&&new h(n)}}get eastNeighbors(){const{east:t,southEast:e,northEast:n}=this.center.eastNeighbors;return{east:t&&new h(t),southEast:e&&new h(e),northEast:n&&new h(n)}}get northEastNeighbors(){const{northEast:t}=this.center.northEastNeighbors;return{northEast:new h(t)}}get southWestNeighbors(){const{southWest:t}=this.center.southWestNeighbors;return{southWest:new h(t)}}get northWestNeighbors(){const{northWest:t}=this.center.northWestNeighbors;return{northWest:new h(t)}}get southEastNeighbors(){const{southEast:t}=this.center.southEastNeighbors;return{southEast:new h(t)}}static fromCenter(t){return new h(t)}static fromGeoPoint(t,e){const n=i.CenterPoint.fromGeo(t,e);return new h(n)}static fromGridPoint(t){const e=i.CenterPoint.fromGrid(t);return new h(e)}static fromCenterPoint(t){return new h(t)}constructor(t){const e=a.expand(t).map(({i:e,j:n,k:i})=>new s.PeakPoint(t.params,e,n,i));super(e.map(t=>t.toGeo().toFormatted())),this.peaks=e,this.center=t}findEqualGeoPoint(t){return this.points.find(e=>e.isEqual(t))}intersectedWithSegmentNeighbor(t){return u.getIntersectedWithSegmentNeighbor(this,t)}intersectedWithSegmentsNeighbors(t){return t.reduce((t,e)=>{const n=this.intersectedWithSegmentNeighbor(e);return n&&!t.find(t=>t.isEqual(n))&&t.push(n),t},[])}nearestPeaks(t){const e=[],n=this.prevPeak(t),i=this.nextPeak(t);return n&&e.push(n),i&&e.push(i),e}nearestPeaksGeo(t){const e=[],n=this.prevPeakGeo(t),i=this.nextPeakGeo(t);return n&&e.push(n),i&&e.push(i),e}prevPeak(t){const e=this.peaks.findIndex(e=>t.isEqual(e));if(-1!==e)return this.prevPeakByIndex(e)}nextPeak(t){const e=this.peaks.findIndex(e=>t.isEqual(e));if(-1!==e)return this.nextPeakByIndex(e)}prevPeakGeo(t){const e=this.points.findIndex(e=>t.isEqual(e));if(-1!==e)return this.prevPointByIndex(e)}nextPeakGeo(t){const e=this.points.findIndex(e=>t.isEqual(e));if(-1!==e)return this.nextPointByIndex(e)}nextPeakByIndex(t){const e=this.nextIndex(t);return this.peaks[e]}prevPeakByIndex(t){const e=this.prevIndex(t);return this.peaks[e]}isEqual(t){return this.center.isEqual(t.center)}sideByIndex(t){const{pointA:e,pointB:n}=super.sideByIndex(t),i=this.points.indexOf(e),s=this.points.indexOf(n);return new r.CellSide(e,n,this.peaks[i],this.peaks[s],this.center.params)}nextCellBySide(t){const e=this.center.nextCenterByCellSide(t);return new h(e)}containsPoint(t){const e=i.CenterPoint.fromGeo(t,this.center.params);return this.center.isEqual(e)}nearestToEndIntersectedSide(t){const{pointB:e}=t;if(this.containsPoint(e))return;const n=this.reduceSides((n,i)=>{const s=i.intersectionPoint(t);if(s){n[e.calcMercDistance(s)]=i}return n},{}),i=Object.keys(n).map(t=>+t);return 0!==i.length?n[Math.min(...i)]:void 0}nextCellOnSegment(t){const{pointA:e,pointB:n}=t,s=i.CenterPoint.fromGeo(e,this.center.params),r=i.CenterPoint.fromGeo(n,this.center.params);if(s.isEqual(r))return;const o=this.nearestToEndIntersectedSide(t);return o?this.nextCellBySide(o):void 0}isNeighbor(t){return this.center.isNeighbor(t.center)}commonPoints(t){return c.getCommonPoints(this,t)}moveByDiff(t,e){const n=this.center.moveByDiff(t,e);return h.fromCenter(n)}}e.Cell=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(30);e.CenterPoint=i.CenterPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(5),s=n(34),r=n(35),o=n(36),a=n(37);class c extends i.GridPoint{get neighbors(){const{south:t,north:e,west:n,east:i,southEast:s,southWest:r,northEast:a,northWest:u}=o.getAll(this);return{south:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),west:n&&c.fromObject(n,this.params),east:i&&c.fromObject(i,this.params),southEast:c.fromObject(s,this.params),southWest:c.fromObject(r,this.params),northEast:c.fromObject(a,this.params),northWest:c.fromObject(u,this.params)}}get northNeighbors(){const{northWest:t,north:e,northEast:n}=o.getNorth(this);return{northWest:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),northEast:n&&c.fromObject(n,this.params)}}get southNeighbors(){const{southWest:t,south:e,southEast:n}=o.getSouth(this);return{southWest:t&&c.fromObject(t,this.params),south:e&&c.fromObject(e,this.params),southEast:n&&c.fromObject(n,this.params)}}get westNeighbors(){const{southWest:t,west:e,northWest:n}=o.getWest(this);return{southWest:t&&c.fromObject(t,this.params),west:e&&c.fromObject(e,this.params),northWest:n&&c.fromObject(n,this.params)}}get eastNeighbors(){const{southEast:t,east:e,northEast:n}=o.getEast(this);return{southEast:t&&c.fromObject(t,this.params),east:e&&c.fromObject(e,this.params),northEast:n&&c.fromObject(n,this.params)}}get northEastNeighbors(){const{northEast:t}=o.getNorthEast(this);return{northEast:c.fromObject(t,this.params)}}get southWestNeighbors(){const{southWest:t}=o.getSouthWest(this);return{southWest:c.fromObject(t,this.params)}}get northWestNeighbors(){const{northWest:t}=o.getNorthWest(this);return{northWest:c.fromObject(t,this.params)}}get southEastNeighbors(){const{southEast:t}=o.getSouthEast(this);return{southEast:c.fromObject(t,this.params)}}static fromObject({i:t,j:e,k:n},i){return new c(i,t,e,n)}static fromGeo(t,e){const n=i.GridPoint.fromGeo(t,e);return c.fromGrid(n)}static fromGrid(t){const{i:e,j:n,k:s}=a.round(t),r=new i.GridPoint(t.params,e,n,s).toGeo(),o=i.GridPoint.fromGeo(r,t.params),{i:u,j:h,k:l}=a.round(o);return new c(t.params,u,h,l)}nextCenterByCellSide(t){const{i:e,j:n,k:r}=s.getNextCenterByCellSide(this,t),o=new i.GridPoint(this.params,e,n,r).toGeo();return c.fromGeo(o,this.params)}isNeighbor(t){let e=this,n=t;return this.isCloserThroughAntiMeridian(t)&&(e=e.toOppositeHemishpere(),n=n.toOppositeHemishpere()),r.isNeighbor(e,n)}isCloserThroughAntiMeridian(t){return this.toGeo().isCloserThroughAntiMeridian(t.toGeo())}toOppositeHemishpere(){const t=this.toGeo().toOppositeHemisphere();return c.fromGeo(t,this.params)}moveByDiff(t,e){const n=this.i+t,i=this.j+e,s=void 0===this.k?void 0:this.k-(t+e),r=new c(this.params,n,i,s).toGeo();return c.fromGeo(r,this.params)}toPlain(){return{i:this.i,j:this.j,k:this.k}}static fromPlain({i:t,j:e,k:n},i){return new c(i,t,e,n)}}e.CenterPoint=c},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1),s=n(32),r=n(33);class o{static fromGeo(t,e){const n=s.correctForGrid(t,e),{axes:i}=e,{i:a,j:c,k:u}=i.reduce((t,i)=>(t[i.name]=r.toGrid(n,i,e),t),{});return new o(e,a,c,u)}constructor(t,e,n,i){this.params=t,this.i=e,this.j=n,this.k=i}toFormatted(){return this}isEasternTo(t){return this.toGeo().isEasternTo(t.toGeo())}isWesternTo(t){return this.toGeo().isWesternTo(t.toGeo())}isNorthernTo(t){return this.toGeo().isNorthernTo(t.toGeo())}isSouthernTo(t){return this.toGeo().isSouthernTo(t.toGeo())}isEqual(t){const{i:e,j:n,k:i}=this.toFormatted(),{i:s,j:r,k:o}=t.toFormatted();return e===s&&n===r&&i===o}toGeo(){const{geoAxes:t}=this.params,{lat:e,lng:n}=t.reduce((t,e)=>(t[e.name]=r.toGeo(this,e),t),{}),o=new i.GeoPoint(e,n);return s.correctForGeo(o,this.params)}onSameAxis(t,e){let n=(this.i-t.i)*(this.j-e.j)-(this.i-e.i)*(this.j-t.j);return"hex"===this.params.type&&(n*=3),0===Math.round(n)}}e.GridPoint=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1);e.correctForGrid=function(t,{correction:e}){if("merc"===e){const{lat:e,lng:n}=t.toSemiSphere();return new i.GeoPoint(e,n/2)}return t},e.correctForGeo=function(t,e){const{correction:n}=e;if("merc"===n){const{lat:e,lng:n}=t;return new i.GeoPoint(e,2*n).fromSemiSphere().toFormatted()}return t.toFormatted()},e.correctPoly=function(t,{correction:e}){return t}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0);e.toGrid=function(t,e,n){return function(t,e){const n=e.initSize;return 1e7*t/n}(function(t,e,n){const s=n?"lat":"lng",r=t[n?"lng":"lat"],o=t[s],a=e.angle,c=i.sinDeg(a),u=i.cosDeg(a);return o*c+r*u}(t,e,n.isHorizontal),n)},e.toGeo=function(t,e){return function(t,e){const n=e.initSize;return t*n/1e7}(function(t,e){const{isHorizontal:n}=t.params,s=n?"lng":"lat",r=n?"lat":"lng",o=e.angle,a=i.sinDeg(o),c=i.cosDeg(o);let u;switch(e.name){case s:u=(t.i-t.j*a)/c;break;case r:u=(t.j-t.i*c)/a;break;default:u=t.j*a+t.i*c}return u}(t,e),t.params)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getNextCenterByCellSide=function(t,e){const{i:n,j:i,k:s}=t,{averagePoint:{i:r,j:o,k:a}}=e;return{i:Math.round(n+2*(r-n)),j:Math.round(i+2*(o-i)),k:void 0!==s&&void 0!==a?Math.round(s+2*(a-s)):void 0}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNeighbor=function(t,e){const{type:n}=t.params;return"hex"===n?function({i:t,j:e,k:n},{i:i,j:s,k:r}){const o=[t-i,e-s,n-r];return o.includes(0)&&o.includes(1)&&o.includes(-1)}(t,e):function({i:t,j:e},{i:n,j:i}){const s=[Math.abs(t-n),Math.abs(e-i)];return s.includes(0)&&s.includes(1)}(t,e)}},function(t,e,n){"use strict";function i(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:s,j:r}=t;const{k:o}=t;return"rect"===e&&"lat"===i?(s+=1,r-=1):"rect"===e&&"lng"===i?(s-=1,r+=1):"hex"===e&&"lat"===i?(s+=1,r-=1):"hex"===e&&"lng"===i&&(s-=1,r+=1),{northWest:{i:s,j:r,k:o}}}function s(t){const{type:e}=t.params;let{i:n,j:i,k:s}=t;return"rect"===e?(n+=1,i+=1):"hex"===e&&(n+=1,s-=1),{northEast:{i:n,j:i,k:s}}}function r(t){const{type:e}=t.params;let{i:n,j:i,k:s}=t;return"rect"===e?(n-=1,i-=1):"hex"===e&&(n-=1,s+=1),{southWest:{i:n,j:i,k:s}}}function o(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:s,j:r}=t;const{k:o}=t;return"rect"===e&&"lat"===i?(s-=1,r+=1):"rect"===e&&"lng"===i?(s+=1,r-=1):"hex"===e&&"lat"===i?(s-=1,r+=1):"hex"===e&&"lng"===i&&(s+=1,r-=1),{southEast:{i:s,j:r,k:o}}}function a(t){const{type:e,geoAxes:n}=t.params,r=n[0].name;let{i:o,j:a,k:c}=t;if("rect"===e&&"lat"===r)o+=1;else if("rect"===e&&"lng"===r)a+=1;else if("hex"===e&&"lat"===r)a+=1,c-=1;else if("hex"===e&&"lng"===r)return Object.assign({},s(t),i(t));return{north:{i:o,j:a,k:c}}}function c(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:s,j:a,k:c}=t;if("rect"===e&&"lat"===i)s-=1;else if("rect"===e&&"lng"===i)a-=1;else if("hex"===e&&"lng"===i)a-=1,c+=1;else if("hex"===e&&"lat"===i)return Object.assign({},o(t),r(t));return{south:{i:s,j:a,k:c}}}function u(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:r,j:a,k:c}=t;if("rect"===e&&"lat"===i)a+=1;else if("rect"===e&&"lng"===i)r-=1;else{if("hex"===e&&"lng"===i)return Object.assign({},o(t),s(t));"hex"===e&&"lat"===i&&(a+=1,c-=1)}return{east:{i:r,j:a,k:c}}}function h(t){const{type:e,geoAxes:n}=t.params,s=n[0].name;let{i:o,j:a,k:c}=t;if("rect"===e&&"lat"===s)a-=1;else if("rect"===e&&"lng"===s)o+=1;else{if("hex"===e&&"lng"===s)return Object.assign({},r(t),i(t));"hex"===e&&"lat"===s&&(a-=1,c+=1)}return{west:{i:o,j:a,k:c}}}Object.defineProperty(e,"__esModule",{value:!0}),e.getAll=function(t){const{type:e,geoAxes:n}=t.params,l=n[0].name;return"hex"===e&&"lat"===l?Object.assign({},a(t),c(t),o(t),r(t),s(t),i(t)):"hex"===e&&"lng"===l?Object.assign({},u(t),h(t),o(t),r(t),s(t),i(t)):Object.assign({},a(t),c(t),u(t),h(t),o(t),r(t),s(t),i(t))},e.getNorthWest=i,e.getNorthEast=s,e.getSouthWest=r,e.getSouthEast=o,e.getNorth=a,e.getSouth=c,e.getEast=u,e.getWest=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0);e.round=function(t){const{type:e}=t.params;if("hex"===e){const{i:e,j:n,k:s}=t;return function(t){const e=function(t){return Object.keys(t).reduce((e,n)=>{const s=t[n],r=i.decRemain(s);return e[n]=r,e},{})}(t),n=Object.keys(e).sort((t,n)=>e[n]-e[t]);let s=Object.values(e).reduce((t,e)=>t+e,0);return s=Math.round(s),n.reduce((e,n)=>(s>0?(e[n]=Math.ceil(t[n]),s-=1):e[n]=Math.floor(t[n]),e),{})}({i:e,j:n,k:s})}{const{i:e,j:n}=t;return function(t){return Object.keys(t).reduce((e,n)=>(e[n]=Math.round(t[n]),e),{})}({i:e,j:n})}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(13),s=n(5),r=n(39);class o extends s.GridPoint{get nearestPeaks(){return r.calcNearestPeaks(this).map(({i:t,j:e,k:n})=>{const i=new o(this.params,t,e,n).toGeo(),r=s.GridPoint.fromGeo(i,this.params);return new o(this.params,r.i,r.j,r.k)})}get nearestPeaksGeo(){return this.nearestPeaks.map(t=>t.toGeo())}static fromGeo(t,e){const{i:n,j:i,k:r}=s.GridPoint.fromGeo(t,e);return new o(e,n,i,r)}toFormatted(){const{params:t,i:e,j:n,k:i}=this;return new o(t,+e.toFixed(6),+n.toFixed(6),i&&+i.toFixed(6))}nearestNotSeparatedByPoly(t){const{nearestPeaks:e}=this;return e.reduce((e,n)=>{const s=i.CellSide.fromPeaks(this,n);return!t.intersectsSegment(s)&&e.push(n),e},[])}}e.PeakPoint=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calcNearestPeaks=function(t){const{type:e}=t.params;return"hex"===e?function({i:t,j:e,k:n}){return 2===Math.round(t%1*3)?[{i:t+2/3,j:e-1/3,k:n-1/3},{i:t-1/3,j:e+2/3,k:n-1/3},{i:t-1/3,j:e-1/3,k:n+2/3}]:[{i:t-2/3,j:e+1/3,k:n+1/3},{i:t+1/3,j:e-2/3,k:n+1/3},{i:t+1/3,j:e+1/3,k:n-2/3}]}(t):function({i:t,j:e}){return[{i:t+1,j:e-1},{i:t+1,j:e+1},{i:t-1,j:e+1},{i:t-1,j:e-1}]}(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.expand=function(t){const{type:e}=t.params;return"hex"===e?function({i:t,j:e,k:n}){return[{i:t-2/3,j:e+1/3,k:n+1/3},{i:t-1/3,j:e-1/3,k:n+2/3},{i:t+1/3,j:e-2/3,k:n+1/3},{i:t+2/3,j:e-1/3,k:n-1/3},{i:t+1/3,j:e+1/3,k:n-2/3},{i:t-1/3,j:e+2/3,k:n-1/3}]}(t):function({i:t,j:e}){return[{i:t+.5,j:e-.5},{i:t+.5,j:e+.5},{i:t-.5,j:e+.5},{i:t-.5,j:e-.5}]}(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getCommonPoints=function(t,e){const{params:n}=t.center;let i,s;if(t.center.isCloserThroughAntiMeridian(e.center)){const n=t.center.toOppositeHemishpere(),r=e.center.toOppositeHemishpere();i=r.i-n.i,s=r.j-n.j}else i=e.center.i-t.center.i,s=e.center.j-t.center.j;return("hex"===n.type?function(t,e){return 0===t&&0===e?[0,1,2,3,4,5]:1===t&&0===e?[3,4]:-1===t&&0===e?[0,1]:0===t&&1===e?[4,5]:0===t&&-1===e?[1,2]:-1===t&&1===e?[5,0]:1===t&&-1===e?[2,3]:[]}(i,s):function(t,e){return 0===t&&0===e?[0,1,2,3]:1===t&&0===e?[0,1]:-1===t&&0===e?[2,3]:0===t&&1===e?[1,2]:0===t&&-1===e?[3,0]:1===t&&1===e?[1]:-1===t&&1===e?[2]:-1===t&&-1===e?[3]:1===t&&-1===e?[0]:[]}(i,s)).map(e=>t.points[e])}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getIntersectedWithSegmentNeighbor=function(t,e){if(t.intersectsWithSegment(e).length>0)return t;const n=t.closestSideToSegment(e),i=t.nextCellBySide(n);return i.intersectsWithSegment(e).length>0?i:void 0}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.cleanFigure=function(t){const e=function(t){return t.reduce((t,{lat:e,lng:n},i)=>{const s=`${e} ${n}`,r=t[s];return void 0===r?t[s]=i:Array.isArray(r)?r.push(i):t[s]=[r,i],t},{})}(t),{inner:n,outer:i}=function(t,e){const n=e.length;return Object.keys(t).reduce((i,s)=>{let r=t[s];if(!Array.isArray(r))return i;r.length>2&&(r=function(t,e){return t.reduce((n,i,s)=>{const r=t[s+1]||t[0],o=Math.max(n[0],n[1]),a=Math.min(n[0],n[1]),c=Math.min(o-a,e+a-o),u=Math.max(i,r),h=Math.min(i,r);return c>Math.min(u-h,e+h-u)?n:[i,r]},[t[0],t[1]])}(r,e.length));const o=Math.min(...r),a=Math.max(...r);if(a-o>n+o-a&&i.outer[0]<=o&&i.outer[1]>=a)return i.outer=[o,a],i;let c=!0;return i.inner.forEach((t,e)=>{if(!c)return;const n=Math.min(...t),s=Math.max(...t);n>o&&s<a?i.inner[e]=[o,a]:n<o&&s>a&&(c=!1)}),c&&i.inner.push([o,a]),i},{inner:[],outer:[0,n]})}(e,t);return function(t,e){const n=e.reduce((e,[n,i])=>[...e,...t.slice(n,i)],[]),i=n[0];n[n.length-1].isEqual(i)||n.push(i);return n}(t,function(t,e){return[...t,...e.reduce((t,e)=>[...t,...e],[])].sort((t,e)=>t-e).reduce((t,e,n,i)=>{if(n%2)return t;const s=0===n?e:e+1,r=i[n+1]+1;return t.push([s,r]),t},[])}(i,n))}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(12),s=n(4);function r(t,e,n){const i=e.nearestNotSeparatedByPoly(t),{length:s}=i;return 1===s?r(t,i[0],e):n?s>1:i.map(n=>r(t,n,e)).some(t=>t)}function o(t,e,n,o=!0){const a=o?t.pointsInsidePoly(e):t.pointsOutsidePoly(e);if(0!==a.length){if(1===a.length){return r(e,i.PeakPoint.fromGeo(a[0],n))?a[0]:void 0}return a.length===t.points.length?function(t,e,n){const i=t.sideByIndex(0),s=t.points.length-1,r=t.sideByIndex(s);return e.reduceSides((t,e)=>{if(t)return t;const s=e.intersectionPoint(i),o=e.intersectionPoint(r);if(!s||!o)return t;const{pointA:a,pointB:c}=e,u=a.calcMercDistance(s),h=a.calcMercDistance(o);return n===u>h?c:a},void 0)}(e,t,o):function(t,e,n,o){const a=t.sideByIndex(0),{params:c}=e.center,u=e.nextCellOnSegment(a)||s.Cell.fromGeoPoint(t.points[1],c),h=n.find(n=>{const i=e.points.indexOf(n),s=e.prevPointByIndex(i),r=e.nextPointByIndex(i);return t.containsPoint(s)!==t.containsPoint(r)&&!u.points.find(t=>t.isEqual(n))});if(!h)return;const l=i.PeakPoint.fromGeo(h,c);return r(t,l)?h:void 0}(e,t,a)}}e.findStartPointForSide=function(t,e,n,i){const r=s.Cell.fromGeoPoint(t.pointB,n);let a,c=s.Cell.fromGeoPoint(e.points[0],n);if(c){for(;c&&(!a||!c.isEqual(r))&&(a=o(c,e,n,i),!a);)c=c.nextCellOnSegment(t);return a}},e.recalcStartCell=function(t,e,n){const i=t[t.length-1],r=s.Cell.fromGeoPoint(e.pointB,n);let o=s.Cell.fromGeoPoint(e.pointA,n),a=o.findEqualGeoPoint(i);if(a)return o;for(;!a&&o&&!o.isEqual(r)&&(o=o.nextCellOnSegment(e),o);){const e=t[t.length-2];!!e&&!!o.findEqualGeoPoint(e)||(a=o.findEqualGeoPoint(i))}return o}}]);',null)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(3);e.getInvalidCells=function(t,e){return t.reduceNeighboringSidesPairs((n,s,o)=>{const r=function(t,e,n,s=3){const o=i.Cell.fromGeoPoint(t.pointA,n),r=[];let a,c;for(let n=0;n<s;n+=1){c=c?c.nextCellOnSegment(t):o,a=a?a.nextCellOnSegment(e):o;const n=!!r.find(t=>!!c&&t.isEqual(c)),i=!!r.find(t=>!!a&&t.isEqual(a));c&&!n&&r.push(c),a&&!i&&r.push(a)}return r}(s,o,e),a=t.reduceSides((t,e)=>(e.isEqual(s)||e.isEqual(o)||t.push(e),t),[]),c=r.reduce((t,e)=>{const n=e.intersectedWithSegmentsNeighbors(a).filter(e=>!t.find(t=>t.isEqual(e)));return t.push(...n),t},[]).filter(t=>!n.find(e=>e.isEqual(t)));return n.push(...c),n},[])}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(60);e.IndexatedFigure=i.IndexatedFigure},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(27),s=n(11),o=n(61);class r extends i.Figure{static async fromShape(t,e,n=!0){r.indexWorker||(r.indexWorker=new o.IndexationWorker);const{points:a}=await i.Figure.fromShape(t,e,n),c=await r.indexWorker.indexatePoints(a,t,e);return new r(c,t,e,n,new s.GeoPolygon(a))}constructor(t,e,n,i,s){super(t,e,n,i),this.fullPoints=s}async tilePoints(t){if(0===this.points.length)return[];if(!r.indexWorker)return[];return await r.indexWorker.buildTile(t)}}e.IndexatedFigure=r},function(t,e,n){"use strict";var i=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const s=n(13),o=i(n(62)),r=n(8);e.IndexationWorker=class{constructor(){this.worker=new s.WorkerService(new o.default)}terminate(){this.worker.terminate()}async indexatePoints(t,e,n){const{data:i}=await this.worker.post({type:"indexate",payload:{points:t.map(t=>t.toPlain()),shape:e.toPlain(),params:n.toPlain()}});return i.points.map(t=>r.GeoPoint.fromPlain(t))}async buildTile(t){const{data:e}=await this.worker.post({type:"tile-intersects",payload:{tile:t.toPlain()}});return e.points.map(t=>r.Point.fromPlain(t))}}},function(t,e,n){t.exports=function(){return n(14)('!function(t){var e={};function i(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,i),o.l=!0,o.exports}i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)i.d(n,o,function(e){return t[e]}.bind(null,o));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=13)}([function(t,e,i){"use strict";function n(t){return t*Math.PI/180}Object.defineProperty(e,"__esModule",{value:!0}),e.floorNumStrByOrder=function(t){const e=t.length;if(t.split("").every(t=>"0"===t))return t;if(t.lastIndexOf(".")===e-2)return Math.floor(+t)+"";if(-1!==t.indexOf("."))return t.slice(0,-1);if(-1===t.indexOf("0"))return t.slice(0,-1)+"0";{const i=t.lastIndexOf("0");return t.slice(0,i-1)+"0".repeat(e-i+1)}},e.calcClosestMultiple=function(t,e){let i=t,n=t;for(;e%i!=0&&e%n!=0;)i+=1,n-=1;return e%i==0?i:n},e.cosDeg=function(t){const e=n(t);return Math.cos(e)},e.sinDeg=function(t){const e=n(t);return Math.sin(e)},e.findPrimeFactors=function(t){if(t<2)return[];let e=t,i=2;const n=[];for(;i*i<=e;)e%i==0?(n.push(i),e/=i):i+=1;return 1!==e&&n.push(e),n},e.degToRad=n,e.radToDeg=function(t){return 180*t/Math.PI},e.decRemain=function(t){return t-Math.floor(t)}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(6),o=i(19),s=i(2),r=i(21);class a{constructor(t,e){this.pointA=t,this.pointB=e,this.rhumbLine=o.RhumbLine.fromTwoGeoPoints(t,e)}get points(){return[this.pointA,this.pointB]}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallel(){return this.pointA.lat===this.pointB.lat}get isMeridian(){return this.pointA.lat===this.pointB.lat}get easternPoint(){return this.isMeridian?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isMeridian?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallel?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallel?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}static segmentsFromPointsByLng(t){const e=t.sort(({lng:t},{lng:e})=>t-e),i=e.reduce((t,i,n)=>e[t].isEasternTo(i)?n:t,0);return[...e.slice(i),...e.slice(0,i)].reduce((t,e,i,n)=>{if(i%2)return t;const o=new a(n[i+1],e);return t.push(o),t},[])}static segmentsFromPointsByLat(t){return t.sort(({lat:t},{lat:e})=>t-e).reduce((t,e,i,n)=>{if(i%2)return t;const o=new a(n[i+1],e);return t.push(o),t},[])}toMerc(){const t=this.pointA.toMerc(),e=this.pointB.toMerc();return new r.MercSegment(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new a(t,e)}intersectsWithPoly(t){return t.intersectsWithSegment(this)}intersects(t){return!!this.intersectionPoint(t)}intersectionPoint(t){let e=this,i=t;const n=this.isAntiMeridian||t.isAntiMeridian;n&&(e=e.toOppositeHemisphere(),i=i.toOppositeHemisphere());const o=e.toMerc(),r=i.toMerc(),a=o.intersectionPoint(r);if(!a)return;const c=s.GeoPoint.fromMerc(a);return n?c.toOppositeHemisphere():c}closestToPoint(t){const{isAntiMeridian:e}=this;let i=this;e&&(i=i.toOppositeHemisphere(),t=t.toOppositeHemisphere());const n=t.toMerc(),o=i.toMerc().closestToPoint(n),r=s.GeoPoint.fromMerc(o);return e?r.toOppositeHemisphere():r}isEqual({pointA:t,pointB:e}){return this.pointA.isEqual(t)&&this.pointB.isEqual(e)||this.pointA.isEqual(e)&&this.pointB.isEqual(t)}mercDistanceToPoint(t){const e=this.closestToPoint(t);return t.calcMercDistance(e)}latByLng(t){if(!this.containsLng(t))return;const e=this.rhumbLine.latByLng(t);return void 0===e||0!==this.rhumbLine.a&&!this.containsLat(e)?void 0:e}lngByLat(t){if(!this.containsLat(t))return;const e=this.rhumbLine.lngByLat(t);return void 0===e||0!==this.rhumbLine.b&&!this.containsLng(e)?void 0:e}containsLat(t){t=n.formatLat(t);const{lat:e}=this.pointA.toFormatted(),{lat:i}=this.pointB.toFormatted();return Math.max(e,i)>=t&&Math.min(e,i)<=t}containsLng(t){t=n.formatLng(t);const{lng:e}=this.pointA.toFormatted(),{lng:i}=this.pointB.toFormatted(),o=Math.max(e,i),s=Math.min(e,i);return this.isAntiMeridian?o<=t&&t<180||s>=t&&t>=-180:o>=t&&s<=t}containsPoint({lat:t,lng:e}){return this.containsLat(t)&&this.containsLng(e)}containsSegment({pointA:t,pointB:e}){return this.containsPoint(t)&&this.containsPoint(e)}overlapsSegment(t){const{pointA:e,pointB:i}=t;return this.containsPoint(e)||this.containsPoint(i)||t.containsPoint(this.pointB)||t.containsPoint(this.pointB)}}e.GeoSegment=a},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(6),o=i(3);class s{constructor(t,e){this.lat=t,this.lng=e}static createFormatted(t,e){return t=n.formatLat(t),e=n.formatLng(e),new s(t,e)}static fromUnsafeCoords(t,e){return t=n.reduceLat(t),e=n.reduceLng(e),new s(t,e)}static fromMerc(t){const{lat:e,lng:i}=t.toSphereLiteral();return new s(e,i)}isEqual(t){const e=this.toFormatted(),i=t.toFormatted();return e.lat===i.lat&&e.lng===i.lng}isCloserThroughAntiMeridian(t){const e=Math.min(this.lng,t.lng);return Math.max(this.lng,t.lng)-e>180}toOppositeHemisphere(){const t=n.reduceLng(this.lng-180);return new s(this.lat,t)}calcMercDistance(t){let e=this;this.isCloserThroughAntiMeridian(t)&&(e=this.toOppositeHemisphere(),t=t.toOppositeHemisphere());const i=e.toMerc(),n=t.toMerc();return i.distanceToPoint(n)}toMerc(){const t=n.lngToX(this.lng),e=n.latToY(this.lat);return new o.MercPoint(t,e)}toSemiSphere(){const{lat:t,lng:e}=this.toMerc().toSemiSphereLiteral();return new s(t,e)}fromSemiSphere(){const t=n.semiLngToX(this.lng),e=n.semiLatToY(this.lat),{lat:i,lng:r}=new o.MercPoint(t,e).toSphereLiteral();return new s(i,r)}toFormatted(){const t=n.formatLat(this.lat),e=n.formatLng(this.lng);return new s(t,e)}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng<t.lng:this.lng>t.lng}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng>t.lng:this.lng<t.lng}isNorthernTo(t){return this.lat>t.lat}isSouthernTo(t){return this.lat<t.lat}toPlain(){const{lat:t,lng:e}=this;return{lat:t,lng:e}}toGeoJSON(){return{type:"Point",coordinates:[this.lng,this.lat]}}static fromPlain({lat:t,lng:e}){return new s(t,e)}static fromGeoJSON({coordinates:[t,e]}){return s.fromPlain({lat:e,lng:t})}}e.GeoPoint=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(5),o=i(7);class s extends n.Point{constructor(t,e){super(t=o.reduceX(t),e)}toFormatted(){return new s(+this.x.toFixed(10),+this.y.toFixed(10))}toOppositeHemisphere(){const t=o.reduceX(this.x-.5);return new s(t,this.y)}calcMercDistance(t){return(this.isCloserThroughAntiMeridian(t)?this.toOppositeHemisphere():this).distanceToPoint(t)}isCloserThroughAntiMeridian(t){const e=Math.min(this.x,t.x);return Math.max(this.x,t.x)-e>1}toSphereLiteral(){return{lat:o.yToLat(this.y),lng:o.xToLng(this.x)}}toSemiSphereLiteral(){return{lat:o.yToSemiLat(this.y),lng:o.xToSemiLng(this.x)}}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x<t.x:this.x>t.x}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x>t.x:this.x<t.x}isNorthernTo(t){return this.y>t.y}isSouthernTo(t){return this.y<t.y}}e.MercPoint=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(30);e.GridPoint=n.GridPoint},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class n{constructor(t,e){this.x=t,this.y=e}distanceToPoint({x:t,y:e}){return Math.sqrt(Math.pow(t-this.x,2)+Math.pow(e-this.y,2))}toFormatted(){return this}toPlain(){return{x:this.x,y:this.y}}static fromPlain({x:t,y:e}){return new n(t,e)}containedByLine(t){return t.hasPoint(this)}containedBySegment(t){return t.hasPoint(this)}isEqual(t){const e=this.toFormatted(),i=t.toFormatted();return e.x===i.x&&e.y===i.y}distanceToLine(t){return t.distanceToPoint(this)}closestOnLine(t){return t.closestToPoint(this)}closestOnSegment(t){return t.closestToPoint(this)}}e.Point=n},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0);function o(t){return(t>360||t<-360)&&(t%=360),t>=180?t-360:t<-180?t+360:t}e.semiLatToY=function(t){return-t/180+.5},e.semiLngToX=function(t){return t/360+.5},e.latToY=function(t){return(-Math.log(Math.tan(Math.PI/4+n.degToRad(t)/2))/Math.PI+1)/2},e.lngToX=function(t){return(n.degToRad(t)/Math.PI+1)/2},e.formatLat=function(t){return t>90&&(t=90),t<-90&&(t=-90),+t.toFixed(7)},e.formatLng=function(t){return+(t=o(t)).toFixed(7)},e.reduceLat=function(t){return(t>360||t<-360)&&(t%=360),t>90?180-t:t<-90?-180+t:t},e.reduceLng=o},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0);e.yToLat=function(t){const e=Math.atan(Math.E**(-(2*t-1)*Math.PI))-Math.PI/4;return 2*n.radToDeg(e)},e.xToLng=function(t){const e=(2*t-1)*Math.PI;return n.radToDeg(e)},e.yToSemiLat=function(t){return 180*-(t-.5)},e.xToSemiLng=function(t){return 360*(t-.5)},e.reduceX=function(t){return t%=1}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(3),o=i(9);class s extends o.Line{static fromTwoPoints(t,e){const{a:i,b:n,c:r}=o.Line.fromTwoPoints(t,e);return new s(i,n,r)}calcAlikePoint(t){const{x:e,y:i}=super.calcAlikePoint(t);return new n.MercPoint(e,i)}closestToPoint(t){const{x:e,y:i}=super.closestToPoint(t);return new n.MercPoint(e,i)}perpendicularByPoint(t){const{a:e,b:i,c:n}=super.perpendicularByPoint(t);return new s(e,i,n)}intersectionPoint(t){const e=super.intersectionPoint(t);if(!e)return;const{x:i,y:o}=e;return new n.MercPoint(i,o)}}e.MercLine=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(5),o=i(20);class s{constructor(t,e,i){this.a=t,this.b=e,this.c=i}get isParallelToAxisX(){return 0===this.b}get isParallelToAxisY(){return 0===this.a}static fromTwoPoints({x:t,y:e},{x:i,y:n}){return new s(e-n,i-t,-(t*n-e*i))}calcAlikePoint(t){const e=this.xByY(t.y),i=this.yByX(t.x);return new n.Point(void 0===e?t.x:e,void 0===i?t.y:i)}hasPoint(t){return this.calcAlikePoint(t).isEqual(t)}xByY(t){if(!this.isParallelToAxisY)return(this.c-this.b*t)/this.a}yByX(t){if(!this.isParallelToAxisX)return(this.c-this.a*t)/this.b}distanceToPoint(t){const e=this.closestToPoint(t);return t.distanceToPoint(e)}getNormalVector(){return new o.Vector(this.a,this.b)}closestToPoint(t){const{x:e,y:i}=t;if(this.isParallelToAxisX)return new n.Point(this.c/this.a,i);if(this.isParallelToAxisY)return new n.Point(e,this.c/this.b);const o=this.perpendicularByPoint(t);return this.intersectionPoint(o)}perpendicularByPoint({x:t,y:e}){const{x:i,y:n}=this.getNormalVector();return new s(1/i,-1/n,t/i-e/n)}intersectionX({a:t,b:e,c:i}){const n=this.a*e-this.b*t,o=this.c*e-this.b*i;if(n)return o/n}intersectionY({a:t,b:e,c:i}){const n=this.a*e-this.b*t,o=this.a*i-this.c*t;if(n)return o/n}intersectionPoint(t){if(t.isParallelToAxisX&&this.isParallelToAxisX||t.isParallelToAxisY&&this.isParallelToAxisY)return;const{a:e,b:i,c:o}=t;let s,r;return s=t.isParallelToAxisX?o/e:this.isParallelToAxisX?this.c/this.a:this.intersectionX(t),r=t.isParallelToAxisY?o/i:this.isParallelToAxisY?this.c/this.b:this.intersectionY(t),void 0===s&&void 0!==r&&(s=this.xByY(r)||t.xByY(r)),void 0!==s&&void 0===r&&(r=this.yByX(s)||t.yByX(s)),void 0!==s&&void 0!==r?new n.Point(s,r):void 0}}e.Line=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(29);e.CenterPoint=n.CenterPoint},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.constants={equatorLength:40075696,radius:6370997,meridianLength:40007860,googleTileSize:256}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(42);e.GeoPolygon=n.GeoPolygon},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(14),o=i(15),s=i(28),r=i(44),a=i(12),c=i(45),h=self,u=new n.CtxService(h);let l;u.onMessage(t=>{const{data:e}=t;if("indexate"===e.type){const{payload:{points:t,shape:i,params:n}}=e,h=new a.GeoPolygon(i.map(({lat:t,lng:e})=>new s.GeoPoint(t,e))),p=new c.GridParams(n),d=t.map(({lat:t,lng:e})=>new s.GeoPoint(t,e)),m=r.simplifyFigure(d,h,p);return l=o.Indexation.fromPoints(m),void u.post({points:m.map(t=>t.toPlain())})}if("tile-intersects"===e.type){if(!l)throw new Error("Border points wasn\'t provided.");const{payload:{tile:{tileX:t,tileY:i,zoom:n,tileHeight:o,tileWidth:r}}}=e,a=s.TileMercPoint.fromTile(t,i,r,o,n),c=l.tileBorderPoints(a);u.post({points:c.map(t=>t.toPlain())})}}),e.default={}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.CtxService=class{constructor(t){this.worker=t,this.handleMessage=t=>{"terminate"!==t.data?this.messageHandler&&this.messageHandler(t):this.close()},this.handleError=t=>{this.errorHandler&&this.errorHandler(t)},this.worker.addEventListener("message",this.handleMessage),this.worker.addEventListener("error",this.handleError)}post(t){this.worker.postMessage(t)}onMessage(t){this.messageHandler=t}onError(t){this.errorHandler=t}close(){this.unmount(),close()}unmount(){this.worker.removeEventListener("message",this.handleMessage),this.worker.removeEventListener("error",this.handleError)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(16);e.Indexation=n.Indexation},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(17),o=i(25),s=i(27);class r{constructor(t,e,i){this.points=t,this.spreaded=e,this.indexations=i}static fromPoints(t){const e=s.spreadPointsBySides(t),i=e.map(e=>n.SideIndexation.fromSpreadedSide(t,e));return new r(t,e,i)}tileIntersection(t){const e=[],i=[],n=[],s=[],r=t.toPoly();return this.indexations.forEach(o=>{const a=o.boundIntersection(t.northBound,r,"north"),c=o.boundIntersection(t.southBound,r,"south"),h=o.boundIntersection(t.eastBound,r,"east"),u=o.boundIntersection(t.westBound,r,"west");a&&e.push(a),c&&i.push(c),h&&n.push(h),u&&s.push(u)}),o.TileIntersection.fromBounds(t,e,i,n,s).normalize()}tileBorderPoints(t){const e=this.tileIntersection(t);if(e.isEmpty){return t.toPoly().containsPoint(this.points[0])?t.projectGeoPoints(this.points):[]}if(e.isContained){return t.projectGeoPoints(t.toPoly().points)}const i=e.reduce((i,n,o)=>{if(0===n.length)return i;const s=t[o],{pointA:r,pointB:a}=s;if(e.tileContainedByDirection(o))return i.push(...s.points),i;const c=n.length-1,h=n.reduce((i,s,h)=>{const u=0===h,l=h===c;if(u&&s.containsPoint(r)?i.push(r):u&&i.push(s.pointA),l&&s.containsPoint(a))return i.push(a),i;i.push(s.pointB);const{toIndex:p}=s.boundB;if(void 0===p)return i;let d;const m=n[h+1];if(m&&m.boundA.toIndex)d=m.boundA.toIndex;else{const{keys:t}=e,i=t.indexOf(o),n=[...t.slice(i+1),...t.slice(0,i+1)].find(t=>e[t].length>0);d=n&&e[n][0].boundA.toIndex}if(void 0===d)return i;if(p===d)return i.push(this.points[p]),i;const g=Math.min(p,d),f=Math.max(p,d),P=this.points[g+1],y=!t.containsPoint(P),x=p>d!==y;let M;return M=y?[...this.points.slice(f),...this.points.slice(0,g+1)]:this.points.slice(g,f+1),x&&M.reverse(),i.push(...M),i},[]);return i.push(...h),i},[]);return t.projectGeoPoints(i)}}e.Indexation=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(18);e.SideIndexation=n.SideIndexation},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0),o=i(1),s=i(23),r=i(24);class a{constructor(t,e,i,n,o,s,r){this.points=t,this.spreadedSide=e,this.lngIndexes=i,this.latIndexes=n,this.lngKeys=o,this.latKeys=s,this.approximation=r}get isAntiMeridian(){return this.approximation.isAntiMeridian}get north(){return this.approximation.northernPoint.lat}get south(){return this.approximation.southernPoint.lat}get east(){return this.approximation.easternPoint.lng}get west(){return this.approximation.westernPoint.lng}static fromSpreadedSide(t,e){const i={},n={};e.forEach(({point:{lat:t,lng:e},index:o})=>{i[e]||(i[e]=[]),n[t]||(n[t]=[]),i[e].push(o),n[t].push(o)},{});const s=Object.keys(i).sort((t,e)=>+t-+e),c=Object.keys(n).sort((t,e)=>+t-+e),h=r.indexateKeys(s),u=r.indexateKeys(c),l=new o.GeoSegment(e[0].point,e[e.length-1].point);return new a(t,e,i,n,h,u,l)}boundIntersection(t,e,i){const n="north"===i||"south"===i,o=n?this.closestLatKeys(t):this.closestLngKeys(t);if(!o)return;let r=o[0],a=o[o.length-1];if(t<r||t>a)return;o.forEach(e=>{e>t&&e<a&&(a=e),e<t&&e>r&&(r=e)});const c=n?this.latIndexes:this.lngIndexes,h=c[a],u=c[r];let l,p;if(1===h.length&&1===u.length){return l=u[0],p=h[0],s.BoundIntersection.fromPoints(this.points,l,p,e,t,i)}const d=Math.min(...h),m=Math.max(...h),g=Math.min(...u),f=Math.max(...u),P=Math.abs(d-f),y=Math.abs(m-g);return 1===P||1!==y&&y<P?(p=d,l=f):(p=m,l=g),s.BoundIntersection.fromPoints(this.points,l,p,e,t,i)}closestLatKeys(t){let e,i=t+"";for(;e=this.latKeys[i],!e;){const t=n.floorNumStrByOrder(i);if(t===i)break;i=t}return e}closestLngKeys(t){let e,i=t+"";for(;!e&&(e=this.lngKeys[i],!e);){const t=n.floorNumStrByOrder(i);if(t===i)break;i=t}return e}}e.SideIndexation=a},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(6),o=i(7),s=i(8);class r extends s.MercLine{static fromTwoGeoPoints(t,e){const i=t.isCloserThroughAntiMeridian(e);i&&(t=t.toOppositeHemisphere(),e=e.toOppositeHemisphere());const{a:n,b:o,c:a}=s.MercLine.fromTwoPoints(t.toMerc(),e.toMerc());return new r(n,o,a,i)}constructor(t,e,i,n){super(t,e,i),this.isAntiMeridian=n}lngByLat(t){const e=n.latToY(t),i=this.xByY(e);if(void 0===i)return;let s=o.xToLng(i);return this.isAntiMeridian&&(s=n.reduceLng(s-180)),s}latByLng(t){this.isAntiMeridian&&(t=n.reduceLng(t-180));const e=n.lngToX(t),i=this.yByX(e);if(void 0!==i)return o.yToLat(i)}}e.RhumbLine=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Vector=class{constructor(t,e){this.x=t,this.y=e}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(8),o=i(3),s=i(22);class r extends s.Segment{constructor(t,e){super(t,e),this.pointA=t,this.pointB=e,this.line=n.MercLine.fromTwoPoints(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new r(t,e)}intersectionPoint(t){if(!this.isAntiMeridian&&!t.isAntiMeridian){const e=super.intersectionPoint(t);return e&&new o.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere(),i=t.toOppositeHemisphere(),n=e.intersectionPoint(i);return n&&n.toOppositeHemisphere()}closestToPoint(t){if(!this.isAntiMeridian){const e=super.closestToPoint(t);return new o.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere();return t=t.toOppositeHemisphere(),e.closestToPoint(t).toOppositeHemisphere()}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallelToAxisX(){return this.line.isParallelToAxisX}get isParallelToAxisY(){return this.line.isParallelToAxisY}get easternPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}}e.MercSegment=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(9);e.Segment=class{constructor(t,e){this.pointA=t,this.pointB=e,this.line=n.Line.fromTwoPoints(t,e)}get minX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.min(t,e)}get maxX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.max(t,e)}get minY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.min(t,e)}get maxY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.max(t,e)}get minXPoint(){const{x:t}=this.pointA;return this.minX===t?this.pointA:this.pointB}get maxXPoint(){const{x:t}=this.pointA;return this.maxX===t?this.pointA:this.pointB}get minYPoint(){const{y:t}=this.pointA;return this.minY===t?this.pointA:this.pointB}get maxYPoint(){const{y:t}=this.pointA;return this.maxY===t?this.pointA:this.pointB}closestToPoint(t){const e=this.line.closestToPoint(t).toFormatted(),{x:i,y:n}=this.pointA.toFormatted(),{x:o,y:s}=this.pointB.toFormatted();return e.x<Math.min(i,o)?this.minXPoint:e.x>Math.max(i,o)?this.maxXPoint:e.y<Math.min(n,s)?this.minYPoint:e.y>Math.max(n,s)?this.maxYPoint:e}hasPoint(t){const{pointA:e,pointB:i}=this,{x:n,y:o}=t.toFormatted(),{x:s,y:r}=e.toFormatted(),{x:a,y:c}=i.toFormatted();return this.line.hasPoint(t)&&Math.max(s,a)>=n&&Math.min(s,a)<=n&&Math.max(r,c)>=o&&Math.min(r,c)<=o}intersectionPoint(t){if(this.line.a===t.line.a||this.line.b===t.line.b)return;const e=this.line.intersectionPoint(t.line);if(!e)return;let i,n;const o=Math.max(this.pointA.x,this.pointB.x),s=Math.min(this.pointA.x,this.pointB.x),r=Math.max(this.pointA.y,this.pointB.y),a=Math.min(this.pointA.y,this.pointB.y),c=Math.max(t.pointA.x,t.pointB.x),h=Math.min(t.pointA.x,t.pointB.x),u=Math.max(t.pointA.y,t.pointB.y),l=Math.min(t.pointA.y,t.pointB.y);return i=0===this.line.a?e.x<=o&&e.x>=s&&u>=r&&l<=a:0===this.line.b?e.y<=r&&e.y>=a&&c>=o&&h<=s:this.hasPoint(e),n=0===t.line.a?e.x<=c&&e.x>=h&&r>=u&&a<=l:0===t.line.b?e.y<=u&&e.y>=l&&o>=c&&s<=h:t.hasPoint(e),i&&n?e:void 0}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(2),o=i(1);class s{constructor(t,e,i,n,o){this.intersection=t,this.bound=e,this.boundKey=i,this.toIndex=n,this.toPoint=o}static fromPoints(t,e,i,r,a,c){let h=t[e];const u=t[i],l="north"===c||"south"===c;let p,d,m=new o.GeoSegment(h,u);if(l?(p=a,d=m.lngByLat(p)):(d=a,p=m.latByLng(d)),void 0===p||void 0===d)return;let g,f,P=new n.GeoPoint(p,d),y=!1;const x=e-i;if(l&&P.lat===h.lat||!l&&P.lng===h.lng){const i=e+x,n=t[i],o=l?h.lat===n.lat:h.lng===n.lng;y=o,e=o?i:e,h=o?n:h}if(l&&P.lat===u.lat||!l&&P.lng===u.lng){const n=i-x,o=t[n],s=l?u.lat===o.lat:u.lng===o.lng;y=s,e=s?n:i,h=s?o:u}return y&&(m=new o.GeoSegment(h,u)),y&&l?d=m.lngByLat(p):y&&!l&&(p=m.latByLng(d)),void 0!==p&&void 0!==d?(y&&(P=new n.GeoPoint(p,d)),r.containsPoint(h)?(g=h,f=e):r.containsPoint(u)&&(g=u,f=i),new s(P,a,c,f,g)):void 0}}e.BoundIntersection=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0);e.indexateKeys=function(t){const e=t.reduce((t,e)=>{let i=e;for(;;){t[i]||(t[i]=[]),t[i].push(+e);const o=n.floorNumStrByOrder(i);if(o===i)break;i=o}return t},{});return Object.keys(e).forEach(i=>{const n=e[i],o=Math.min(...n),s=Math.max(...n),r=t.indexOf(o+""),a=t.indexOf(s+""),c=t[r-1],h=t[a+1];c&&n.push(+c),h&&n.push(+h),n.sort((t,e)=>t-e)}),e}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(26);class o{constructor(t,e,i,n,o){this.tilePoint=t,this.north=e,this.south=i,this.east=n,this.west=o}get isContained(){return this.reduce((t,e,i)=>t?this.tileContainedByDirection(i):t,!0)}get keys(){return["north","east","south","west"]}get isEmpty(){return this.reduce((t,e)=>t?0===e.length:t,!0)}get pointsIndexes(){return this.reduce((t,e)=>e.reduce((t,{boundA:e,boundB:i})=>(void 0!==e.toIndex&&t.push(e.toIndex),void 0!==i.toIndex&&t.push(i.toIndex),t),t),[]).sort((t,e)=>t-e)}static fromBounds(t,e,i,s,r){return new o(t,n.SplitGeoSegment.splitsByLng(e,"north"),n.SplitGeoSegment.splitsByLng(i,"south"),n.SplitGeoSegment.splitsByLat(s,"east"),n.SplitGeoSegment.splitsByLat(r,"west"))}normalize(){return this.reduce((t,e,i)=>{const n=this.tilePoint[i];return t[i]=e.filter(t=>t.overlapsSegment(n)),t},new o(this.tilePoint,[],[],[],[]))}forEach(t){this.keys.forEach(e=>{t(this[e],e)})}map(t){return this.keys.map(e=>t(this[e],e))}reduce(t,e){return this.keys.reduce((e,i)=>t(e,this[i],i),e)}tileContainedByDirection(t){const e=this.tilePoint[t];return!!this[t].find(t=>t.containsSegment(e))}tileOverlappedByDirection(t){const e=this.tilePoint[t];return!!this[t].find(t=>t.overlapsSegment(e))}}e.TileIntersection=o},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(1);class o extends n.GeoSegment{constructor(t,e){super(t.intersection,e.intersection),this.boundA=t,this.boundB=e}static splitsByLng(t,e){const i="north"===e,s=t.reduce((t,e)=>(t[e.intersection.lng]=e,t),{}),r=t.map(({intersection:t})=>t),a=n.GeoSegment.segmentsFromPointsByLng(r);return i&&a.reverse(),a.map(({pointA:t,pointB:e})=>new o(i?s[e.lng]:s[t.lng],i?s[t.lng]:s[e.lng]))}static splitsByLat(t,e){const i="west"===e,s=t.reduce((t,e)=>(t[e.intersection.lat]=e,t),{}),r=t.map(({intersection:t})=>t),a=n.GeoSegment.segmentsFromPointsByLat(r);return i&&a.reverse(),a.map(({pointA:t,pointB:e})=>new o(i?s[e.lat]:s[t.lat],i?s[t.lat]:s[e.lat]))}}e.SplitGeoSegment=o},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(1);e.spreadPointsBySides=function(t){return t.slice(0,-1).reduce((t,e,i,o)=>{const s=t[t.length-1];if(!s){const t=o.length-1;return[[{index:t,point:o[t]},{point:e,index:i}]]}const r=new n.GeoSegment(s[0].point,s[s.length-1].point),a=!r.containsLat(e.lat),c=!r.containsLng(e.lng);return a&&c?s.push({index:i,point:e}):t.push([s[s.length-1],{index:i,point:e}]),t},[])}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(10);e.CenterPoint=n.CenterPoint;var o=i(4);e.GridPoint=o.GridPoint;var s=i(2);e.GeoPoint=s.GeoPoint;var r=i(3);e.MercPoint=r.MercPoint;var a=i(37);e.PeakPoint=a.PeakPoint;var c=i(5);e.Point=c.Point;var h=i(41);e.TileMercPoint=h.TileMercPoint},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(4),o=i(33),s=i(34),r=i(35),a=i(36);class c extends n.GridPoint{get neighbors(){const{south:t,north:e,west:i,east:n,southEast:o,southWest:s,northEast:a,northWest:h}=r.getAll(this);return{south:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),west:i&&c.fromObject(i,this.params),east:n&&c.fromObject(n,this.params),southEast:c.fromObject(o,this.params),southWest:c.fromObject(s,this.params),northEast:c.fromObject(a,this.params),northWest:c.fromObject(h,this.params)}}get northNeighbors(){const{northWest:t,north:e,northEast:i}=r.getNorth(this);return{northWest:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),northEast:i&&c.fromObject(i,this.params)}}get southNeighbors(){const{southWest:t,south:e,southEast:i}=r.getSouth(this);return{southWest:t&&c.fromObject(t,this.params),south:e&&c.fromObject(e,this.params),southEast:i&&c.fromObject(i,this.params)}}get westNeighbors(){const{southWest:t,west:e,northWest:i}=r.getWest(this);return{southWest:t&&c.fromObject(t,this.params),west:e&&c.fromObject(e,this.params),northWest:i&&c.fromObject(i,this.params)}}get eastNeighbors(){const{southEast:t,east:e,northEast:i}=r.getEast(this);return{southEast:t&&c.fromObject(t,this.params),east:e&&c.fromObject(e,this.params),northEast:i&&c.fromObject(i,this.params)}}get northEastNeighbors(){const{northEast:t}=r.getNorthEast(this);return{northEast:c.fromObject(t,this.params)}}get southWestNeighbors(){const{southWest:t}=r.getSouthWest(this);return{southWest:c.fromObject(t,this.params)}}get northWestNeighbors(){const{northWest:t}=r.getNorthWest(this);return{northWest:c.fromObject(t,this.params)}}get southEastNeighbors(){const{southEast:t}=r.getSouthEast(this);return{southEast:c.fromObject(t,this.params)}}static fromObject({i:t,j:e,k:i},n){return new c(n,t,e,i)}static fromGeo(t,e){const i=n.GridPoint.fromGeo(t,e);return c.fromGrid(i)}static fromGrid(t){const{i:e,j:i,k:o}=a.round(t),s=new n.GridPoint(t.params,e,i,o).toGeo(),r=n.GridPoint.fromGeo(s,t.params),{i:h,j:u,k:l}=a.round(r);return new c(t.params,h,u,l)}nextCenterByCellSide(t){const{i:e,j:i,k:s}=o.getNextCenterByCellSide(this,t),r=new n.GridPoint(this.params,e,i,s).toGeo();return c.fromGeo(r,this.params)}isNeighbor(t){let e=this,i=t;return this.isCloserThroughAntiMeridian(t)&&(e=e.toOppositeHemishpere(),i=i.toOppositeHemishpere()),s.isNeighbor(e,i)}isCloserThroughAntiMeridian(t){return this.toGeo().isCloserThroughAntiMeridian(t.toGeo())}toOppositeHemishpere(){const t=this.toGeo().toOppositeHemisphere();return c.fromGeo(t,this.params)}moveByDiff(t,e){const i=this.i+t,n=this.j+e,o=void 0===this.k?void 0:this.k-(t+e),s=new c(this.params,i,n,o).toGeo();return c.fromGeo(s,this.params)}toPlain(){return{i:this.i,j:this.j,k:this.k}}static fromPlain({i:t,j:e,k:i},n){return new c(n,t,e,i)}}e.CenterPoint=c},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(2),o=i(31),s=i(32);class r{static fromGeo(t,e){const i=o.correctForGrid(t,e),{axes:n}=e,{i:a,j:c,k:h}=n.reduce((t,n)=>(t[n.name]=s.toGrid(i,n,e),t),{});return new r(e,a,c,h)}constructor(t,e,i,n){this.params=t,this.i=e,this.j=i,this.k=n}toFormatted(){return this}isEasternTo(t){return this.toGeo().isEasternTo(t.toGeo())}isWesternTo(t){return this.toGeo().isWesternTo(t.toGeo())}isNorthernTo(t){return this.toGeo().isNorthernTo(t.toGeo())}isSouthernTo(t){return this.toGeo().isSouthernTo(t.toGeo())}isEqual(t){const{i:e,j:i,k:n}=this.toFormatted(),{i:o,j:s,k:r}=t.toFormatted();return e===o&&i===s&&n===r}toGeo(){const{geoAxes:t}=this.params,{lat:e,lng:i}=t.reduce((t,e)=>(t[e.name]=s.toGeo(this,e),t),{}),r=new n.GeoPoint(e,i);return o.correctForGeo(r,this.params)}onSameAxis(t,e){let i=(this.i-t.i)*(this.j-e.j)-(this.i-e.i)*(this.j-t.j);return"hex"===this.params.type&&(i*=3),0===Math.round(i)}}e.GridPoint=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(2);e.correctForGrid=function(t,{correction:e}){if("merc"===e){const{lat:e,lng:i}=t.toSemiSphere();return new n.GeoPoint(e,i/2)}return t},e.correctForGeo=function(t,e){const{correction:i}=e;if("merc"===i){const{lat:e,lng:i}=t;return new n.GeoPoint(e,2*i).fromSemiSphere().toFormatted()}return t.toFormatted()},e.correctPoly=function(t,{correction:e}){return t}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0);e.toGrid=function(t,e,i){return function(t,e){const i=e.initSize;return 1e7*t/i}(function(t,e,i){const o=i?"lat":"lng",s=t[i?"lng":"lat"],r=t[o],a=e.angle,c=n.sinDeg(a),h=n.cosDeg(a);return r*c+s*h}(t,e,i.isHorizontal),i)},e.toGeo=function(t,e){return function(t,e){const i=e.initSize;return t*i/1e7}(function(t,e){const{isHorizontal:i}=t.params,o=i?"lng":"lat",s=i?"lat":"lng",r=e.angle,a=n.sinDeg(r),c=n.cosDeg(r);let h;switch(e.name){case o:h=(t.i-t.j*a)/c;break;case s:h=(t.j-t.i*c)/a;break;default:h=t.j*a+t.i*c}return h}(t,e),t.params)}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getNextCenterByCellSide=function(t,e){const{i:i,j:n,k:o}=t,{averagePoint:{i:s,j:r,k:a}}=e;return{i:Math.round(i+2*(s-i)),j:Math.round(n+2*(r-n)),k:void 0!==o&&void 0!==a?Math.round(o+2*(a-o)):void 0}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNeighbor=function(t,e){const{type:i}=t.params;return"hex"===i?function({i:t,j:e,k:i},{i:n,j:o,k:s}){const r=[t-n,e-o,i-s];return r.includes(0)&&r.includes(1)&&r.includes(-1)}(t,e):function({i:t,j:e},{i:i,j:n}){const o=[Math.abs(t-i),Math.abs(e-n)];return o.includes(0)&&o.includes(1)}(t,e)}},function(t,e,i){"use strict";function n(t){const{type:e,geoAxes:i}=t.params,n=i[0].name;let{i:o,j:s}=t;const{k:r}=t;return"rect"===e&&"lat"===n?(o+=1,s-=1):"rect"===e&&"lng"===n?(o-=1,s+=1):"hex"===e&&"lat"===n?(o+=1,s-=1):"hex"===e&&"lng"===n&&(o-=1,s+=1),{northWest:{i:o,j:s,k:r}}}function o(t){const{type:e}=t.params;let{i:i,j:n,k:o}=t;return"rect"===e?(i+=1,n+=1):"hex"===e&&(i+=1,o-=1),{northEast:{i:i,j:n,k:o}}}function s(t){const{type:e}=t.params;let{i:i,j:n,k:o}=t;return"rect"===e?(i-=1,n-=1):"hex"===e&&(i-=1,o+=1),{southWest:{i:i,j:n,k:o}}}function r(t){const{type:e,geoAxes:i}=t.params,n=i[0].name;let{i:o,j:s}=t;const{k:r}=t;return"rect"===e&&"lat"===n?(o-=1,s+=1):"rect"===e&&"lng"===n?(o+=1,s-=1):"hex"===e&&"lat"===n?(o-=1,s+=1):"hex"===e&&"lng"===n&&(o+=1,s-=1),{southEast:{i:o,j:s,k:r}}}function a(t){const{type:e,geoAxes:i}=t.params,s=i[0].name;let{i:r,j:a,k:c}=t;if("rect"===e&&"lat"===s)r+=1;else if("rect"===e&&"lng"===s)a+=1;else if("hex"===e&&"lat"===s)a+=1,c-=1;else if("hex"===e&&"lng"===s)return Object.assign({},o(t),n(t));return{north:{i:r,j:a,k:c}}}function c(t){const{type:e,geoAxes:i}=t.params,n=i[0].name;let{i:o,j:a,k:c}=t;if("rect"===e&&"lat"===n)o-=1;else if("rect"===e&&"lng"===n)a-=1;else if("hex"===e&&"lng"===n)a-=1,c+=1;else if("hex"===e&&"lat"===n)return Object.assign({},r(t),s(t));return{south:{i:o,j:a,k:c}}}function h(t){const{type:e,geoAxes:i}=t.params,n=i[0].name;let{i:s,j:a,k:c}=t;if("rect"===e&&"lat"===n)a+=1;else if("rect"===e&&"lng"===n)s-=1;else{if("hex"===e&&"lng"===n)return Object.assign({},r(t),o(t));"hex"===e&&"lat"===n&&(a+=1,c-=1)}return{east:{i:s,j:a,k:c}}}function u(t){const{type:e,geoAxes:i}=t.params,o=i[0].name;let{i:r,j:a,k:c}=t;if("rect"===e&&"lat"===o)a-=1;else if("rect"===e&&"lng"===o)r+=1;else{if("hex"===e&&"lng"===o)return Object.assign({},s(t),n(t));"hex"===e&&"lat"===o&&(a-=1,c+=1)}return{west:{i:r,j:a,k:c}}}Object.defineProperty(e,"__esModule",{value:!0}),e.getAll=function(t){const{type:e,geoAxes:i}=t.params,l=i[0].name;return"hex"===e&&"lat"===l?Object.assign({},a(t),c(t),r(t),s(t),o(t),n(t)):"hex"===e&&"lng"===l?Object.assign({},h(t),u(t),r(t),s(t),o(t),n(t)):Object.assign({},a(t),c(t),h(t),u(t),r(t),s(t),o(t),n(t))},e.getNorthWest=n,e.getNorthEast=o,e.getSouthWest=s,e.getSouthEast=r,e.getNorth=a,e.getSouth=c,e.getEast=h,e.getWest=u},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0);e.round=function(t){const{type:e}=t.params;if("hex"===e){const{i:e,j:i,k:o}=t;return function(t){const e=function(t){return Object.keys(t).reduce((e,i)=>{const o=t[i],s=n.decRemain(o);return e[i]=s,e},{})}(t),i=Object.keys(e).sort((t,i)=>e[i]-e[t]);let o=Object.values(e).reduce((t,e)=>t+e,0);return o=Math.round(o),i.reduce((e,i)=>(o>0?(e[i]=Math.ceil(t[i]),o-=1):e[i]=Math.floor(t[i]),e),{})}({i:e,j:i,k:o})}{const{i:e,j:i}=t;return function(t){return Object.keys(t).reduce((e,i)=>(e[i]=Math.round(t[i]),e),{})}({i:e,j:i})}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(38);e.PeakPoint=n.PeakPoint},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(39),o=i(4),s=i(40);class r extends o.GridPoint{get nearestPeaks(){return s.calcNearestPeaks(this).map(({i:t,j:e,k:i})=>{const n=new r(this.params,t,e,i).toGeo(),s=o.GridPoint.fromGeo(n,this.params);return new r(this.params,s.i,s.j,s.k)})}get nearestPeaksGeo(){return this.nearestPeaks.map(t=>t.toGeo())}static fromGeo(t,e){const{i:i,j:n,k:s}=o.GridPoint.fromGeo(t,e);return new r(e,i,n,s)}toFormatted(){const{params:t,i:e,j:i,k:n}=this;return new r(t,+e.toFixed(6),+i.toFixed(6),n&&+n.toFixed(6))}nearestNotSeparatedByPoly(t){const{nearestPeaks:e}=this;return e.reduce((e,i)=>{const o=n.CellSide.fromPeaks(this,i);return!t.intersectsSegment(o)&&e.push(i),e},[])}}e.PeakPoint=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(4),o=i(1);class s extends o.GeoSegment{constructor(t,e,i,n,o){super(t,e),this.peakA=i,this.peakB=n,this.params=o}get averagePoint(){const{i:t,j:e,k:i,params:o}=this.peakA,{i:s,j:r,k:a}=this.peakB;return new n.GridPoint(o,(t+s)/2,(e+r)/2,void 0!==i&&void 0!==a?(i+a)/2:void 0)}static fromPeaks(t,e){const i=t.toGeo(),n=e.toGeo();return new s(i,n,t,e,t.params)}}e.CellSide=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calcNearestPeaks=function(t){const{type:e}=t.params;return"hex"===e?function({i:t,j:e,k:i}){return 2===Math.round(t%1*3)?[{i:t+2/3,j:e-1/3,k:i-1/3},{i:t-1/3,j:e+2/3,k:i-1/3},{i:t-1/3,j:e-1/3,k:i+2/3}]:[{i:t-2/3,j:e+1/3,k:i+1/3},{i:t+1/3,j:e-2/3,k:i+1/3},{i:t+1/3,j:e+1/3,k:i-2/3}]}(t):function({i:t,j:e}){return[{i:t+1,j:e-1},{i:t+1,j:e+1},{i:t-1,j:e+1},{i:t-1,j:e-1}]}(t)}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(11),o=i(12),s=i(1),r=i(10),a=i(2),c=i(3),h=i(5);class u extends c.MercPoint{get zoomCoofX(){return 2**this.zoom*n.constants.googleTileSize/this.tileWidth}get zoomCoofY(){return 2**this.zoom*n.constants.googleTileSize/this.tileHeight}get northTile(){const{tileX:t,tileY:e,tileHeight:i,tileWidth:n,zoom:o}=this;return u.fromTile(t,e-1,n,i,o)}get southTile(){const{tileX:t,tileY:e,tileHeight:i,tileWidth:n,zoom:o}=this;return u.fromTile(t,e+1,n,i,o)}get eastTile(){const{tileX:t,tileY:e,tileHeight:i,tileWidth:n,zoom:o}=this;return u.fromTile(t+1,e,n,i,o)}get westTile(){const{tileX:t,tileY:e,tileHeight:i,tileWidth:n,zoom:o}=this;return u.fromTile(t-1,e,n,i,o)}get northBound(){return a.GeoPoint.fromMerc(this).lat}get southBound(){return a.GeoPoint.fromMerc(this.southTile).lat}get eastBound(){return a.GeoPoint.fromMerc(this.eastTile).lng}get westBound(){return a.GeoPoint.fromMerc(this).lng}get north(){return new s.GeoSegment(a.GeoPoint.fromMerc(this),a.GeoPoint.fromMerc(this.eastTile))}get south(){const t=this.southTile;return new s.GeoSegment(a.GeoPoint.fromMerc(t.eastTile),a.GeoPoint.fromMerc(t))}get east(){const t=this.eastTile;return new s.GeoSegment(a.GeoPoint.fromMerc(t),a.GeoPoint.fromMerc(t.southTile))}get west(){return new s.GeoSegment(a.GeoPoint.fromMerc(this.southTile),a.GeoPoint.fromMerc(this))}static fromTile(t,e,i,o,s){const r=t/(2**s*(n.constants.googleTileSize/i)),a=e/(2**s*(n.constants.googleTileSize/o));return new u(r,a,t,e,i,o,s)}static fromPlain({x:t,y:e,tileX:i,tileY:n,tileWidth:o,tileHeight:s,zoom:r}){return new u(t,e,i,n,o,s,r)}static fromMerc(t,e,i,o){const s=t.x*(2**o*(n.constants.googleTileSize/e)),r=t.y*(2**o*(n.constants.googleTileSize/i));return new u(t.x,t.y,s,r,e,i,o)}constructor(t,e,i,n,o,s,r){super(t,e),this.tileX=i,this.tileY=n,this.tileWidth=o,this.tileHeight=s,this.zoom=r}gridPatternStartPoint(t){const e=a.GeoPoint.fromMerc(this),i=r.CenterPoint.fromGeo(e,t),{northWest:n}=i.northWestNeighbors,o=n.toGeo().toMerc(),s=u.fromMerc(o,this.tileWidth,this.tileHeight,this.zoom);return this.startPointDiff(s)}startPointDiff(t){let e=t.tileX-this.tileX;const i=t.tileY-this.tileY;return e>this.tileX&&(e-=Math.ceil(e)),new h.Point(e,i)}toPoly(){const t=this.eastTile;return new o.GeoPolygon([a.GeoPoint.fromMerc(this),a.GeoPoint.fromMerc(t),a.GeoPoint.fromMerc(t.southTile),a.GeoPoint.fromMerc(this.southTile)])}containsPoint({lat:t,lng:e}){return t<=this.northBound&&t>=this.southBound&&e<=this.eastBound&&e>=this.westBound}projectGeoPoints(t){return t.map(t=>{const e=t.toMerc(),{tileX:i,tileY:n}=u.fromMerc(e,this.tileWidth,this.tileHeight,this.zoom),o=Math.round((i-this.tileX)*this.tileWidth),s=Math.round((n-this.tileY)*this.tileHeight);return new h.Point(o,s)})}toPlain(){return{x:this.x,y:this.y,tileX:this.tileX,tileY:this.tileY,zoom:this.zoom,tileHeight:this.tileHeight,tileWidth:this.tileWidth}}}e.TileMercPoint=u},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(2),o=i(1),s=i(43);class r extends s.GenericPolygon{sideByIndex(t){const{pointA:e,pointB:i}=super.sideByIndex(t);return new o.GeoSegment(e,i)}sideByIndexInversed(t){const{pointA:e,pointB:i}=super.sideByIndexInversed(t);return new o.GeoSegment(e,i)}splitSectionsByLng(t){const e=this.reduceSides((e,i)=>{const o=i.latByLng(t);if(void 0===o)return e;const s=new n.GeoPoint(o,t);return e.find(t=>t.isEqual(s))||e.push(s),e},[]);return o.GeoSegment.segmentsFromPointsByLat(e)}splitSectionsByLat(t){const e=this.reduceSides((e,i)=>{const o=i.lngByLat(t);if(void 0!==o){const i=new n.GeoPoint(t,o);e.push(i)}return e},[]);return o.GeoSegment.segmentsFromPointsByLng(e)}intersectsSegment(t){return super.intersectsSegment(t)}intersectsWithSegment(t){return super.intersectsWithSegment(t)}closestSideToSegment(t){const[e,i]=this.pointsByDistanceToSegment(t),n=this.points.indexOf(e),o=this.points.indexOf(i);return this.sideByIndex(Math.min(n,o))}pointsByDistanceToSegment(t){return[...this.points].sort((e,i)=>{return t.mercDistanceToPoint(e)-t.mercDistanceToPoint(i)})}pointsInsidePoly(t){return this.points.filter(e=>t.containsPoint(e))}pointsOutsidePoly(t){return this.points.filter(e=>!t.containsPoint(e))}arePointsInsidePoly(t){return this.points.every(e=>t.containsPoint(e))}arePointsOutsidePoly(t){return this.points.every(e=>!t.containsPoint(e))}containsPoint(t){return this.splitSectionsByLat(t.lat).reduce((e,i)=>e||i.containsLng(t.lng),!1)}isValidForFigure(t){if(this.outmapPoints.length>0)return!1;if(this.points.length<3)return!1;const{selfIntersections:e}=this;return!(e.length>0)}get outmapPoints(){return this.points.filter(t=>{const{y:e}=t.toMerc();return e>1||e<0})}get easternPoint(){return this.points.reduce((t,e)=>e.isEasternTo(t)?e:t,this.points[0])}get westernPoint(){return this.points.reduce((t,e)=>e.isWesternTo(t)?e:t,this.points[0])}get northernPoint(){return this.points.reduce((t,e)=>e.isNorthernTo(t)?e:t,this.points[0])}get southernPoint(){return this.points.reduce((t,e)=>e.isSouthernTo(t)?e:t,this.points[0])}toPlain(){return this.points.map(t=>t.toPlain())}toGeoJSON(){return{type:"Polygon",coordinates:[[...this.points,this.points[0]].map(({lat:t,lng:e})=>[e,t])]}}static fromGeoJSON({coordinates:[t]}){const e=n.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[0]}),i=n.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[t.length-1]});if(!e.isEqual(i))throw new Error("Loop is not closed");return r.fromPlain(t.slice(0,-1).map(([t,e])=>({lat:e,lng:t})))}static fromPlain(t){return new r(t.map(({lat:t,lng:e})=>new n.GeoPoint(t,e)))}}e.GeoPolygon=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.GenericPolygon=class{constructor(t){this.points=t}intersectsPoly(t){return this.reduceSides((e,i,n)=>t.reduceSides((t,e,n)=>{const o=i.intersectionPoint(e);return o&&t.push(o),t},e),[])}intersectsSegment(t){return this.reduceSides((e,i)=>!!e||!!i.intersectionPoint(t),!1)}intersectsWithSegment(t){return this.reduceSides((e,i)=>{const n=i.intersectionPoint(t);return n&&e.push(n),e},[])}get selfIntersections(){return this.reduceOppositeSidesPairs((t,e,i)=>{const n=e.intersectionPoint(i);return n&&t.push(n),t},[])}sideByIndex(t){return{pointA:this.points[t],pointB:this.nextPointByIndex(t)}}sideByIndexInversed(t){return{pointA:this.points[t],pointB:this.prevPointByIndex(t)}}nextIndex(t){return t===this.points.length-1?0:t+1}prevIndex(t){const{length:e}=this.points;return 0===t?e-1:t-1}nextPointByIndex(t){const e=this.nextIndex(t);return this.points[e]}prevPointByIndex(t){const e=this.prevIndex(t);return this.points[e]}forEachSide(t){this.points.forEach((e,i)=>{const n=this.sideByIndex(i);t(n,i)})}mapSides(t){return this.points.map((e,i)=>{const n=this.sideByIndex(i);return t(n,i)})}reduceSides(t,e){return this.points.reduce((e,i,n)=>{const o=this.sideByIndex(n);return t(e,o,n)},e)}forEachSidesPair(t){this.forEachSide((e,i)=>{this.forEachSide((n,o)=>{o<=i||t(e,n)})})}reduceSidesPairs(t,e){return this.reduceSides((e,i,n)=>this.reduceSides((e,o,s)=>s<=n?e:t(e,i,o),e),e)}reduceNeighboringSidesPairs(t,e){return this.points.reduce((e,i,n)=>{const o=this.sideByIndexInversed(n),s=this.sideByIndex(n);return t(e,o,s)},e)}reduceOppositeSidesPairs(t,e){const i=this.points.length-1;return this.reduceSides((e,n,o)=>this.reduceSides((e,s,r)=>0===o&&r===i||r-1<=o?e:t(e,n,s),e),e)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(4);function o(t,e,i,o,s,r){const a=e[i];let c=o.map(e=>t[e]);const h=c.map(({lng:t})=>t),u=Math.min(...h);Math.max(...h)-u>180&&(c=c.map(t=>t.toOppositeHemisphere()));const l=c.map(t=>n.GridPoint.fromGeo(t,s)),p=l.reduce((t,e,i)=>l.reduce((t,n,s)=>{if(i>=s)return t;const r=e,a=n;return l.forEach((e,n)=>{n!==i&&n!==s&&e.onSameAxis(r,a)&&t.push([i,s,n].sort((t,e)=>t-e).map(t=>o[t]))}),t},t),[]);let d;if(0===p.length)return!0;if(p.length>1&&p.every(t=>t.includes(i))){const t=o.filter(t=>p.every(e=>!e.includes(t)));return 1!==t.length||a<e[t[0]]===r}return d=p.reduce((t,n)=>{if(t)return t;if(n.includes(i))return!1;const o=n[1];return a<e[o]===r},!1),d}e.simplifyFigure=function(t,e,i){return"hex"===i.type?function(t,e,i){if(0===t.length)return t;if("rect"===i.type)return t;const s=t.length,r=e.containsPoint(t[0]),a=t.map(t=>e.reduceSides((e,i)=>{const n=i.mercDistanceToPoint(t);return Math.min(n,e)},1/0)),c=t.reduce((e,n,c)=>{const h=c-3<0?c-5+s:c-3,u=c-2<0?c-4+s:c-2,l=c-1<0?s-2:c-1,p=c+1>s-1?1:c+1,d=c+2>s-1?c+3-s:c+2;let m=o(t,a,c,[u,l,c,p,d,c+3>s-1?c+4-s:c+3],i,r);if(!m){m=o(t,a,c,[d,p,c,l,u,h],i,r)}return m&&e.push(n),e},[]),h=c.length,u=c.map(t=>n.GridPoint.fromGeo(t,i)),l=u.reduce((t,e,i)=>{const n=i+1===h?1:i+1,o=u[0===i?h-2:i-1],s=u[n];return e.onSameAxis(o,s)||t.push(c[i]),t},[]),p=l.length;l[0].isEqual(l[p-1])||l.push(l[0]);return l}(t,e,i):function(t){return t.filter((e,i)=>{const n=t[i-1],o=t[i+1];return!n||!o||![e.lat===n.lat||e.lng===n.lng,e.lat===o.lat||e.lng===o.lng,o.lat===n.lat||o.lng===n.lng].every(t=>t)})}(t)}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(46);e.GridParams=n.GridParams},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(47);class o{static fromConfig({isHorizontal:t=!1,type:e,correction:i,cellSize:s}){const r=t?"horizontal":"vertical",a=n.initCoofs[e][i][r],c=n.axesParams[e],h=n.calcAxesParams(t,e),u=n.calcInitialCellWidth(s,a),l=n.calcInitialCellHeight(s);return new o({isHorizontal:t,type:e,axes:c,geoAxes:h,initSize:u,initHeight:l,correction:i})}constructor({isHorizontal:t,type:e,axes:i,geoAxes:n,initSize:o,initHeight:s,correction:r}){this.isHorizontal=t,this.type=e,this.axes=i,this.geoAxes=n,this.initSize=o,this.initHeight=s,this.correction=r}minCellSize(t){const{tileWidth:e,zoomCoofX:i}=t,{initSize:n,initHeight:o,isHorizontal:s}=this;return(s?n:o)/1e7*e*i/360}isEqual(t){return this.isHorizontal===t.isHorizontal&&this.type===t.type&&this.correction===t.correction&&this.initSize===t.initSize}toPlain(){const{isHorizontal:t,type:e,axes:i,geoAxes:n,initSize:o,initHeight:s,correction:r}=this;return{isHorizontal:t,type:e,axes:i,geoAxes:n,initSize:o,initHeight:s,correction:r}}static fromPlain(t){return new o(t)}}e.GridParams=o},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(11),o=i(0),s=Math.sqrt(3)/2;e.axesParams={get hex(){return[{name:"i",angle:0},{name:"j",angle:120},{name:"k",angle:240}]},get rect(){return[{name:"i",angle:0},{name:"j",angle:90}]}},e.initCoofs={hex:{get merc(){return{vertical:.5*s,horizontal:.5}},get none(){return{vertical:s,horizontal:1}},get area(){return{vertical:s,horizontal:1}}},rect:{get merc(){return{vertical:.5,horizontal:.5}},get none(){return{vertical:1,horizontal:1}},get area(){return{vertical:2,horizontal:.5}}}},e.calcAxesParams=function(t,e){let i;switch(e){case"hex":i=120;break;case"rect":default:i=90}return[{name:t?"lng":"lat",angle:0},{name:t?"lat":"lng",angle:i}]},e.calcInitialCellWidth=function(t,e){const i=n.constants.equatorLength/36e8,s=Math.round(t/i);let r=o.calcClosestMultiple(s,36e8);return r>18e8&&(r=18e8),r<1&&(r=1),r*e},e.calcInitialCellHeight=function(t){const e=n.constants.meridianLength/36e8,i=Math.round(t/e);let s=o.calcClosestMultiple(i,18e8);return s>18e8&&(s=18e8),s<1&&(s=1),s}}]);',null)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(18),s=n(12);class o extends s.GenericPolygon{sideByIndex(t){const{pointA:e,pointB:n}=super.sideByIndex(t);return new i.MercSegment(e,n)}}e.MercPolygon=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(19),s=n(12);class o extends s.GenericPolygon{sideByIndex(t){const{pointA:e,pointB:n}=super.sideByIndex(t);return new i.Segment(e,n)}}e.Polygon=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(66);e.Area=i.Area},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(11),s=n(67);class o extends i.GeoPolygon{constructor(t,e,n){super(t),this.polys=e,this.centers=n}static async fromCellCenters(t){if(t.length<1)return new o([],[],t);o.worker||(o.worker=new s.AreaWorker);const e=t[0].params;await o.worker.postParams(e);const n=await o.worker.getBiggestSet(t),i=await o.worker.joinCenters(t);return new o(i[0],i,n)}static async biggestSet(t){return t.length<1?[]:(o.worker||(o.worker=new s.AreaWorker),await o.worker.getBiggestSet(t))}}e.Area=o},function(t,e,n){"use strict";var i=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const s=n(13),o=i(n(68)),r=n(8),a=n(69);e.AreaWorker=class{constructor(){"undefined"!=typeof window&&(this.worker=new s.WorkerService(new o.default))}terminate(){this.worker&&this.worker.terminate()}async postParams(t){this.worker&&await this.worker.post({type:"params",payload:{params:t.toPlain()}})}async getBiggestSet(t){if(0===t.length)return[];const e=t[0].params;if(!this.worker)return a.pickBiggestSet(t);const{data:n}=await this.worker.post({type:"biggest-set",payload:{centers:t.map(t=>t.toPlain()),params:e.toPlain()}});return n.centers.map(t=>r.CenterPoint.fromPlain(t,e))}async joinCenters(t){if(!this.worker)return a.buildArea(t);const{data:e}=await this.worker.post({type:"join-centers",payload:{centers:t.map(t=>t.toPlain())}});return e.polygons.map(t=>t.map(t=>r.GeoPoint.fromPlain(t)))}}},function(t,e,n){t.exports=function(){return n(14)('!function(t){var e={};function n(i){if(e[i])return e[i].exports;var r=e[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)n.d(i,r,function(e){return t[e]}.bind(null,r));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=20)}([function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(26);e.CenterPoint=i.CenterPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(7),r=n(4);class s{constructor(t,e){this.lat=t,this.lng=e}static createFormatted(t,e){return t=i.formatLat(t),e=i.formatLng(e),new s(t,e)}static fromUnsafeCoords(t,e){return t=i.reduceLat(t),e=i.reduceLng(e),new s(t,e)}static fromMerc(t){const{lat:e,lng:n}=t.toSphereLiteral();return new s(e,n)}isEqual(t){const e=this.toFormatted(),n=t.toFormatted();return e.lat===n.lat&&e.lng===n.lng}isCloserThroughAntiMeridian(t){const e=Math.min(this.lng,t.lng);return Math.max(this.lng,t.lng)-e>180}toOppositeHemisphere(){const t=i.reduceLng(this.lng-180);return new s(this.lat,t)}calcMercDistance(t){let e=this;this.isCloserThroughAntiMeridian(t)&&(e=this.toOppositeHemisphere(),t=t.toOppositeHemisphere());const n=e.toMerc(),i=t.toMerc();return n.distanceToPoint(i)}toMerc(){const t=i.lngToX(this.lng),e=i.latToY(this.lat);return new r.MercPoint(t,e)}toSemiSphere(){const{lat:t,lng:e}=this.toMerc().toSemiSphereLiteral();return new s(t,e)}fromSemiSphere(){const t=i.semiLngToX(this.lng),e=i.semiLatToY(this.lat),{lat:n,lng:o}=new r.MercPoint(t,e).toSphereLiteral();return new s(n,o)}toFormatted(){const t=i.formatLat(this.lat),e=i.formatLng(this.lng);return new s(t,e)}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng<t.lng:this.lng>t.lng}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng>t.lng:this.lng<t.lng}isNorthernTo(t){return this.lat>t.lat}isSouthernTo(t){return this.lat<t.lat}toPlain(){const{lat:t,lng:e}=this;return{lat:t,lng:e}}toGeoJSON(){return{type:"Point",coordinates:[this.lng,this.lat]}}static fromPlain({lat:t,lng:e}){return new s(t,e)}static fromGeoJSON({coordinates:[t,e]}){return s.fromPlain({lat:e,lng:t})}}e.GeoPoint=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calcNearestIndexes=function(t,e,n){const i=[[t+1,e],[t,e+1],[t-1,e],[t,e-1]];return"hex"!==n.type?i:(i.push([t-1,e+1],[t+1,e-1]),i)},e.calcNearestAndTouchedIndexes=function(t,e,n){const i=[[t+1,e],[t,e+1],[t-1,e],[t,e-1],[t-1,e+1],[t+1,e-1]];return"rect"!==n.type?i:(i.push([t+1,e+1],[t-1,e-1]),i)}},function(t,e,n){"use strict";function i(t){return t*Math.PI/180}Object.defineProperty(e,"__esModule",{value:!0}),e.floorNumStrByOrder=function(t){const e=t.length;if(t.split("").every(t=>"0"===t))return t;if(t.lastIndexOf(".")===e-2)return Math.floor(+t)+"";if(-1!==t.indexOf("."))return t.slice(0,-1);if(-1===t.indexOf("0"))return t.slice(0,-1)+"0";{const n=t.lastIndexOf("0");return t.slice(0,n-1)+"0".repeat(e-n+1)}},e.calcClosestMultiple=function(t,e){let n=t,i=t;for(;e%n!=0&&e%i!=0;)n+=1,i-=1;return e%n==0?n:i},e.cosDeg=function(t){const e=i(t);return Math.cos(e)},e.sinDeg=function(t){const e=i(t);return Math.sin(e)},e.findPrimeFactors=function(t){if(t<2)return[];let e=t,n=2;const i=[];for(;n*n<=e;)e%n==0?(i.push(n),e/=n):n+=1;return 1!==e&&i.push(e),i},e.degToRad=i,e.radToDeg=function(t){return 180*t/Math.PI},e.decRemain=function(t){return t-Math.floor(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(6),r=n(12);class s extends i.Point{constructor(t,e){super(t=r.reduceX(t),e)}toFormatted(){return new s(+this.x.toFixed(10),+this.y.toFixed(10))}toOppositeHemisphere(){const t=r.reduceX(this.x-.5);return new s(t,this.y)}calcMercDistance(t){return(this.isCloserThroughAntiMeridian(t)?this.toOppositeHemisphere():this).distanceToPoint(t)}isCloserThroughAntiMeridian(t){const e=Math.min(this.x,t.x);return Math.max(this.x,t.x)-e>1}toSphereLiteral(){return{lat:r.yToLat(this.y),lng:r.xToLng(this.x)}}toSemiSphereLiteral(){return{lat:r.yToSemiLat(this.y),lng:r.xToSemiLng(this.x)}}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x<t.x:this.x>t.x}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x>t.x:this.x<t.x}isNorthernTo(t){return this.y>t.y}isSouthernTo(t){return this.y<t.y}}e.MercPoint=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(27);e.GridPoint=i.GridPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class i{constructor(t,e){this.x=t,this.y=e}distanceToPoint({x:t,y:e}){return Math.sqrt(Math.pow(t-this.x,2)+Math.pow(e-this.y,2))}toFormatted(){return this}toPlain(){return{x:this.x,y:this.y}}static fromPlain({x:t,y:e}){return new i(t,e)}containedByLine(t){return t.hasPoint(this)}containedBySegment(t){return t.hasPoint(this)}isEqual(t){const e=this.toFormatted(),n=t.toFormatted();return e.x===n.x&&e.y===n.y}distanceToLine(t){return t.distanceToPoint(this)}closestOnLine(t){return t.closestToPoint(this)}closestOnSegment(t){return t.closestToPoint(this)}}e.Point=i},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(3);function r(t){return(t>360||t<-360)&&(t%=360),t>=180?t-360:t<-180?t+360:t}e.semiLatToY=function(t){return-t/180+.5},e.semiLngToX=function(t){return t/360+.5},e.latToY=function(t){return(-Math.log(Math.tan(Math.PI/4+i.degToRad(t)/2))/Math.PI+1)/2},e.lngToX=function(t){return(i.degToRad(t)/Math.PI+1)/2},e.formatLat=function(t){return t>90&&(t=90),t<-90&&(t=-90),+t.toFixed(7)},e.formatLng=function(t){return+(t=r(t)).toFixed(7)},e.reduceLat=function(t){return(t>360||t<-360)&&(t%=360),t>90?180-t:t<-90?-180+t:t},e.reduceLng=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(7),r=n(35),s=n(1),o=n(37);class a{constructor(t,e){this.pointA=t,this.pointB=e,this.rhumbLine=r.RhumbLine.fromTwoGeoPoints(t,e)}get points(){return[this.pointA,this.pointB]}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallel(){return this.pointA.lat===this.pointB.lat}get isMeridian(){return this.pointA.lat===this.pointB.lat}get easternPoint(){return this.isMeridian?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isMeridian?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallel?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallel?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}static segmentsFromPointsByLng(t){const e=t.sort(({lng:t},{lng:e})=>t-e),n=e.reduce((t,n,i)=>e[t].isEasternTo(n)?i:t,0);return[...e.slice(n),...e.slice(0,n)].reduce((t,e,n,i)=>{if(n%2)return t;const r=new a(i[n+1],e);return t.push(r),t},[])}static segmentsFromPointsByLat(t){return t.sort(({lat:t},{lat:e})=>t-e).reduce((t,e,n,i)=>{if(n%2)return t;const r=new a(i[n+1],e);return t.push(r),t},[])}toMerc(){const t=this.pointA.toMerc(),e=this.pointB.toMerc();return new o.MercSegment(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new a(t,e)}intersectsWithPoly(t){return t.intersectsWithSegment(this)}intersects(t){return!!this.intersectionPoint(t)}intersectionPoint(t){let e=this,n=t;const i=this.isAntiMeridian||t.isAntiMeridian;i&&(e=e.toOppositeHemisphere(),n=n.toOppositeHemisphere());const r=e.toMerc(),o=n.toMerc(),a=r.intersectionPoint(o);if(!a)return;const c=s.GeoPoint.fromMerc(a);return i?c.toOppositeHemisphere():c}closestToPoint(t){const{isAntiMeridian:e}=this;let n=this;e&&(n=n.toOppositeHemisphere(),t=t.toOppositeHemisphere());const i=t.toMerc(),r=n.toMerc().closestToPoint(i),o=s.GeoPoint.fromMerc(r);return e?o.toOppositeHemisphere():o}isEqual({pointA:t,pointB:e}){return this.pointA.isEqual(t)&&this.pointB.isEqual(e)||this.pointA.isEqual(e)&&this.pointB.isEqual(t)}mercDistanceToPoint(t){const e=this.closestToPoint(t);return t.calcMercDistance(e)}latByLng(t){if(!this.containsLng(t))return;const e=this.rhumbLine.latByLng(t);return void 0===e||0!==this.rhumbLine.a&&!this.containsLat(e)?void 0:e}lngByLat(t){if(!this.containsLat(t))return;const e=this.rhumbLine.lngByLat(t);return void 0===e||0!==this.rhumbLine.b&&!this.containsLng(e)?void 0:e}containsLat(t){t=i.formatLat(t);const{lat:e}=this.pointA.toFormatted(),{lat:n}=this.pointB.toFormatted();return Math.max(e,n)>=t&&Math.min(e,n)<=t}containsLng(t){t=i.formatLng(t);const{lng:e}=this.pointA.toFormatted(),{lng:n}=this.pointB.toFormatted(),r=Math.max(e,n),s=Math.min(e,n);return this.isAntiMeridian?r<=t&&t<180||s>=t&&t>=-180:r>=t&&s<=t}containsPoint({lat:t,lng:e}){return this.containsLat(t)&&this.containsLng(e)}containsSegment({pointA:t,pointB:e}){return this.containsPoint(t)&&this.containsPoint(e)}overlapsSegment(t){const{pointA:e,pointB:n}=t;return this.containsPoint(e)||this.containsPoint(n)||t.containsPoint(this.pointB)||t.containsPoint(this.pointB)}}e.GeoSegment=a},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0);e.calcTopLeft=function(t){const e=t.findIndex(t=>t.some(t=>t instanceof i.CenterPoint)),n=t[e].findIndex(t=>t instanceof i.CenterPoint);return t[e][n].moveByDiff(-e,-n)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.constants={equatorLength:40075696,radius:6370997,meridianLength:40007860,googleTileSize:256}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(25);e.Cell=i.Cell},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(3);e.yToLat=function(t){const e=Math.atan(Math.E**(-(2*t-1)*Math.PI))-Math.PI/4;return 2*i.radToDeg(e)},e.xToLng=function(t){const e=(2*t-1)*Math.PI;return i.radToDeg(e)},e.yToSemiLat=function(t){return 180*-(t-.5)},e.xToSemiLng=function(t){return 360*(t-.5)},e.reduceX=function(t){return t%=1}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(34);e.PeakPoint=i.PeakPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(5),r=n(8);class s extends r.GeoSegment{constructor(t,e,n,i,r){super(t,e),this.peakA=n,this.peakB=i,this.params=r}get averagePoint(){const{i:t,j:e,k:n,params:r}=this.peakA,{i:s,j:o,k:a}=this.peakB;return new i.GridPoint(r,(t+s)/2,(e+o)/2,void 0!==n&&void 0!==a?(n+a)/2:void 0)}static fromPeaks(t,e){const n=t.toGeo(),i=e.toGeo();return new s(n,i,t,e,t.params)}}e.CellSide=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(4),r=n(16);class s extends r.Line{static fromTwoPoints(t,e){const{a:n,b:i,c:o}=r.Line.fromTwoPoints(t,e);return new s(n,i,o)}calcAlikePoint(t){const{x:e,y:n}=super.calcAlikePoint(t);return new i.MercPoint(e,n)}closestToPoint(t){const{x:e,y:n}=super.closestToPoint(t);return new i.MercPoint(e,n)}perpendicularByPoint(t){const{a:e,b:n,c:i}=super.perpendicularByPoint(t);return new s(e,n,i)}intersectionPoint(t){const e=super.intersectionPoint(t);if(!e)return;const{x:n,y:r}=e;return new i.MercPoint(n,r)}}e.MercLine=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(6),r=n(36);class s{constructor(t,e,n){this.a=t,this.b=e,this.c=n}get isParallelToAxisX(){return 0===this.b}get isParallelToAxisY(){return 0===this.a}static fromTwoPoints({x:t,y:e},{x:n,y:i}){return new s(e-i,n-t,-(t*i-e*n))}calcAlikePoint(t){const e=this.xByY(t.y),n=this.yByX(t.x);return new i.Point(void 0===e?t.x:e,void 0===n?t.y:n)}hasPoint(t){return this.calcAlikePoint(t).isEqual(t)}xByY(t){if(!this.isParallelToAxisY)return(this.c-this.b*t)/this.a}yByX(t){if(!this.isParallelToAxisX)return(this.c-this.a*t)/this.b}distanceToPoint(t){const e=this.closestToPoint(t);return t.distanceToPoint(e)}getNormalVector(){return new r.Vector(this.a,this.b)}closestToPoint(t){const{x:e,y:n}=t;if(this.isParallelToAxisX)return new i.Point(this.c/this.a,n);if(this.isParallelToAxisY)return new i.Point(e,this.c/this.b);const r=this.perpendicularByPoint(t);return this.intersectionPoint(r)}perpendicularByPoint({x:t,y:e}){const{x:n,y:i}=this.getNormalVector();return new s(1/n,-1/i,t/n-e/i)}intersectionX({a:t,b:e,c:n}){const i=this.a*e-this.b*t,r=this.c*e-this.b*n;if(i)return r/i}intersectionY({a:t,b:e,c:n}){const i=this.a*e-this.b*t,r=this.a*n-this.c*t;if(i)return r/i}intersectionPoint(t){if(t.isParallelToAxisX&&this.isParallelToAxisX||t.isParallelToAxisY&&this.isParallelToAxisY)return;const{a:e,b:n,c:r}=t;let s,o;return s=t.isParallelToAxisX?r/e:this.isParallelToAxisX?this.c/this.a:this.intersectionX(t),o=t.isParallelToAxisY?r/n:this.isParallelToAxisY?this.c/this.b:this.intersectionY(t),void 0===s&&void 0!==o&&(s=this.xByY(o)||t.xByY(o)),void 0!==s&&void 0===o&&(o=this.yByX(s)||t.yByX(s)),void 0!==s&&void 0!==o?new i.Point(s,o):void 0}}e.Line=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1),r=n(8),s=n(40);class o extends s.GenericPolygon{sideByIndex(t){const{pointA:e,pointB:n}=super.sideByIndex(t);return new r.GeoSegment(e,n)}sideByIndexInversed(t){const{pointA:e,pointB:n}=super.sideByIndexInversed(t);return new r.GeoSegment(e,n)}splitSectionsByLng(t){const e=this.reduceSides((e,n)=>{const r=n.latByLng(t);if(void 0===r)return e;const s=new i.GeoPoint(r,t);return e.find(t=>t.isEqual(s))||e.push(s),e},[]);return r.GeoSegment.segmentsFromPointsByLat(e)}splitSectionsByLat(t){const e=this.reduceSides((e,n)=>{const r=n.lngByLat(t);if(void 0!==r){const n=new i.GeoPoint(t,r);e.push(n)}return e},[]);return r.GeoSegment.segmentsFromPointsByLng(e)}intersectsSegment(t){return super.intersectsSegment(t)}intersectsWithSegment(t){return super.intersectsWithSegment(t)}closestSideToSegment(t){const[e,n]=this.pointsByDistanceToSegment(t),i=this.points.indexOf(e),r=this.points.indexOf(n);return this.sideByIndex(Math.min(i,r))}pointsByDistanceToSegment(t){return[...this.points].sort((e,n)=>{return t.mercDistanceToPoint(e)-t.mercDistanceToPoint(n)})}pointsInsidePoly(t){return this.points.filter(e=>t.containsPoint(e))}pointsOutsidePoly(t){return this.points.filter(e=>!t.containsPoint(e))}arePointsInsidePoly(t){return this.points.every(e=>t.containsPoint(e))}arePointsOutsidePoly(t){return this.points.every(e=>!t.containsPoint(e))}containsPoint(t){return this.splitSectionsByLat(t.lat).reduce((e,n)=>e||n.containsLng(t.lng),!1)}isValidForFigure(t){if(this.outmapPoints.length>0)return!1;if(this.points.length<3)return!1;const{selfIntersections:e}=this;return!(e.length>0)}get outmapPoints(){return this.points.filter(t=>{const{y:e}=t.toMerc();return e>1||e<0})}get easternPoint(){return this.points.reduce((t,e)=>e.isEasternTo(t)?e:t,this.points[0])}get westernPoint(){return this.points.reduce((t,e)=>e.isWesternTo(t)?e:t,this.points[0])}get northernPoint(){return this.points.reduce((t,e)=>e.isNorthernTo(t)?e:t,this.points[0])}get southernPoint(){return this.points.reduce((t,e)=>e.isSouthernTo(t)?e:t,this.points[0])}toPlain(){return this.points.map(t=>t.toPlain())}toGeoJSON(){return{type:"Polygon",coordinates:[[...this.points,this.points[0]].map(({lat:t,lng:e})=>[e,t])]}}static fromGeoJSON({coordinates:[t]}){const e=i.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[0]}),n=i.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[t.length-1]});if(!e.isEqual(n))throw new Error("Loop is not closed");return o.fromPlain(t.slice(0,-1).map(([t,e])=>({lat:e,lng:t})))}static fromPlain(t){return new o(t.map(({lat:t,lng:e})=>new i.GeoPoint(t,e)))}}e.GeoPolygon=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(44);e.CentersMatrix=i.CentersMatrix},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(50);e.PolyMatrix=i.PolyMatrix},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(21),r=n(24),s=n(61),o=n(62),a=self,c=new s.CtxService(a);let u;c.onMessage(t=>{const{data:e}=t;if("params"===e.type){const{payload:{params:t}}=e;return u=i.GridParams.fromPlain(t),void c.post("")}if("biggest-set"!==e.type){if("join-centers"===e.type){if(!u)throw new Error("Grid params wasn\'t provided.");const{payload:{centers:t}}=e,n=t.map(t=>o.CenterPoint.fromPlain(t,u)),i=r.buildArea(n);c.post({polygons:i.map(t=>t.map(t=>t.toPlain()))})}}else{const{payload:{centers:t,params:n}}=e,s=i.GridParams.fromPlain(n),a=t.map(t=>o.CenterPoint.fromPlain(t,s)),u=r.pickBiggestSet(a);c.post({centers:u.map(t=>t.toPlain())})}}),e.default={}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(22);e.GridParams=i.GridParams},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(23);class r{static fromConfig({isHorizontal:t=!1,type:e,correction:n,cellSize:s}){const o=t?"horizontal":"vertical",a=i.initCoofs[e][n][o],c=i.axesParams[e],u=i.calcAxesParams(t,e),h=i.calcInitialCellWidth(s,a),l=i.calcInitialCellHeight(s);return new r({isHorizontal:t,type:e,axes:c,geoAxes:u,initSize:h,initHeight:l,correction:n})}constructor({isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:r,initHeight:s,correction:o}){this.isHorizontal=t,this.type=e,this.axes=n,this.geoAxes=i,this.initSize=r,this.initHeight=s,this.correction=o}minCellSize(t){const{tileWidth:e,zoomCoofX:n}=t,{initSize:i,initHeight:r,isHorizontal:s}=this;return(s?i:r)/1e7*e*n/360}isEqual(t){return this.isHorizontal===t.isHorizontal&&this.type===t.type&&this.correction===t.correction&&this.initSize===t.initSize}toPlain(){const{isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:r,initHeight:s,correction:o}=this;return{isHorizontal:t,type:e,axes:n,geoAxes:i,initSize:r,initHeight:s,correction:o}}static fromPlain(t){return new r(t)}}e.GridParams=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(10),r=n(3),s=Math.sqrt(3)/2;e.axesParams={get hex(){return[{name:"i",angle:0},{name:"j",angle:120},{name:"k",angle:240}]},get rect(){return[{name:"i",angle:0},{name:"j",angle:90}]}},e.initCoofs={hex:{get merc(){return{vertical:.5*s,horizontal:.5}},get none(){return{vertical:s,horizontal:1}},get area(){return{vertical:s,horizontal:1}}},rect:{get merc(){return{vertical:.5,horizontal:.5}},get none(){return{vertical:1,horizontal:1}},get area(){return{vertical:2,horizontal:.5}}}},e.calcAxesParams=function(t,e){let n;switch(e){case"hex":n=120;break;case"rect":default:n=90}return[{name:t?"lng":"lat",angle:0},{name:t?"lat":"lng",angle:n}]},e.calcInitialCellWidth=function(t,e){const n=i.constants.equatorLength/36e8,s=Math.round(t/n);let o=r.calcClosestMultiple(s,36e8);return o>18e8&&(o=18e8),o<1&&(o=1),o*e},e.calcInitialCellHeight=function(t){const e=i.constants.meridianLength/36e8,n=Math.round(t/e);let s=r.calcClosestMultiple(n,18e8);return s>18e8&&(s=18e8),s<1&&(s=1),s}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(11),r=n(18),s=n(48),o=n(57),a=n(60);e.buildArea=function(t){if(0===t.length)return[[]];if(1===t.length)return[i.Cell.fromCenter(t[0]).points];const e=r.CentersMatrix.fromCenters(t),n=a.getBiggestSet(e),c=e.filterBySet(n),{innerEmpties:u}=c,h=o.OuterCentersMatrix.fromCentersMatrix(c),l=u.map(t=>s.InnerCentersMatrix.fromCentersMatrix(c,t));return[h.toPoly(),...l.map(t=>t.toPoly())]},e.pickBiggestSet=function(t){if(0===t.length)return[];const e=r.CentersMatrix.fromCenters(t);return[...a.getBiggestSet(e)]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),r=n(13),s=n(14),o=n(17),a=n(41),c=n(42),u=n(43);class h extends o.GeoPolygon{get neighbors(){const{west:t,southWest:e,east:n,southEast:i,south:r,northEast:s,north:o,northWest:a}=this.center.neighbors;return{west:t&&new h(t),southWest:new h(e),east:n&&new h(n),southEast:new h(i),south:r&&new h(r),northEast:new h(s),north:o&&new h(o),northWest:new h(a)}}get northNeighbors(){const{northEast:t,north:e,northWest:n}=this.center.northNeighbors;return{northEast:t&&new h(t),north:e&&new h(e),northWest:n&&new h(n)}}get southNeighbors(){const{southWest:t,southEast:e,south:n}=this.center.southNeighbors;return{southWest:t&&new h(t),southEast:e&&new h(e),south:n&&new h(n)}}get westNeighbors(){const{west:t,southWest:e,northWest:n}=this.center.westNeighbors;return{west:t&&new h(t),southWest:e&&new h(e),northWest:n&&new h(n)}}get eastNeighbors(){const{east:t,southEast:e,northEast:n}=this.center.eastNeighbors;return{east:t&&new h(t),southEast:e&&new h(e),northEast:n&&new h(n)}}get northEastNeighbors(){const{northEast:t}=this.center.northEastNeighbors;return{northEast:new h(t)}}get southWestNeighbors(){const{southWest:t}=this.center.southWestNeighbors;return{southWest:new h(t)}}get northWestNeighbors(){const{northWest:t}=this.center.northWestNeighbors;return{northWest:new h(t)}}get southEastNeighbors(){const{southEast:t}=this.center.southEastNeighbors;return{southEast:new h(t)}}static fromCenter(t){return new h(t)}static fromGeoPoint(t,e){const n=i.CenterPoint.fromGeo(t,e);return new h(n)}static fromGridPoint(t){const e=i.CenterPoint.fromGrid(t);return new h(e)}static fromCenterPoint(t){return new h(t)}constructor(t){const e=a.expand(t).map(({i:e,j:n,k:i})=>new r.PeakPoint(t.params,e,n,i));super(e.map(t=>t.toGeo().toFormatted())),this.peaks=e,this.center=t}findEqualGeoPoint(t){return this.points.find(e=>e.isEqual(t))}intersectedWithSegmentNeighbor(t){return u.getIntersectedWithSegmentNeighbor(this,t)}intersectedWithSegmentsNeighbors(t){return t.reduce((t,e)=>{const n=this.intersectedWithSegmentNeighbor(e);return n&&!t.find(t=>t.isEqual(n))&&t.push(n),t},[])}nearestPeaks(t){const e=[],n=this.prevPeak(t),i=this.nextPeak(t);return n&&e.push(n),i&&e.push(i),e}nearestPeaksGeo(t){const e=[],n=this.prevPeakGeo(t),i=this.nextPeakGeo(t);return n&&e.push(n),i&&e.push(i),e}prevPeak(t){const e=this.peaks.findIndex(e=>t.isEqual(e));if(-1!==e)return this.prevPeakByIndex(e)}nextPeak(t){const e=this.peaks.findIndex(e=>t.isEqual(e));if(-1!==e)return this.nextPeakByIndex(e)}prevPeakGeo(t){const e=this.points.findIndex(e=>t.isEqual(e));if(-1!==e)return this.prevPointByIndex(e)}nextPeakGeo(t){const e=this.points.findIndex(e=>t.isEqual(e));if(-1!==e)return this.nextPointByIndex(e)}nextPeakByIndex(t){const e=this.nextIndex(t);return this.peaks[e]}prevPeakByIndex(t){const e=this.prevIndex(t);return this.peaks[e]}isEqual(t){return this.center.isEqual(t.center)}sideByIndex(t){const{pointA:e,pointB:n}=super.sideByIndex(t),i=this.points.indexOf(e),r=this.points.indexOf(n);return new s.CellSide(e,n,this.peaks[i],this.peaks[r],this.center.params)}nextCellBySide(t){const e=this.center.nextCenterByCellSide(t);return new h(e)}containsPoint(t){const e=i.CenterPoint.fromGeo(t,this.center.params);return this.center.isEqual(e)}nearestToEndIntersectedSide(t){const{pointB:e}=t;if(this.containsPoint(e))return;const n=this.reduceSides((n,i)=>{const r=i.intersectionPoint(t);if(r){n[e.calcMercDistance(r)]=i}return n},{}),i=Object.keys(n).map(t=>+t);return 0!==i.length?n[Math.min(...i)]:void 0}nextCellOnSegment(t){const{pointA:e,pointB:n}=t,r=i.CenterPoint.fromGeo(e,this.center.params),s=i.CenterPoint.fromGeo(n,this.center.params);if(r.isEqual(s))return;const o=this.nearestToEndIntersectedSide(t);return o?this.nextCellBySide(o):void 0}isNeighbor(t){return this.center.isNeighbor(t.center)}commonPoints(t){return c.getCommonPoints(this,t)}moveByDiff(t,e){const n=this.center.moveByDiff(t,e);return h.fromCenter(n)}}e.Cell=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(5),r=n(30),s=n(31),o=n(32),a=n(33);class c extends i.GridPoint{get neighbors(){const{south:t,north:e,west:n,east:i,southEast:r,southWest:s,northEast:a,northWest:u}=o.getAll(this);return{south:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),west:n&&c.fromObject(n,this.params),east:i&&c.fromObject(i,this.params),southEast:c.fromObject(r,this.params),southWest:c.fromObject(s,this.params),northEast:c.fromObject(a,this.params),northWest:c.fromObject(u,this.params)}}get northNeighbors(){const{northWest:t,north:e,northEast:n}=o.getNorth(this);return{northWest:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),northEast:n&&c.fromObject(n,this.params)}}get southNeighbors(){const{southWest:t,south:e,southEast:n}=o.getSouth(this);return{southWest:t&&c.fromObject(t,this.params),south:e&&c.fromObject(e,this.params),southEast:n&&c.fromObject(n,this.params)}}get westNeighbors(){const{southWest:t,west:e,northWest:n}=o.getWest(this);return{southWest:t&&c.fromObject(t,this.params),west:e&&c.fromObject(e,this.params),northWest:n&&c.fromObject(n,this.params)}}get eastNeighbors(){const{southEast:t,east:e,northEast:n}=o.getEast(this);return{southEast:t&&c.fromObject(t,this.params),east:e&&c.fromObject(e,this.params),northEast:n&&c.fromObject(n,this.params)}}get northEastNeighbors(){const{northEast:t}=o.getNorthEast(this);return{northEast:c.fromObject(t,this.params)}}get southWestNeighbors(){const{southWest:t}=o.getSouthWest(this);return{southWest:c.fromObject(t,this.params)}}get northWestNeighbors(){const{northWest:t}=o.getNorthWest(this);return{northWest:c.fromObject(t,this.params)}}get southEastNeighbors(){const{southEast:t}=o.getSouthEast(this);return{southEast:c.fromObject(t,this.params)}}static fromObject({i:t,j:e,k:n},i){return new c(i,t,e,n)}static fromGeo(t,e){const n=i.GridPoint.fromGeo(t,e);return c.fromGrid(n)}static fromGrid(t){const{i:e,j:n,k:r}=a.round(t),s=new i.GridPoint(t.params,e,n,r).toGeo(),o=i.GridPoint.fromGeo(s,t.params),{i:u,j:h,k:l}=a.round(o);return new c(t.params,u,h,l)}nextCenterByCellSide(t){const{i:e,j:n,k:s}=r.getNextCenterByCellSide(this,t),o=new i.GridPoint(this.params,e,n,s).toGeo();return c.fromGeo(o,this.params)}isNeighbor(t){let e=this,n=t;return this.isCloserThroughAntiMeridian(t)&&(e=e.toOppositeHemishpere(),n=n.toOppositeHemishpere()),s.isNeighbor(e,n)}isCloserThroughAntiMeridian(t){return this.toGeo().isCloserThroughAntiMeridian(t.toGeo())}toOppositeHemishpere(){const t=this.toGeo().toOppositeHemisphere();return c.fromGeo(t,this.params)}moveByDiff(t,e){const n=this.i+t,i=this.j+e,r=void 0===this.k?void 0:this.k-(t+e),s=new c(this.params,n,i,r).toGeo();return c.fromGeo(s,this.params)}toPlain(){return{i:this.i,j:this.j,k:this.k}}static fromPlain({i:t,j:e,k:n},i){return new c(i,t,e,n)}}e.CenterPoint=c},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1),r=n(28),s=n(29);class o{static fromGeo(t,e){const n=r.correctForGrid(t,e),{axes:i}=e,{i:a,j:c,k:u}=i.reduce((t,i)=>(t[i.name]=s.toGrid(n,i,e),t),{});return new o(e,a,c,u)}constructor(t,e,n,i){this.params=t,this.i=e,this.j=n,this.k=i}toFormatted(){return this}isEasternTo(t){return this.toGeo().isEasternTo(t.toGeo())}isWesternTo(t){return this.toGeo().isWesternTo(t.toGeo())}isNorthernTo(t){return this.toGeo().isNorthernTo(t.toGeo())}isSouthernTo(t){return this.toGeo().isSouthernTo(t.toGeo())}isEqual(t){const{i:e,j:n,k:i}=this.toFormatted(),{i:r,j:s,k:o}=t.toFormatted();return e===r&&n===s&&i===o}toGeo(){const{geoAxes:t}=this.params,{lat:e,lng:n}=t.reduce((t,e)=>(t[e.name]=s.toGeo(this,e),t),{}),o=new i.GeoPoint(e,n);return r.correctForGeo(o,this.params)}onSameAxis(t,e){let n=(this.i-t.i)*(this.j-e.j)-(this.i-e.i)*(this.j-t.j);return"hex"===this.params.type&&(n*=3),0===Math.round(n)}}e.GridPoint=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(1);e.correctForGrid=function(t,{correction:e}){if("merc"===e){const{lat:e,lng:n}=t.toSemiSphere();return new i.GeoPoint(e,n/2)}return t},e.correctForGeo=function(t,e){const{correction:n}=e;if("merc"===n){const{lat:e,lng:n}=t;return new i.GeoPoint(e,2*n).fromSemiSphere().toFormatted()}return t.toFormatted()},e.correctPoly=function(t,{correction:e}){return t}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(3);e.toGrid=function(t,e,n){return function(t,e){const n=e.initSize;return 1e7*t/n}(function(t,e,n){const r=n?"lat":"lng",s=t[n?"lng":"lat"],o=t[r],a=e.angle,c=i.sinDeg(a),u=i.cosDeg(a);return o*c+s*u}(t,e,n.isHorizontal),n)},e.toGeo=function(t,e){return function(t,e){const n=e.initSize;return t*n/1e7}(function(t,e){const{isHorizontal:n}=t.params,r=n?"lng":"lat",s=n?"lat":"lng",o=e.angle,a=i.sinDeg(o),c=i.cosDeg(o);let u;switch(e.name){case r:u=(t.i-t.j*a)/c;break;case s:u=(t.j-t.i*c)/a;break;default:u=t.j*a+t.i*c}return u}(t,e),t.params)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getNextCenterByCellSide=function(t,e){const{i:n,j:i,k:r}=t,{averagePoint:{i:s,j:o,k:a}}=e;return{i:Math.round(n+2*(s-n)),j:Math.round(i+2*(o-i)),k:void 0!==r&&void 0!==a?Math.round(r+2*(a-r)):void 0}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNeighbor=function(t,e){const{type:n}=t.params;return"hex"===n?function({i:t,j:e,k:n},{i:i,j:r,k:s}){const o=[t-i,e-r,n-s];return o.includes(0)&&o.includes(1)&&o.includes(-1)}(t,e):function({i:t,j:e},{i:n,j:i}){const r=[Math.abs(t-n),Math.abs(e-i)];return r.includes(0)&&r.includes(1)}(t,e)}},function(t,e,n){"use strict";function i(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:r,j:s}=t;const{k:o}=t;return"rect"===e&&"lat"===i?(r+=1,s-=1):"rect"===e&&"lng"===i?(r-=1,s+=1):"hex"===e&&"lat"===i?(r+=1,s-=1):"hex"===e&&"lng"===i&&(r-=1,s+=1),{northWest:{i:r,j:s,k:o}}}function r(t){const{type:e}=t.params;let{i:n,j:i,k:r}=t;return"rect"===e?(n+=1,i+=1):"hex"===e&&(n+=1,r-=1),{northEast:{i:n,j:i,k:r}}}function s(t){const{type:e}=t.params;let{i:n,j:i,k:r}=t;return"rect"===e?(n-=1,i-=1):"hex"===e&&(n-=1,r+=1),{southWest:{i:n,j:i,k:r}}}function o(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:r,j:s}=t;const{k:o}=t;return"rect"===e&&"lat"===i?(r-=1,s+=1):"rect"===e&&"lng"===i?(r+=1,s-=1):"hex"===e&&"lat"===i?(r-=1,s+=1):"hex"===e&&"lng"===i&&(r+=1,s-=1),{southEast:{i:r,j:s,k:o}}}function a(t){const{type:e,geoAxes:n}=t.params,s=n[0].name;let{i:o,j:a,k:c}=t;if("rect"===e&&"lat"===s)o+=1;else if("rect"===e&&"lng"===s)a+=1;else if("hex"===e&&"lat"===s)a+=1,c-=1;else if("hex"===e&&"lng"===s)return Object.assign({},r(t),i(t));return{north:{i:o,j:a,k:c}}}function c(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:r,j:a,k:c}=t;if("rect"===e&&"lat"===i)r-=1;else if("rect"===e&&"lng"===i)a-=1;else if("hex"===e&&"lng"===i)a-=1,c+=1;else if("hex"===e&&"lat"===i)return Object.assign({},o(t),s(t));return{south:{i:r,j:a,k:c}}}function u(t){const{type:e,geoAxes:n}=t.params,i=n[0].name;let{i:s,j:a,k:c}=t;if("rect"===e&&"lat"===i)a+=1;else if("rect"===e&&"lng"===i)s-=1;else{if("hex"===e&&"lng"===i)return Object.assign({},o(t),r(t));"hex"===e&&"lat"===i&&(a+=1,c-=1)}return{east:{i:s,j:a,k:c}}}function h(t){const{type:e,geoAxes:n}=t.params,r=n[0].name;let{i:o,j:a,k:c}=t;if("rect"===e&&"lat"===r)a-=1;else if("rect"===e&&"lng"===r)o+=1;else{if("hex"===e&&"lng"===r)return Object.assign({},s(t),i(t));"hex"===e&&"lat"===r&&(a-=1,c+=1)}return{west:{i:o,j:a,k:c}}}Object.defineProperty(e,"__esModule",{value:!0}),e.getAll=function(t){const{type:e,geoAxes:n}=t.params,l=n[0].name;return"hex"===e&&"lat"===l?Object.assign({},a(t),c(t),o(t),s(t),r(t),i(t)):"hex"===e&&"lng"===l?Object.assign({},u(t),h(t),o(t),s(t),r(t),i(t)):Object.assign({},a(t),c(t),u(t),h(t),o(t),s(t),r(t),i(t))},e.getNorthWest=i,e.getNorthEast=r,e.getSouthWest=s,e.getSouthEast=o,e.getNorth=a,e.getSouth=c,e.getEast=u,e.getWest=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(3);e.round=function(t){const{type:e}=t.params;if("hex"===e){const{i:e,j:n,k:r}=t;return function(t){const e=function(t){return Object.keys(t).reduce((e,n)=>{const r=t[n],s=i.decRemain(r);return e[n]=s,e},{})}(t),n=Object.keys(e).sort((t,n)=>e[n]-e[t]);let r=Object.values(e).reduce((t,e)=>t+e,0);return r=Math.round(r),n.reduce((e,n)=>(r>0?(e[n]=Math.ceil(t[n]),r-=1):e[n]=Math.floor(t[n]),e),{})}({i:e,j:n,k:r})}{const{i:e,j:n}=t;return function(t){return Object.keys(t).reduce((e,n)=>(e[n]=Math.round(t[n]),e),{})}({i:e,j:n})}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(14),r=n(5),s=n(39);class o extends r.GridPoint{get nearestPeaks(){return s.calcNearestPeaks(this).map(({i:t,j:e,k:n})=>{const i=new o(this.params,t,e,n).toGeo(),s=r.GridPoint.fromGeo(i,this.params);return new o(this.params,s.i,s.j,s.k)})}get nearestPeaksGeo(){return this.nearestPeaks.map(t=>t.toGeo())}static fromGeo(t,e){const{i:n,j:i,k:s}=r.GridPoint.fromGeo(t,e);return new o(e,n,i,s)}toFormatted(){const{params:t,i:e,j:n,k:i}=this;return new o(t,+e.toFixed(6),+n.toFixed(6),i&&+i.toFixed(6))}nearestNotSeparatedByPoly(t){const{nearestPeaks:e}=this;return e.reduce((e,n)=>{const r=i.CellSide.fromPeaks(this,n);return!t.intersectsSegment(r)&&e.push(n),e},[])}}e.PeakPoint=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(7),r=n(12),s=n(15);class o extends s.MercLine{static fromTwoGeoPoints(t,e){const n=t.isCloserThroughAntiMeridian(e);n&&(t=t.toOppositeHemisphere(),e=e.toOppositeHemisphere());const{a:i,b:r,c:a}=s.MercLine.fromTwoPoints(t.toMerc(),e.toMerc());return new o(i,r,a,n)}constructor(t,e,n,i){super(t,e,n),this.isAntiMeridian=i}lngByLat(t){const e=i.latToY(t),n=this.xByY(e);if(void 0===n)return;let s=r.xToLng(n);return this.isAntiMeridian&&(s=i.reduceLng(s-180)),s}latByLng(t){this.isAntiMeridian&&(t=i.reduceLng(t-180));const e=i.lngToX(t),n=this.yByX(e);if(void 0!==n)return r.yToLat(n)}}e.RhumbLine=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Vector=class{constructor(t,e){this.x=t,this.y=e}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(15),r=n(4),s=n(38);class o extends s.Segment{constructor(t,e){super(t,e),this.pointA=t,this.pointB=e,this.line=i.MercLine.fromTwoPoints(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new o(t,e)}intersectionPoint(t){if(!this.isAntiMeridian&&!t.isAntiMeridian){const e=super.intersectionPoint(t);return e&&new r.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere(),n=t.toOppositeHemisphere(),i=e.intersectionPoint(n);return i&&i.toOppositeHemisphere()}closestToPoint(t){if(!this.isAntiMeridian){const e=super.closestToPoint(t);return new r.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere();return t=t.toOppositeHemisphere(),e.closestToPoint(t).toOppositeHemisphere()}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallelToAxisX(){return this.line.isParallelToAxisX}get isParallelToAxisY(){return this.line.isParallelToAxisY}get easternPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}}e.MercSegment=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(16);e.Segment=class{constructor(t,e){this.pointA=t,this.pointB=e,this.line=i.Line.fromTwoPoints(t,e)}get minX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.min(t,e)}get maxX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.max(t,e)}get minY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.min(t,e)}get maxY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.max(t,e)}get minXPoint(){const{x:t}=this.pointA;return this.minX===t?this.pointA:this.pointB}get maxXPoint(){const{x:t}=this.pointA;return this.maxX===t?this.pointA:this.pointB}get minYPoint(){const{y:t}=this.pointA;return this.minY===t?this.pointA:this.pointB}get maxYPoint(){const{y:t}=this.pointA;return this.maxY===t?this.pointA:this.pointB}closestToPoint(t){const e=this.line.closestToPoint(t).toFormatted(),{x:n,y:i}=this.pointA.toFormatted(),{x:r,y:s}=this.pointB.toFormatted();return e.x<Math.min(n,r)?this.minXPoint:e.x>Math.max(n,r)?this.maxXPoint:e.y<Math.min(i,s)?this.minYPoint:e.y>Math.max(i,s)?this.maxYPoint:e}hasPoint(t){const{pointA:e,pointB:n}=this,{x:i,y:r}=t.toFormatted(),{x:s,y:o}=e.toFormatted(),{x:a,y:c}=n.toFormatted();return this.line.hasPoint(t)&&Math.max(s,a)>=i&&Math.min(s,a)<=i&&Math.max(o,c)>=r&&Math.min(o,c)<=r}intersectionPoint(t){if(this.line.a===t.line.a||this.line.b===t.line.b)return;const e=this.line.intersectionPoint(t.line);if(!e)return;let n,i;const r=Math.max(this.pointA.x,this.pointB.x),s=Math.min(this.pointA.x,this.pointB.x),o=Math.max(this.pointA.y,this.pointB.y),a=Math.min(this.pointA.y,this.pointB.y),c=Math.max(t.pointA.x,t.pointB.x),u=Math.min(t.pointA.x,t.pointB.x),h=Math.max(t.pointA.y,t.pointB.y),l=Math.min(t.pointA.y,t.pointB.y);return n=0===this.line.a?e.x<=r&&e.x>=s&&h>=o&&l<=a:0===this.line.b?e.y<=o&&e.y>=a&&c>=r&&u<=s:this.hasPoint(e),i=0===t.line.a?e.x<=c&&e.x>=u&&o>=h&&a<=l:0===t.line.b?e.y<=h&&e.y>=l&&r>=c&&s<=u:t.hasPoint(e),n&&i?e:void 0}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calcNearestPeaks=function(t){const{type:e}=t.params;return"hex"===e?function({i:t,j:e,k:n}){return 2===Math.round(t%1*3)?[{i:t+2/3,j:e-1/3,k:n-1/3},{i:t-1/3,j:e+2/3,k:n-1/3},{i:t-1/3,j:e-1/3,k:n+2/3}]:[{i:t-2/3,j:e+1/3,k:n+1/3},{i:t+1/3,j:e-2/3,k:n+1/3},{i:t+1/3,j:e+1/3,k:n-2/3}]}(t):function({i:t,j:e}){return[{i:t+1,j:e-1},{i:t+1,j:e+1},{i:t-1,j:e+1},{i:t-1,j:e-1}]}(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.GenericPolygon=class{constructor(t){this.points=t}intersectsPoly(t){return this.reduceSides((e,n,i)=>t.reduceSides((t,e,i)=>{const r=n.intersectionPoint(e);return r&&t.push(r),t},e),[])}intersectsSegment(t){return this.reduceSides((e,n)=>!!e||!!n.intersectionPoint(t),!1)}intersectsWithSegment(t){return this.reduceSides((e,n)=>{const i=n.intersectionPoint(t);return i&&e.push(i),e},[])}get selfIntersections(){return this.reduceOppositeSidesPairs((t,e,n)=>{const i=e.intersectionPoint(n);return i&&t.push(i),t},[])}sideByIndex(t){return{pointA:this.points[t],pointB:this.nextPointByIndex(t)}}sideByIndexInversed(t){return{pointA:this.points[t],pointB:this.prevPointByIndex(t)}}nextIndex(t){return t===this.points.length-1?0:t+1}prevIndex(t){const{length:e}=this.points;return 0===t?e-1:t-1}nextPointByIndex(t){const e=this.nextIndex(t);return this.points[e]}prevPointByIndex(t){const e=this.prevIndex(t);return this.points[e]}forEachSide(t){this.points.forEach((e,n)=>{const i=this.sideByIndex(n);t(i,n)})}mapSides(t){return this.points.map((e,n)=>{const i=this.sideByIndex(n);return t(i,n)})}reduceSides(t,e){return this.points.reduce((e,n,i)=>{const r=this.sideByIndex(i);return t(e,r,i)},e)}forEachSidesPair(t){this.forEachSide((e,n)=>{this.forEachSide((i,r)=>{r<=n||t(e,i)})})}reduceSidesPairs(t,e){return this.reduceSides((e,n,i)=>this.reduceSides((e,r,s)=>s<=i?e:t(e,n,r),e),e)}reduceNeighboringSidesPairs(t,e){return this.points.reduce((e,n,i)=>{const r=this.sideByIndexInversed(i),s=this.sideByIndex(i);return t(e,r,s)},e)}reduceOppositeSidesPairs(t,e){const n=this.points.length-1;return this.reduceSides((e,i,r)=>this.reduceSides((e,s,o)=>0===r&&o===n||o-1<=r?e:t(e,i,s),e),e)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.expand=function(t){const{type:e}=t.params;return"hex"===e?function({i:t,j:e,k:n}){return[{i:t-2/3,j:e+1/3,k:n+1/3},{i:t-1/3,j:e-1/3,k:n+2/3},{i:t+1/3,j:e-2/3,k:n+1/3},{i:t+2/3,j:e-1/3,k:n-1/3},{i:t+1/3,j:e+1/3,k:n-2/3},{i:t-1/3,j:e+2/3,k:n-1/3}]}(t):function({i:t,j:e}){return[{i:t+.5,j:e-.5},{i:t+.5,j:e+.5},{i:t-.5,j:e+.5},{i:t-.5,j:e-.5}]}(t)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getCommonPoints=function(t,e){const{params:n}=t.center;let i,r;if(t.center.isCloserThroughAntiMeridian(e.center)){const n=t.center.toOppositeHemishpere(),s=e.center.toOppositeHemishpere();i=s.i-n.i,r=s.j-n.j}else i=e.center.i-t.center.i,r=e.center.j-t.center.j;return("hex"===n.type?function(t,e){return 0===t&&0===e?[0,1,2,3,4,5]:1===t&&0===e?[3,4]:-1===t&&0===e?[0,1]:0===t&&1===e?[4,5]:0===t&&-1===e?[1,2]:-1===t&&1===e?[5,0]:1===t&&-1===e?[2,3]:[]}(i,r):function(t,e){return 0===t&&0===e?[0,1,2,3]:1===t&&0===e?[0,1]:-1===t&&0===e?[2,3]:0===t&&1===e?[1,2]:0===t&&-1===e?[3,0]:1===t&&1===e?[1]:-1===t&&1===e?[2]:-1===t&&-1===e?[3]:1===t&&-1===e?[0]:[]}(i,r)).map(e=>t.points[e])}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getIntersectedWithSegmentNeighbor=function(t,e){if(t.intersectsWithSegment(e).length>0)return t;const n=t.closestSideToSegment(e),i=t.nextCellBySide(n);return i.intersectsWithSegment(e).length>0?i:void 0}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),r=n(11),s=n(9),o=n(2),a=n(45),c=n(46),u=n(47);class h{constructor(t,e){this.payload=t,this.topLeft=e}get outerCoords(){const t=[],e=this.payload.length,n=this.payload[0].length,i=e-1,r=n-1;for(let e=0;e<n;e+=1)t.push([0,e]);for(let n=0;n<e;n+=1)t.push([n,r]);for(let e=0;e<n;e+=1)t.push([i,e]);for(let n=0;n<e;n+=1)t.push([n,0]);return t}get borderEmpties(){const{outerCoords:t}=this,{params:e}=this.topLeft;return t.reduce((t,[n,i])=>{if(this.payload[n][i])return t;if(t.some(([t,e])=>n===t&&i===e))return t;const r=u.getNearestEmpties(n,i,this.payload,e);return t.push(...r),t},[])}get innerEmpties(){const{borderEmpties:t,topLeft:{params:e}}=this;return this.payload.reduce((n,i,r)=>i.reduce((n,i,s)=>{if(this.payload[r][s])return n;if(t.some(([t,e])=>r===t&&s===e)||n.some(t=>t.some(([t,e])=>r===t&&s===e)))return n;const o=u.getNearestEmpties(r,s,this.payload,e);return n.push(o),n},n),[])}static fromCenters(t){const e=c.isOnAntiMeridian(t),n=a.buildMatrix(t,e),i=s.calcTopLeft(n);return new h(n,i)}removeEmptyLines(){const t=this.payload.filter(t=>!t.every(t=>!(t instanceof i.CenterPoint))),e=[];for(let n=0;n<t[0].length;n+=1){t.reduce((t,e)=>{if(!t)return t;return!(e[n]instanceof i.CenterPoint)},!0)&&e.push(n)}const n=t.map(t=>t.filter((t,n)=>!e.includes(n))),r=s.calcTopLeft(n);return new h(n,r)}filterBySet(t){const e=this.payload.map(e=>e.map(e=>e instanceof i.CenterPoint&&t.has(e)?e:void 0));return new h(e,this.topLeft).removeEmptyLines()}equivalentCenter(t,e){return this.topLeft.moveByDiff(t,e)}equivalentCell(t,e){const n=this.equivalentCenter(t,e);return r.Cell.fromCenter(n)}touchedCenters(t,e){return o.calcNearestAndTouchedIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&this.payload[t][e]instanceof i.CenterPoint)}nearestCenters(t,e){return o.calcNearestIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&this.payload[t][e]instanceof i.CenterPoint)}touchedEmpties(t,e){return o.calcNearestAndTouchedIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&!(this.payload[t][e]instanceof i.CenterPoint))}nearestEmpties(t,e){return o.calcNearestIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&!(this.payload[t][e]instanceof i.CenterPoint))}touchedInnerEmpties(t,e){return o.calcNearestAndTouchedIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&"inner"===this.payload[t][e])}nearestInnerEmpties(t,e){return o.calcNearestIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&"inner"===this.payload[t][e])}touchedOuterEmpties(t,e){return o.calcNearestAndTouchedIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&"outer"===this.payload[t][e])}nearestOuterEmpties(t,e){return o.calcNearestIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&"outer"===this.payload[t][e])}}e.CentersMatrix=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.buildMatrix=function(t,e){t=e?t.map(t=>t.toOppositeHemishpere()):[...t];const n=[...t].sort(({i:t},{i:e})=>t-e),i=[...t].sort(({j:t},{j:e})=>t-e),{i:r}=n[0],{i:s}=n[n.length-1],{j:o}=i[0],{j:a}=i[i.length-1],c=a-o,u=new Array(s-r+1).fill(void 0).map(()=>new Array(c+1).fill(void 0));return n.forEach(t=>{const n=t.i-r,i=t.j-o;u[n][i]=e?t.toOppositeHemishpere():t}),u}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isOnAntiMeridian=function(t){let e=t[0],n=t[0];return t.forEach(t=>{t.isEasternTo(e)&&(e=t),t.isWesternTo(n)&&(n=t)}),e.isCloserThroughAntiMeridian(n)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),r=n(2);e.getNearestEmpties=function t(e,n,s,o,a){return a||(a=[]),a.find(([t,i])=>e===t&&n===i)?a:(a.push([e,n]),r.calcNearestAndTouchedIndexes(e,n,o).filter(([t,e])=>{if(!s[t])return!1;if(e<0||e>=s[0].length)return!1;return!(s[t][e]instanceof i.CenterPoint)}).forEach(([e,n])=>{t(e,n,s,o,a)}),a)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(49);e.InnerCentersMatrix=i.InnerCentersMatrix},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(9),r=n(19),s=n(56);class o extends r.PolyMatrix{get startIndexes(){return this.startIndexesBy(t=>"inner"===t)}static fromCentersMatrix(t,e){const n=s.getInnerCentersMatrix(t,e),r=i.calcTopLeft(n);return new o(n,r).removeEmptyLines()}constructor(t,e){super(t,e),this.payload=t}touchedInnerIndexes(t,e){return this.touchedInnerEmpties(t,e)}touchedOuterIndexes(t,e){return this.touchedCenters(t,e)}toPoly(){return super.toPoly(!0).reverse()}removeEmptyLines(){const{payload:t,topLeft:e}=super.removeEmptyLines();return new o(t,e)}}e.InnerCentersMatrix=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(18),r=n(51),s=n(52),o=n(53),a=n(54),c=n(55);class u extends i.CentersMatrix{get startPoints(){return c.getStartPoints(this)}startIndexesBy(t){return a.getStartIndexesTouchedBy(this,t)}nextIndexes(t,e,n,i,r){return s.callNextIndexes(this,t,e,n,i,r)}nextPoints(t,e,n,i=!1){return o.getNextPoints(this,t,e,n,i)}toPoly(t){return r.buildPoly(this,t)}}e.PolyMatrix=u},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.buildPoly=function(t,e=!1){const[n,i]=t.startIndexes,r=t.startPoints;let[s,o]=t.nextIndexes(r,n,i),a=n,c=i;for(;s!==n||o!==i;){const n=t.nextPoints(r,s,o,e);r.push(...n);const[i,u]=t.nextIndexes(r,s,o,a,c);a=s,c=o,s=i,o=u}return r}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.callNextIndexes=function(t,e,n,i,r,s){const o=e[e.length-1];let a=t.touchedOuterIndexes(n,i).filter(([e,n])=>{return!!t.equivalentCell(e,n).findEqualGeoPoint(o)});if(a.length>1&&void 0!==r&&void 0!==s)a=a.filter(([t,e])=>t!==r||e!==s);else if(a.length>1)return a.sort(([,t],[,e])=>e-t)[0];return a.length>1&&a.filter(([t,e])=>t===n||e===i),a[0]}},function(t,e,n){"use strict";function i(t,e,n){return n?t.find(t=>!!n&&n.isNeighbor(t)):1===t.length?t[0]:t.find(t=>!!t.findEqualGeoPoint(e))}function r(t,e,n){return 1===t.length?t[0]:n?t.find(t=>!!n&&!n.isNeighbor(t)):t.find(t=>!!t.findEqualGeoPoint(e))}Object.defineProperty(e,"__esModule",{value:!0}),e.getNextPoints=function(t,e,n,s,o=!1){const a=t.equivalentCell(n,s),c=t.touchedInnerIndexes(n,s).map(([e,n])=>t.equivalentCell(e,n)),u=[];let h;for(;c.length>0;){const t=u[u.length-1]||e[e.length-1],n=c.filter(e=>!!e.findEqualGeoPoint(t)),s=u[u.length-2]||e[e.length-2],l=o?r(n,s,h):i(n,s,h);if(!l)break;const p=c.indexOf(l);if(-1===p)break;const d=l.commonPoints(a).filter(e=>!e.isEqual(t));u.push(...d),h=l,c.splice(p,1)}return u}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2);e.getStartIndexesTouchedBy=function(t,e){const{payload:n,topLeft:{params:r}}=t;return[0,n[0].reduce((t,s,o)=>{if(void 0!==t)return t;return i.calcNearestAndTouchedIndexes(0,o,r).reduce((t,[i,r])=>t||!!n[i]&&e(n[i][r]),!1)?o:t},void 0)]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getStartPoints=function(t){const{topLeft:{params:{isHorizontal:e}},startIndexes:[n,i]}=t,r=[],s=t.touchedInnerIndexes(n,i);s.sort(([t,e],[n,i])=>n-t||e-i);const o=t.equivalentCell(n,i),a=o.center.moveByDiff(-1,-1),c=o.center.isNorthernTo(a),u=o.center.isEasternTo(a);return s.map(([n,i])=>{return t.equivalentCell(n,i).commonPoints(o).sort((t,n)=>{return!e&&t.lng!==n.lng||e&&t.lat===n.lat?t.isEasternTo(n)===u?1:-1:t.isNorthernTo(n)===c?1:-1})}).reduce((t,e)=>(t.push(...e),t),[]).forEach(t=>{const e=r[r.length-1];e&&e.isEqual(t)||r.push(t)}),r}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2);e.getInnerCentersMatrix=function(t,e){const{payload:n,topLeft:{params:r}}=t;return n.map((t,s)=>t.map((t,o)=>{if(!t&&e.some(([t,e])=>s===t&&o===e))return"inner";if(!t)return t;return i.calcNearestAndTouchedIndexes(s,o,r).filter(([t,e])=>!!n[t]&&(!(e<0||e>=n[0].length)&&!n[t][e])).some(([t,n])=>e.some(([e,i])=>t===e&&n===i))?t:void 0}))}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(58);e.OuterCentersMatrix=i.OuterCentersMatrix},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),r=n(9),s=n(19),o=n(59);class a extends s.PolyMatrix{get startIndexes(){return this.startIndexesBy(t=>t instanceof i.CenterPoint)}static fromCentersMatrix(t){const e=o.getOuterCentersMatrix(t),n=r.calcTopLeft(e);return new a(e,n)}constructor(t,e){super(t,e),this.payload=t}touchedInnerIndexes(t,e){return this.touchedCenters(t,e)}touchedOuterIndexes(t,e){return this.touchedOuterEmpties(t,e)}toPoly(){return super.toPoly()}removeEmptyLines(){const{payload:t,topLeft:e}=super.removeEmptyLines();return new a(t,e)}}e.OuterCentersMatrix=a},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(2);e.getOuterCentersMatrix=function(t){const{payload:e,borderEmpties:n,topLeft:{params:r}}=t,s=e.length-1,o=e[0].length-1,a=e.map((t,a)=>t.map((t,c)=>{if(!t&&n.some(([t,e])=>a===t&&c===e))return"outer";if(!t)return t;if(a===s||c===o||0===a||0===c)return t;return i.calcNearestAndTouchedIndexes(a,c,r).filter(([t,n])=>!!e[t]&&(!(n<0||n>=e[0].length)&&!e[t][n])).some(([t,e])=>n.some(([n,i])=>t===n&&e===i))?t:void 0}));a.forEach(t=>{t.unshift("outer"),t.push("outer")});const c=a[0].length;return a.unshift(new Array(c).fill("outer")),a.push(new Array(c).fill("outer")),a}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),r=n(2);function s(t,e,n,o){o||(o=new Set);const{payload:a}=n,c=a[t]&&a[t][e];return c instanceof i.CenterPoint?o.has(c)?o:(o.add(c),r.calcNearestIndexes(t,e,c.params).forEach(([t,e])=>{s(t,e,n,o)}),o):o}e.unionNearestCenters=s,e.getBiggestSet=function(t){return t.payload.reduce((e,n,r)=>n.reduce((e,n,o)=>{if(!(n instanceof i.CenterPoint))return e;if(e.some(t=>t.has(n)))return e;const a=s(r,o,t);return e.push(a),e},e),[]).sort((t,e)=>e.size-t.size)[0]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.CtxService=class{constructor(t){this.worker=t,this.handleMessage=t=>{"terminate"!==t.data?this.messageHandler&&this.messageHandler(t):this.close()},this.handleError=t=>{this.errorHandler&&this.errorHandler(t)},this.worker.addEventListener("message",this.handleMessage),this.worker.addEventListener("error",this.handleError)}post(t){this.worker.postMessage(t)}onMessage(t){this.messageHandler=t}onError(t){this.errorHandler=t}close(){this.unmount(),close()}unmount(){this.worker.removeEventListener("message",this.handleMessage),this.worker.removeEventListener("error",this.handleError)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(0);e.CenterPoint=i.CenterPoint;var r=n(5);e.GridPoint=r.GridPoint;var s=n(1);e.GeoPoint=s.GeoPoint;var o=n(4);e.MercPoint=o.MercPoint;var a=n(13);e.PeakPoint=a.PeakPoint;var c=n(6);e.Point=c.Point;var u=n(63);e.TileMercPoint=u.TileMercPoint},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(10),r=n(64),s=n(8),o=n(0),a=n(1),c=n(4),u=n(6);class h extends c.MercPoint{get zoomCoofX(){return 2**this.zoom*i.constants.googleTileSize/this.tileWidth}get zoomCoofY(){return 2**this.zoom*i.constants.googleTileSize/this.tileHeight}get northTile(){const{tileX:t,tileY:e,tileHeight:n,tileWidth:i,zoom:r}=this;return h.fromTile(t,e-1,i,n,r)}get southTile(){const{tileX:t,tileY:e,tileHeight:n,tileWidth:i,zoom:r}=this;return h.fromTile(t,e+1,i,n,r)}get eastTile(){const{tileX:t,tileY:e,tileHeight:n,tileWidth:i,zoom:r}=this;return h.fromTile(t+1,e,i,n,r)}get westTile(){const{tileX:t,tileY:e,tileHeight:n,tileWidth:i,zoom:r}=this;return h.fromTile(t-1,e,i,n,r)}get northBound(){return a.GeoPoint.fromMerc(this).lat}get southBound(){return a.GeoPoint.fromMerc(this.southTile).lat}get eastBound(){return a.GeoPoint.fromMerc(this.eastTile).lng}get westBound(){return a.GeoPoint.fromMerc(this).lng}get north(){return new s.GeoSegment(a.GeoPoint.fromMerc(this),a.GeoPoint.fromMerc(this.eastTile))}get south(){const t=this.southTile;return new s.GeoSegment(a.GeoPoint.fromMerc(t.eastTile),a.GeoPoint.fromMerc(t))}get east(){const t=this.eastTile;return new s.GeoSegment(a.GeoPoint.fromMerc(t),a.GeoPoint.fromMerc(t.southTile))}get west(){return new s.GeoSegment(a.GeoPoint.fromMerc(this.southTile),a.GeoPoint.fromMerc(this))}static fromTile(t,e,n,r,s){const o=t/(2**s*(i.constants.googleTileSize/n)),a=e/(2**s*(i.constants.googleTileSize/r));return new h(o,a,t,e,n,r,s)}static fromPlain({x:t,y:e,tileX:n,tileY:i,tileWidth:r,tileHeight:s,zoom:o}){return new h(t,e,n,i,r,s,o)}static fromMerc(t,e,n,r){const s=t.x*(2**r*(i.constants.googleTileSize/e)),o=t.y*(2**r*(i.constants.googleTileSize/n));return new h(t.x,t.y,s,o,e,n,r)}constructor(t,e,n,i,r,s,o){super(t,e),this.tileX=n,this.tileY=i,this.tileWidth=r,this.tileHeight=s,this.zoom=o}gridPatternStartPoint(t){const e=a.GeoPoint.fromMerc(this),n=o.CenterPoint.fromGeo(e,t),{northWest:i}=n.northWestNeighbors,r=i.toGeo().toMerc(),s=h.fromMerc(r,this.tileWidth,this.tileHeight,this.zoom);return this.startPointDiff(s)}startPointDiff(t){let e=t.tileX-this.tileX;const n=t.tileY-this.tileY;return e>this.tileX&&(e-=Math.ceil(e)),new u.Point(e,n)}toPoly(){const t=this.eastTile;return new r.GeoPolygon([a.GeoPoint.fromMerc(this),a.GeoPoint.fromMerc(t),a.GeoPoint.fromMerc(t.southTile),a.GeoPoint.fromMerc(this.southTile)])}containsPoint({lat:t,lng:e}){return t<=this.northBound&&t>=this.southBound&&e<=this.eastBound&&e>=this.westBound}projectGeoPoints(t){return t.map(t=>{const e=t.toMerc(),{tileX:n,tileY:i}=h.fromMerc(e,this.tileWidth,this.tileHeight,this.zoom),r=Math.round((n-this.tileX)*this.tileWidth),s=Math.round((i-this.tileY)*this.tileHeight);return new u.Point(r,s)})}toPlain(){return{x:this.x,y:this.y,tileX:this.tileX,tileY:this.tileY,zoom:this.zoom,tileHeight:this.tileHeight,tileWidth:this.tileWidth}}}e.TileMercPoint=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(17);e.GeoPolygon=i.GeoPolygon}]);',null)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(3),s=n(28),o=n(74),r=n(83),a=n(86);e.buildArea=function(t){if(0===t.length)return[[]];if(1===t.length)return[i.Cell.fromCenter(t[0]).points];const e=s.CentersMatrix.fromCenters(t),n=a.getBiggestSet(e),c=e.filterBySet(n),{innerEmpties:u}=c,h=r.OuterCentersMatrix.fromCentersMatrix(c),l=u.map(t=>o.InnerCentersMatrix.fromCentersMatrix(c,t));return[h.toPoly(),...l.map(t=>t.toPoly())]},e.pickBiggestSet=function(t){if(0===t.length)return[];const e=s.CentersMatrix.fromCenters(t);return[...a.getBiggestSet(e)]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),s=n(3),o=n(21),r=n(4),a=n(71),c=n(72),u=n(73);class h{constructor(t,e){this.payload=t,this.topLeft=e}get outerCoords(){const t=[],e=this.payload.length,n=this.payload[0].length,i=e-1,s=n-1;for(let e=0;e<n;e+=1)t.push([0,e]);for(let n=0;n<e;n+=1)t.push([n,s]);for(let e=0;e<n;e+=1)t.push([i,e]);for(let n=0;n<e;n+=1)t.push([n,0]);return t}get borderEmpties(){const{outerCoords:t}=this,{params:e}=this.topLeft;return t.reduce((t,[n,i])=>{if(this.payload[n][i])return t;if(t.some(([t,e])=>n===t&&i===e))return t;const s=u.getNearestEmpties(n,i,this.payload,e);return t.push(...s),t},[])}get innerEmpties(){const{borderEmpties:t,topLeft:{params:e}}=this;return this.payload.reduce((n,i,s)=>i.reduce((n,i,o)=>{if(this.payload[s][o])return n;if(t.some(([t,e])=>s===t&&o===e)||n.some(t=>t.some(([t,e])=>s===t&&o===e)))return n;const r=u.getNearestEmpties(s,o,this.payload,e);return n.push(r),n},n),[])}static fromCenters(t){const e=c.isOnAntiMeridian(t),n=a.buildMatrix(t,e),i=o.calcTopLeft(n);return new h(n,i)}removeEmptyLines(){const t=this.payload.filter(t=>!t.every(t=>!(t instanceof i.CenterPoint))),e=[];for(let n=0;n<t[0].length;n+=1){t.reduce((t,e)=>{if(!t)return t;return!(e[n]instanceof i.CenterPoint)},!0)&&e.push(n)}const n=t.map(t=>t.filter((t,n)=>!e.includes(n))),s=o.calcTopLeft(n);return new h(n,s)}filterBySet(t){const e=this.payload.map(e=>e.map(e=>e instanceof i.CenterPoint&&t.has(e)?e:void 0));return new h(e,this.topLeft).removeEmptyLines()}equivalentCenter(t,e){return this.topLeft.moveByDiff(t,e)}equivalentCell(t,e){const n=this.equivalentCenter(t,e);return s.Cell.fromCenter(n)}touchedCenters(t,e){return r.calcNearestAndTouchedIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&this.payload[t][e]instanceof i.CenterPoint)}nearestCenters(t,e){return r.calcNearestIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&this.payload[t][e]instanceof i.CenterPoint)}touchedEmpties(t,e){return r.calcNearestAndTouchedIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&!(this.payload[t][e]instanceof i.CenterPoint))}nearestEmpties(t,e){return r.calcNearestIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&!(this.payload[t][e]instanceof i.CenterPoint))}touchedInnerEmpties(t,e){return r.calcNearestAndTouchedIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&"inner"===this.payload[t][e])}nearestInnerEmpties(t,e){return r.calcNearestIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&"inner"===this.payload[t][e])}touchedOuterEmpties(t,e){return r.calcNearestAndTouchedIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&"outer"===this.payload[t][e])}nearestOuterEmpties(t,e){return r.calcNearestIndexes(t,e,this.topLeft.params).filter(([t,e])=>this.payload[t]&&"outer"===this.payload[t][e])}}e.CentersMatrix=h},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.buildMatrix=function(t,e){t=e?t.map(t=>t.toOppositeHemishpere()):[...t];const n=[...t].sort(({i:t},{i:e})=>t-e),i=[...t].sort(({j:t},{j:e})=>t-e),{i:s}=n[0],{i:o}=n[n.length-1],{j:r}=i[0],{j:a}=i[i.length-1],c=a-r,u=new Array(o-s+1).fill(void 0).map(()=>new Array(c+1).fill(void 0));return n.forEach(t=>{const n=t.i-s,i=t.j-r;u[n][i]=e?t.toOppositeHemishpere():t}),u}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isOnAntiMeridian=function(t){let e=t[0],n=t[0];return t.forEach(t=>{t.isEasternTo(e)&&(e=t),t.isWesternTo(n)&&(n=t)}),e.isCloserThroughAntiMeridian(n)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),s=n(4);e.getNearestEmpties=function t(e,n,o,r,a){return a||(a=[]),a.find(([t,i])=>e===t&&n===i)?a:(a.push([e,n]),s.calcNearestAndTouchedIndexes(e,n,r).filter(([t,e])=>{if(!o[t])return!1;if(e<0||e>=o[0].length)return!1;return!(o[t][e]instanceof i.CenterPoint)}).forEach(([e,n])=>{t(e,n,o,r,a)}),a)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(75);e.InnerCentersMatrix=i.InnerCentersMatrix},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(21),s=n(29),o=n(82);class r extends s.PolyMatrix{get startIndexes(){return this.startIndexesBy(t=>"inner"===t)}static fromCentersMatrix(t,e){const n=o.getInnerCentersMatrix(t,e),s=i.calcTopLeft(n);return new r(n,s).removeEmptyLines()}constructor(t,e){super(t,e),this.payload=t}touchedInnerIndexes(t,e){return this.touchedInnerEmpties(t,e)}touchedOuterIndexes(t,e){return this.touchedCenters(t,e)}toPoly(){return super.toPoly(!0).reverse()}removeEmptyLines(){const{payload:t,topLeft:e}=super.removeEmptyLines();return new r(t,e)}}e.InnerCentersMatrix=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(28),s=n(77),o=n(78),r=n(79),a=n(80),c=n(81);class u extends i.CentersMatrix{get startPoints(){return c.getStartPoints(this)}startIndexesBy(t){return a.getStartIndexesTouchedBy(this,t)}nextIndexes(t,e,n,i,s){return o.callNextIndexes(this,t,e,n,i,s)}nextPoints(t,e,n,i=!1){return r.getNextPoints(this,t,e,n,i)}toPoly(t){return s.buildPoly(this,t)}}e.PolyMatrix=u},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.buildPoly=function(t,e=!1){const[n,i]=t.startIndexes,s=t.startPoints;let[o,r]=t.nextIndexes(s,n,i),a=n,c=i;for(;o!==n||r!==i;){const n=t.nextPoints(s,o,r,e);s.push(...n);const[i,u]=t.nextIndexes(s,o,r,a,c);a=o,c=r,o=i,r=u}return s}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.callNextIndexes=function(t,e,n,i,s,o){const r=e[e.length-1];let a=t.touchedOuterIndexes(n,i).filter(([e,n])=>{return!!t.equivalentCell(e,n).findEqualGeoPoint(r)});if(a.length>1&&void 0!==s&&void 0!==o)a=a.filter(([t,e])=>t!==s||e!==o);else if(a.length>1)return a.sort(([,t],[,e])=>e-t)[0];return a.length>1&&a.filter(([t,e])=>t===n||e===i),a[0]}},function(t,e,n){"use strict";function i(t,e,n){return n?t.find(t=>!!n&&n.isNeighbor(t)):1===t.length?t[0]:t.find(t=>!!t.findEqualGeoPoint(e))}function s(t,e,n){return 1===t.length?t[0]:n?t.find(t=>!!n&&!n.isNeighbor(t)):t.find(t=>!!t.findEqualGeoPoint(e))}Object.defineProperty(e,"__esModule",{value:!0}),e.getNextPoints=function(t,e,n,o,r=!1){const a=t.equivalentCell(n,o),c=t.touchedInnerIndexes(n,o).map(([e,n])=>t.equivalentCell(e,n)),u=[];let h;for(;c.length>0;){const t=u[u.length-1]||e[e.length-1],n=c.filter(e=>!!e.findEqualGeoPoint(t)),o=u[u.length-2]||e[e.length-2],l=r?s(n,o,h):i(n,o,h);if(!l)break;const p=c.indexOf(l);if(-1===p)break;const d=l.commonPoints(a).filter(e=>!e.isEqual(t));u.push(...d),h=l,c.splice(p,1)}return u}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(4);e.getStartIndexesTouchedBy=function(t,e){const{payload:n,topLeft:{params:s}}=t;return[0,n[0].reduce((t,o,r)=>{if(void 0!==t)return t;return i.calcNearestAndTouchedIndexes(0,r,s).reduce((t,[i,s])=>t||!!n[i]&&e(n[i][s]),!1)?r:t},void 0)]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getStartPoints=function(t){const{topLeft:{params:{isHorizontal:e}},startIndexes:[n,i]}=t,s=[],o=t.touchedInnerIndexes(n,i);o.sort(([t,e],[n,i])=>n-t||e-i);const r=t.equivalentCell(n,i),a=r.center.moveByDiff(-1,-1),c=r.center.isNorthernTo(a),u=r.center.isEasternTo(a);return o.map(([n,i])=>{return t.equivalentCell(n,i).commonPoints(r).sort((t,n)=>{return!e&&t.lng!==n.lng||e&&t.lat===n.lat?t.isEasternTo(n)===u?1:-1:t.isNorthernTo(n)===c?1:-1})}).reduce((t,e)=>(t.push(...e),t),[]).forEach(t=>{const e=s[s.length-1];e&&e.isEqual(t)||s.push(t)}),s}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(4);e.getInnerCentersMatrix=function(t,e){const{payload:n,topLeft:{params:s}}=t;return n.map((t,o)=>t.map((t,r)=>{if(!t&&e.some(([t,e])=>o===t&&r===e))return"inner";if(!t)return t;return i.calcNearestAndTouchedIndexes(o,r,s).filter(([t,e])=>!!n[t]&&(!(e<0||e>=n[0].length)&&!n[t][e])).some(([t,n])=>e.some(([e,i])=>t===e&&n===i))?t:void 0}))}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(84);e.OuterCentersMatrix=i.OuterCentersMatrix},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),s=n(21),o=n(29),r=n(85);class a extends o.PolyMatrix{get startIndexes(){return this.startIndexesBy(t=>t instanceof i.CenterPoint)}static fromCentersMatrix(t){const e=r.getOuterCentersMatrix(t),n=s.calcTopLeft(e);return new a(e,n)}constructor(t,e){super(t,e),this.payload=t}touchedInnerIndexes(t,e){return this.touchedCenters(t,e)}touchedOuterIndexes(t,e){return this.touchedOuterEmpties(t,e)}toPoly(){return super.toPoly()}removeEmptyLines(){const{payload:t,topLeft:e}=super.removeEmptyLines();return new a(t,e)}}e.OuterCentersMatrix=a},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(4);e.getOuterCentersMatrix=function(t){const{payload:e,borderEmpties:n,topLeft:{params:s}}=t,o=e.length-1,r=e[0].length-1,a=e.map((t,a)=>t.map((t,c)=>{if(!t&&n.some(([t,e])=>a===t&&c===e))return"outer";if(!t)return t;if(a===o||c===r||0===a||0===c)return t;return i.calcNearestAndTouchedIndexes(a,c,s).filter(([t,n])=>!!e[t]&&(!(n<0||n>=e[0].length)&&!e[t][n])).some(([t,e])=>n.some(([n,i])=>t===n&&e===i))?t:void 0}));a.forEach(t=>{t.unshift("outer"),t.push("outer")});const c=a[0].length;return a.unshift(new Array(c).fill("outer")),a.push(new Array(c).fill("outer")),a}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),s=n(4);function o(t,e,n,r){r||(r=new Set);const{payload:a}=n,c=a[t]&&a[t][e];return c instanceof i.CenterPoint?r.has(c)?r:(r.add(c),s.calcNearestIndexes(t,e,c.params).forEach(([t,e])=>{o(t,e,n,r)}),r):r}e.unionNearestCenters=o,e.getBiggestSet=function(t){return t.payload.reduce((e,n,s)=>n.reduce((e,n,r)=>{if(!(n instanceof i.CenterPoint))return e;if(e.some(t=>t.has(n)))return e;const a=o(s,r,t);return e.push(a),e},e),[]).sort((t,e)=>e.size-t.size)[0]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(31);e.GridPattern=i.GridPattern;var s=n(89);e.GridTile=s.GridTile;var o=n(90);e.MapGridTile=o.MapGridTile},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(0),s=n(7),o=n(2),r=n(10);e.expandTile=function(t,e,n,a,c){const{northWestNeighbors:{northWest:u}}=i.CenterPoint.fromGeo(t,c);let h;return h="hex"===c.type?function(t){const{i:e,j:n,params:i}=t,s=t.k;return i.isHorizontal?[[{i:e,j:n-.5,k:s+.5},{i:e+1/3,j:n-2/3,k:s+1/3},{i:e+2/3,j:n-1/3,k:s-1/3},{i:e+4/3,j:n-2/3,k:s-2/3},{i:e+5/3,j:n-4/3,k:s-1/3},{i:e+2,j:n-1.5,k:s-.5}],[{i:e+1/3,j:n-2/3,k:s+1/3},{i:e+2/3,j:n-4/3,k:s+2/3},{i:e+4/3,j:n-5/3,k:s+1/3},{i:e+5/3,j:n-4/3,k:s-1/3}]]:[[{i:e,j:n+.5,k:s-.5},{i:e-1/3,j:n+2/3,k:s-1/3},{i:e-2/3,j:n+1/3,k:s+1/3},{i:e-4/3,j:n+2/3,k:s+2/3},{i:e-5/3,j:n+4/3,k:s+1/3},{i:e-2,j:n+1.5,k:s+.5}],[{i:e-1/3,j:n+2/3,k:s-1/3},{i:e-2/3,j:n+4/3,k:s-2/3},{i:e-4/3,j:n+5/3,k:s-1/3},{i:e-5/3,j:n+4/3,k:s+1/3}]]}(u):function({i:t,j:e,params:n}){return n.isHorizontal?[[{i:t,j:e-.5},{i:t+2,j:e-.5}],[{i:t+.5,j:e},{i:t+.5,j:e-2}],[{i:t+1.5,j:e},{i:t+1.5,j:e-2}],[{i:t,j:e-1.5},{i:t+2,j:e-1.5}]]:[[{i:t-.5,j:e},{i:t-.5,j:e+2}],[{i:t,j:e+.5},{i:t-2,j:e+.5}],[{i:t-1.5,j:e},{i:t-1.5,j:e+2}],[{i:t,j:e+1.5},{i:t-2,j:e+1.5}]]}(u),h.map(t=>t.map(({i:t,j:i,k:u})=>{const h=new s.GridPoint(c,t,i,u).toGeo().toMerc(),l=r.TileMercPoint.fromMerc(h,e.tileWidth,e.tileHeight,e.zoom);let p=l.tileX-e.tileX;if(p>1){const t=Math.abs(Math.ceil(l.tileX)-(l.tileX-e.tileX));p=Math.min(p,t)}const d=p/n,m=(l.tileY-e.tileY)/a;return new o.Point(d,m)}))}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(32);e.GridTile=i.GridTile},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(91);e.MapGridTile=i.MapGridTile},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(10),s=n(31),o=n(1),r=n(92);class a{constructor(t,e,n){this.tilePoint=t,this.patterns=e,this.params=n}get northWest(){return o.GeoPoint.fromMerc(this.tilePoint)}get southWest(){return o.GeoPoint.fromMerc(this.tilePoint.southTile)}get northEast(){return o.GeoPoint.fromMerc(this.tilePoint.eastTile)}get southEast(){return o.GeoPoint.fromMerc(this.tilePoint.southTile.eastTile)}get north(){return this.northWest.lat}get west(){return this.northWest.lng}get south(){return this.southWest.lat}get east(){return this.northEast.lng}static fromTileCoords({x:t,y:e},n,s,o,r){const c=i.TileMercPoint.fromTile(t,e,o,r,s);return a.fromTilePoint(c,n)}static async fromTilePoint(t,e){a.worker||(a.worker=new r.PatternWorker),await a.worker.postParams(e);const n=await a.worker.buildTile(t);return a.fromPlain(n,e)}toPlain(){return{patterns:this.patterns.map(t=>t.toPlain()),tilePoint:this.tilePoint.toPlain()}}static fromPlain({tilePoint:t,patterns:e},n){const o=i.TileMercPoint.fromPlain(t);return new a(o,e.map(t=>s.GridPattern.fromPlain(t,o,n)),n)}}e.MapGridTile=a},function(t,e,n){"use strict";var i=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const s=n(13),o=i(n(93));e.PatternWorker=class{constructor(){this.worker=new s.WorkerService(new o.default)}terminate(){this.worker.terminate()}async postParams(t){await this.worker.post({type:"params",payload:{params:t.toPlain()}})}async buildTile(t){const{data:e}=await this.worker.post({type:"grid-tile",payload:{tilePoint:t.toPlain()}});return e.mapTile}}},function(t,e,n){t.exports=function(){return n(14)('!function(t){var e={};function i(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,i),o.l=!0,o.exports}i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)i.d(n,o,function(e){return t[e]}.bind(null,o));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=13)}([function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class n{constructor(t,e){this.x=t,this.y=e}distanceToPoint({x:t,y:e}){return Math.sqrt(Math.pow(t-this.x,2)+Math.pow(e-this.y,2))}toFormatted(){return this}toPlain(){return{x:this.x,y:this.y}}static fromPlain({x:t,y:e}){return new n(t,e)}containedByLine(t){return t.hasPoint(this)}containedBySegment(t){return t.hasPoint(this)}isEqual(t){const e=this.toFormatted(),i=t.toFormatted();return e.x===i.x&&e.y===i.y}distanceToLine(t){return t.distanceToPoint(this)}closestOnLine(t){return t.closestToPoint(this)}closestOnSegment(t){return t.closestToPoint(this)}}e.Point=n},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(6),o=i(4);class s{constructor(t,e){this.lat=t,this.lng=e}static createFormatted(t,e){return t=n.formatLat(t),e=n.formatLng(e),new s(t,e)}static fromUnsafeCoords(t,e){return t=n.reduceLat(t),e=n.reduceLng(e),new s(t,e)}static fromMerc(t){const{lat:e,lng:i}=t.toSphereLiteral();return new s(e,i)}isEqual(t){const e=this.toFormatted(),i=t.toFormatted();return e.lat===i.lat&&e.lng===i.lng}isCloserThroughAntiMeridian(t){const e=Math.min(this.lng,t.lng);return Math.max(this.lng,t.lng)-e>180}toOppositeHemisphere(){const t=n.reduceLng(this.lng-180);return new s(this.lat,t)}calcMercDistance(t){let e=this;this.isCloserThroughAntiMeridian(t)&&(e=this.toOppositeHemisphere(),t=t.toOppositeHemisphere());const i=e.toMerc(),n=t.toMerc();return i.distanceToPoint(n)}toMerc(){const t=n.lngToX(this.lng),e=n.latToY(this.lat);return new o.MercPoint(t,e)}toSemiSphere(){const{lat:t,lng:e}=this.toMerc().toSemiSphereLiteral();return new s(t,e)}fromSemiSphere(){const t=n.semiLngToX(this.lng),e=n.semiLatToY(this.lat),{lat:i,lng:r}=new o.MercPoint(t,e).toSphereLiteral();return new s(i,r)}toFormatted(){const t=n.formatLat(this.lat),e=n.formatLng(this.lng);return new s(t,e)}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng<t.lng:this.lng>t.lng}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.lng>t.lng:this.lng<t.lng}isNorthernTo(t){return this.lat>t.lat}isSouthernTo(t){return this.lat<t.lat}toPlain(){const{lat:t,lng:e}=this;return{lat:t,lng:e}}toGeoJSON(){return{type:"Point",coordinates:[this.lng,this.lat]}}static fromPlain({lat:t,lng:e}){return new s(t,e)}static fromGeoJSON({coordinates:[t,e]}){return s.fromPlain({lat:e,lng:t})}}e.GeoPoint=s},function(t,e,i){"use strict";function n(t){return t*Math.PI/180}Object.defineProperty(e,"__esModule",{value:!0}),e.floorNumStrByOrder=function(t){const e=t.length;if(t.split("").every(t=>"0"===t))return t;if(t.lastIndexOf(".")===e-2)return Math.floor(+t)+"";if(-1!==t.indexOf("."))return t.slice(0,-1);if(-1===t.indexOf("0"))return t.slice(0,-1)+"0";{const i=t.lastIndexOf("0");return t.slice(0,i-1)+"0".repeat(e-i+1)}},e.calcClosestMultiple=function(t,e){let i=t,n=t;for(;e%i!=0&&e%n!=0;)i+=1,n-=1;return e%i==0?i:n},e.cosDeg=function(t){const e=n(t);return Math.cos(e)},e.sinDeg=function(t){const e=n(t);return Math.sin(e)},e.findPrimeFactors=function(t){if(t<2)return[];let e=t,i=2;const n=[];for(;i*i<=e;)e%i==0?(n.push(i),e/=i):i+=1;return 1!==e&&n.push(e),n},e.degToRad=n,e.radToDeg=function(t){return 180*t/Math.PI},e.decRemain=function(t){return t-Math.floor(t)}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(21);e.GridPoint=n.GridPoint},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0),o=i(10);class s extends n.Point{constructor(t,e){super(t=o.reduceX(t),e)}toFormatted(){return new s(+this.x.toFixed(10),+this.y.toFixed(10))}toOppositeHemisphere(){const t=o.reduceX(this.x-.5);return new s(t,this.y)}calcMercDistance(t){return(this.isCloserThroughAntiMeridian(t)?this.toOppositeHemisphere():this).distanceToPoint(t)}isCloserThroughAntiMeridian(t){const e=Math.min(this.x,t.x);return Math.max(this.x,t.x)-e>1}toSphereLiteral(){return{lat:o.yToLat(this.y),lng:o.xToLng(this.x)}}toSemiSphereLiteral(){return{lat:o.yToSemiLat(this.y),lng:o.xToSemiLng(this.x)}}isEasternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x<t.x:this.x>t.x}isWesternTo(t){return this.isCloserThroughAntiMeridian(t)?this.x>t.x:this.x<t.x}isNorthernTo(t){return this.y>t.y}isSouthernTo(t){return this.y<t.y}}e.MercPoint=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(20);e.CenterPoint=n.CenterPoint},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(2);function o(t){return(t>360||t<-360)&&(t%=360),t>=180?t-360:t<-180?t+360:t}e.semiLatToY=function(t){return-t/180+.5},e.semiLngToX=function(t){return t/360+.5},e.latToY=function(t){return(-Math.log(Math.tan(Math.PI/4+n.degToRad(t)/2))/Math.PI+1)/2},e.lngToX=function(t){return(n.degToRad(t)/Math.PI+1)/2},e.formatLat=function(t){return t>90&&(t=90),t<-90&&(t=-90),+t.toFixed(7)},e.formatLng=function(t){return+(t=o(t)).toFixed(7)},e.reduceLat=function(t){return(t>360||t<-360)&&(t%=360),t>90?180-t:t<-90?-180+t:t},e.reduceLng=o},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(9),o=i(28),s=i(8),r=i(5),a=i(1),c=i(4),h=i(0);class u extends c.MercPoint{get zoomCoofX(){return 2**this.zoom*n.constants.googleTileSize/this.tileWidth}get zoomCoofY(){return 2**this.zoom*n.constants.googleTileSize/this.tileHeight}get northTile(){const{tileX:t,tileY:e,tileHeight:i,tileWidth:n,zoom:o}=this;return u.fromTile(t,e-1,n,i,o)}get southTile(){const{tileX:t,tileY:e,tileHeight:i,tileWidth:n,zoom:o}=this;return u.fromTile(t,e+1,n,i,o)}get eastTile(){const{tileX:t,tileY:e,tileHeight:i,tileWidth:n,zoom:o}=this;return u.fromTile(t+1,e,n,i,o)}get westTile(){const{tileX:t,tileY:e,tileHeight:i,tileWidth:n,zoom:o}=this;return u.fromTile(t-1,e,n,i,o)}get northBound(){return a.GeoPoint.fromMerc(this).lat}get southBound(){return a.GeoPoint.fromMerc(this.southTile).lat}get eastBound(){return a.GeoPoint.fromMerc(this.eastTile).lng}get westBound(){return a.GeoPoint.fromMerc(this).lng}get north(){return new s.GeoSegment(a.GeoPoint.fromMerc(this),a.GeoPoint.fromMerc(this.eastTile))}get south(){const t=this.southTile;return new s.GeoSegment(a.GeoPoint.fromMerc(t.eastTile),a.GeoPoint.fromMerc(t))}get east(){const t=this.eastTile;return new s.GeoSegment(a.GeoPoint.fromMerc(t),a.GeoPoint.fromMerc(t.southTile))}get west(){return new s.GeoSegment(a.GeoPoint.fromMerc(this.southTile),a.GeoPoint.fromMerc(this))}static fromTile(t,e,i,o,s){const r=t/(2**s*(n.constants.googleTileSize/i)),a=e/(2**s*(n.constants.googleTileSize/o));return new u(r,a,t,e,i,o,s)}static fromPlain({x:t,y:e,tileX:i,tileY:n,tileWidth:o,tileHeight:s,zoom:r}){return new u(t,e,i,n,o,s,r)}static fromMerc(t,e,i,o){const s=t.x*(2**o*(n.constants.googleTileSize/e)),r=t.y*(2**o*(n.constants.googleTileSize/i));return new u(t.x,t.y,s,r,e,i,o)}constructor(t,e,i,n,o,s,r){super(t,e),this.tileX=i,this.tileY=n,this.tileWidth=o,this.tileHeight=s,this.zoom=r}gridPatternStartPoint(t){const e=a.GeoPoint.fromMerc(this),i=r.CenterPoint.fromGeo(e,t),{northWest:n}=i.northWestNeighbors,o=n.toGeo().toMerc(),s=u.fromMerc(o,this.tileWidth,this.tileHeight,this.zoom);return this.startPointDiff(s)}startPointDiff(t){let e=t.tileX-this.tileX;const i=t.tileY-this.tileY;return e>this.tileX&&(e-=Math.ceil(e)),new h.Point(e,i)}toPoly(){const t=this.eastTile;return new o.GeoPolygon([a.GeoPoint.fromMerc(this),a.GeoPoint.fromMerc(t),a.GeoPoint.fromMerc(t.southTile),a.GeoPoint.fromMerc(this.southTile)])}containsPoint({lat:t,lng:e}){return t<=this.northBound&&t>=this.southBound&&e<=this.eastBound&&e>=this.westBound}projectGeoPoints(t){return t.map(t=>{const e=t.toMerc(),{tileX:i,tileY:n}=u.fromMerc(e,this.tileWidth,this.tileHeight,this.zoom),o=Math.round((i-this.tileX)*this.tileWidth),s=Math.round((n-this.tileY)*this.tileHeight);return new h.Point(o,s)})}toPlain(){return{x:this.x,y:this.y,tileX:this.tileX,tileY:this.tileY,zoom:this.zoom,tileHeight:this.tileHeight,tileWidth:this.tileWidth}}}e.TileMercPoint=u},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(6),o=i(30),s=i(1),r=i(32);class a{constructor(t,e){this.pointA=t,this.pointB=e,this.rhumbLine=o.RhumbLine.fromTwoGeoPoints(t,e)}get points(){return[this.pointA,this.pointB]}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallel(){return this.pointA.lat===this.pointB.lat}get isMeridian(){return this.pointA.lat===this.pointB.lat}get easternPoint(){return this.isMeridian?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isMeridian?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallel?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallel?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}static segmentsFromPointsByLng(t){const e=t.sort(({lng:t},{lng:e})=>t-e),i=e.reduce((t,i,n)=>e[t].isEasternTo(i)?n:t,0);return[...e.slice(i),...e.slice(0,i)].reduce((t,e,i,n)=>{if(i%2)return t;const o=new a(n[i+1],e);return t.push(o),t},[])}static segmentsFromPointsByLat(t){return t.sort(({lat:t},{lat:e})=>t-e).reduce((t,e,i,n)=>{if(i%2)return t;const o=new a(n[i+1],e);return t.push(o),t},[])}toMerc(){const t=this.pointA.toMerc(),e=this.pointB.toMerc();return new r.MercSegment(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new a(t,e)}intersectsWithPoly(t){return t.intersectsWithSegment(this)}intersects(t){return!!this.intersectionPoint(t)}intersectionPoint(t){let e=this,i=t;const n=this.isAntiMeridian||t.isAntiMeridian;n&&(e=e.toOppositeHemisphere(),i=i.toOppositeHemisphere());const o=e.toMerc(),r=i.toMerc(),a=o.intersectionPoint(r);if(!a)return;const c=s.GeoPoint.fromMerc(a);return n?c.toOppositeHemisphere():c}closestToPoint(t){const{isAntiMeridian:e}=this;let i=this;e&&(i=i.toOppositeHemisphere(),t=t.toOppositeHemisphere());const n=t.toMerc(),o=i.toMerc().closestToPoint(n),r=s.GeoPoint.fromMerc(o);return e?r.toOppositeHemisphere():r}isEqual({pointA:t,pointB:e}){return this.pointA.isEqual(t)&&this.pointB.isEqual(e)||this.pointA.isEqual(e)&&this.pointB.isEqual(t)}mercDistanceToPoint(t){const e=this.closestToPoint(t);return t.calcMercDistance(e)}latByLng(t){if(!this.containsLng(t))return;const e=this.rhumbLine.latByLng(t);return void 0===e||0!==this.rhumbLine.a&&!this.containsLat(e)?void 0:e}lngByLat(t){if(!this.containsLat(t))return;const e=this.rhumbLine.lngByLat(t);return void 0===e||0!==this.rhumbLine.b&&!this.containsLng(e)?void 0:e}containsLat(t){t=n.formatLat(t);const{lat:e}=this.pointA.toFormatted(),{lat:i}=this.pointB.toFormatted();return Math.max(e,i)>=t&&Math.min(e,i)<=t}containsLng(t){t=n.formatLng(t);const{lng:e}=this.pointA.toFormatted(),{lng:i}=this.pointB.toFormatted(),o=Math.max(e,i),s=Math.min(e,i);return this.isAntiMeridian?o<=t&&t<180||s>=t&&t>=-180:o>=t&&s<=t}containsPoint({lat:t,lng:e}){return this.containsLat(t)&&this.containsLng(e)}containsSegment({pointA:t,pointB:e}){return this.containsPoint(t)&&this.containsPoint(e)}overlapsSegment(t){const{pointA:e,pointB:i}=t;return this.containsPoint(e)||this.containsPoint(i)||t.containsPoint(this.pointB)||t.containsPoint(this.pointB)}}e.GeoSegment=a},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.constants={equatorLength:40075696,radius:6370997,meridianLength:40007860,googleTileSize:256}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(2);e.yToLat=function(t){const e=Math.atan(Math.E**(-(2*t-1)*Math.PI))-Math.PI/4;return 2*n.radToDeg(e)},e.xToLng=function(t){const e=(2*t-1)*Math.PI;return n.radToDeg(e)},e.yToSemiLat=function(t){return 180*-(t-.5)},e.xToSemiLng=function(t){return 360*(t-.5)},e.reduceX=function(t){return t%=1}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(4),o=i(12);class s extends o.Line{static fromTwoPoints(t,e){const{a:i,b:n,c:r}=o.Line.fromTwoPoints(t,e);return new s(i,n,r)}calcAlikePoint(t){const{x:e,y:i}=super.calcAlikePoint(t);return new n.MercPoint(e,i)}closestToPoint(t){const{x:e,y:i}=super.closestToPoint(t);return new n.MercPoint(e,i)}perpendicularByPoint(t){const{a:e,b:i,c:n}=super.perpendicularByPoint(t);return new s(e,i,n)}intersectionPoint(t){const e=super.intersectionPoint(t);if(!e)return;const{x:i,y:o}=e;return new n.MercPoint(i,o)}}e.MercLine=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0),o=i(31);class s{constructor(t,e,i){this.a=t,this.b=e,this.c=i}get isParallelToAxisX(){return 0===this.b}get isParallelToAxisY(){return 0===this.a}static fromTwoPoints({x:t,y:e},{x:i,y:n}){return new s(e-n,i-t,-(t*n-e*i))}calcAlikePoint(t){const e=this.xByY(t.y),i=this.yByX(t.x);return new n.Point(void 0===e?t.x:e,void 0===i?t.y:i)}hasPoint(t){return this.calcAlikePoint(t).isEqual(t)}xByY(t){if(!this.isParallelToAxisY)return(this.c-this.b*t)/this.a}yByX(t){if(!this.isParallelToAxisX)return(this.c-this.a*t)/this.b}distanceToPoint(t){const e=this.closestToPoint(t);return t.distanceToPoint(e)}getNormalVector(){return new o.Vector(this.a,this.b)}closestToPoint(t){const{x:e,y:i}=t;if(this.isParallelToAxisX)return new n.Point(this.c/this.a,i);if(this.isParallelToAxisY)return new n.Point(e,this.c/this.b);const o=this.perpendicularByPoint(t);return this.intersectionPoint(o)}perpendicularByPoint({x:t,y:e}){const{x:i,y:n}=this.getNormalVector();return new s(1/i,-1/n,t/i-e/n)}intersectionX({a:t,b:e,c:i}){const n=this.a*e-this.b*t,o=this.c*e-this.b*i;if(n)return o/n}intersectionY({a:t,b:e,c:i}){const n=this.a*e-this.b*t,o=this.a*i-this.c*t;if(n)return o/n}intersectionPoint(t){if(t.isParallelToAxisX&&this.isParallelToAxisX||t.isParallelToAxisY&&this.isParallelToAxisY)return;const{a:e,b:i,c:o}=t;let s,r;return s=t.isParallelToAxisX?o/e:this.isParallelToAxisX?this.c/this.a:this.intersectionX(t),r=t.isParallelToAxisY?o/i:this.isParallelToAxisY?this.c/this.b:this.intersectionY(t),void 0===s&&void 0!==r&&(s=this.xByY(r)||t.xByY(r)),void 0!==s&&void 0===r&&(r=this.yByX(s)||t.yByX(s)),void 0!==s&&void 0!==r?new n.Point(s,r):void 0}}e.Line=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(14),o=i(17),s=i(36),r=i(37),a=self,c=new s.CtxService(a);let h;c.onMessage(t=>{const{data:e}=t;if("params"===e.type){const{payload:{params:t}}=e;return h=n.GridParams.fromPlain(t),void c.post("")}if("grid-tile"===e.type){if(!h)throw new Error("Grid params wasn\'t provided.");const{payload:{tilePoint:t}}=e;let i;i=o.createPatterns(r.TileMercPoint.fromPlain(t),h),c.post({mapTile:{patterns:i.map(t=>t.toPlain()),tilePoint:t}})}}),e.default={}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(15);e.GridParams=n.GridParams},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(16);class o{static fromConfig({isHorizontal:t=!1,type:e,correction:i,cellSize:s}){const r=t?"horizontal":"vertical",a=n.initCoofs[e][i][r],c=n.axesParams[e],h=n.calcAxesParams(t,e),u=n.calcInitialCellWidth(s,a),l=n.calcInitialCellHeight(s);return new o({isHorizontal:t,type:e,axes:c,geoAxes:h,initSize:u,initHeight:l,correction:i})}constructor({isHorizontal:t,type:e,axes:i,geoAxes:n,initSize:o,initHeight:s,correction:r}){this.isHorizontal=t,this.type=e,this.axes=i,this.geoAxes=n,this.initSize=o,this.initHeight=s,this.correction=r}minCellSize(t){const{tileWidth:e,zoomCoofX:i}=t,{initSize:n,initHeight:o,isHorizontal:s}=this;return(s?n:o)/1e7*e*i/360}isEqual(t){return this.isHorizontal===t.isHorizontal&&this.type===t.type&&this.correction===t.correction&&this.initSize===t.initSize}toPlain(){const{isHorizontal:t,type:e,axes:i,geoAxes:n,initSize:o,initHeight:s,correction:r}=this;return{isHorizontal:t,type:e,axes:i,geoAxes:n,initSize:o,initHeight:s,correction:r}}static fromPlain(t){return new o(t)}}e.GridParams=o},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(9),o=i(2),s=Math.sqrt(3)/2;e.axesParams={get hex(){return[{name:"i",angle:0},{name:"j",angle:120},{name:"k",angle:240}]},get rect(){return[{name:"i",angle:0},{name:"j",angle:90}]}},e.initCoofs={hex:{get merc(){return{vertical:.5*s,horizontal:.5}},get none(){return{vertical:s,horizontal:1}},get area(){return{vertical:s,horizontal:1}}},rect:{get merc(){return{vertical:.5,horizontal:.5}},get none(){return{vertical:1,horizontal:1}},get area(){return{vertical:2,horizontal:.5}}}},e.calcAxesParams=function(t,e){let i;switch(e){case"hex":i=120;break;case"rect":default:i=90}return[{name:t?"lng":"lat",angle:0},{name:t?"lat":"lng",angle:i}]},e.calcInitialCellWidth=function(t,e){const i=n.constants.equatorLength/36e8,s=Math.round(t/i);let r=o.calcClosestMultiple(s,36e8);return r>18e8&&(r=18e8),r<1&&(r=1),r*e},e.calcInitialCellHeight=function(t){const e=n.constants.meridianLength/36e8,i=Math.round(t/e);let s=o.calcClosestMultiple(i,18e8);return s>18e8&&(s=18e8),s<1&&(s=1),s}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0),o=i(18);e.createPatterns=function(t,e){let i=t.gridPatternStartPoint(e);if("merc"===e.correction){return[o.GridPattern.fromTileCoords(t,i,e)]}const s=[];for(;i.y<1;){const r=o.GridPattern.fromTileCoords(t,i,e);s.push(r),i=new n.Point(i.x,i.y+r.tile.tileHeight)}return s}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(0),o=i(19);class s{constructor(t,e,i,n,o){this.tilePoint=t,this.tile=e,this.start=i,this.end=n,this.params=o}static fromTileCoords(t,e,i){const r=o.GridTile.fromTileCoords(t,e,i);let a,c;"merc"===i.correction?(a=1,c=1):(a=1,c=e.y+r.tileHeight);const h=new n.Point(a,c);return new s(t,r,e,h,i)}toPlain(){return{start:this.start.toPlain(),end:this.end.toPlain(),tile:this.tile.toPlain()}}static fromPlain({start:t,end:e,tile:i},r,a){return new s(r,o.GridTile.fromPlain(i,r,a),n.Point.fromPlain(t),n.Point.fromPlain(e),a)}}e.GridPattern=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(5),o=i(1),s=i(0),r=i(7),a=i(35);class c{constructor(t,e,i,n,o){this.points=t,this.tilePoint=e,this.tileWidth=i,this.tileHeight=n,this.params=o}static fromTileCoords(t,e,i){const{tileX:s,tileY:h,tileHeight:u,tileWidth:l,zoom:p}=t,d=r.TileMercPoint.fromTile(s+e.x,h+e.y,l,u,p),m=o.GeoPoint.fromMerc(d),f=n.CenterPoint.fromGeo(m,i),{southEast:g}=f.southEastNeighbors,{southEast:P}=g.southEastNeighbors,y=P.toGeo().toMerc(),{tileY:x}=d;let{tileX:M}=d;const{tileX:j,tileY:T}=r.TileMercPoint.fromMerc(y,l,u,p);j<M&&(M-=Math.ceil(M));const b=g.toGeo(),A=j-M,O=T-x,G=a.expandTile(b,d,A,O,i);return new c(G,t,A,O,i)}static fromPlain({points:t,tileHeight:e,tileWidth:i},n,o){return new c(t.map(t=>t.map(({x:t,y:e})=>new s.Point(t,e))),n,i,e,o)}toPlain(){return{points:this.points.map(t=>t.map(({x:t,y:e})=>({x:t,y:e}))),tileHeight:this.tileHeight,tileWidth:this.tileWidth}}}e.GridTile=c},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(3),o=i(24),s=i(25),r=i(26),a=i(27);class c extends n.GridPoint{get neighbors(){const{south:t,north:e,west:i,east:n,southEast:o,southWest:s,northEast:a,northWest:h}=r.getAll(this);return{south:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),west:i&&c.fromObject(i,this.params),east:n&&c.fromObject(n,this.params),southEast:c.fromObject(o,this.params),southWest:c.fromObject(s,this.params),northEast:c.fromObject(a,this.params),northWest:c.fromObject(h,this.params)}}get northNeighbors(){const{northWest:t,north:e,northEast:i}=r.getNorth(this);return{northWest:t&&c.fromObject(t,this.params),north:e&&c.fromObject(e,this.params),northEast:i&&c.fromObject(i,this.params)}}get southNeighbors(){const{southWest:t,south:e,southEast:i}=r.getSouth(this);return{southWest:t&&c.fromObject(t,this.params),south:e&&c.fromObject(e,this.params),southEast:i&&c.fromObject(i,this.params)}}get westNeighbors(){const{southWest:t,west:e,northWest:i}=r.getWest(this);return{southWest:t&&c.fromObject(t,this.params),west:e&&c.fromObject(e,this.params),northWest:i&&c.fromObject(i,this.params)}}get eastNeighbors(){const{southEast:t,east:e,northEast:i}=r.getEast(this);return{southEast:t&&c.fromObject(t,this.params),east:e&&c.fromObject(e,this.params),northEast:i&&c.fromObject(i,this.params)}}get northEastNeighbors(){const{northEast:t}=r.getNorthEast(this);return{northEast:c.fromObject(t,this.params)}}get southWestNeighbors(){const{southWest:t}=r.getSouthWest(this);return{southWest:c.fromObject(t,this.params)}}get northWestNeighbors(){const{northWest:t}=r.getNorthWest(this);return{northWest:c.fromObject(t,this.params)}}get southEastNeighbors(){const{southEast:t}=r.getSouthEast(this);return{southEast:c.fromObject(t,this.params)}}static fromObject({i:t,j:e,k:i},n){return new c(n,t,e,i)}static fromGeo(t,e){const i=n.GridPoint.fromGeo(t,e);return c.fromGrid(i)}static fromGrid(t){const{i:e,j:i,k:o}=a.round(t),s=new n.GridPoint(t.params,e,i,o).toGeo(),r=n.GridPoint.fromGeo(s,t.params),{i:h,j:u,k:l}=a.round(r);return new c(t.params,h,u,l)}nextCenterByCellSide(t){const{i:e,j:i,k:s}=o.getNextCenterByCellSide(this,t),r=new n.GridPoint(this.params,e,i,s).toGeo();return c.fromGeo(r,this.params)}isNeighbor(t){let e=this,i=t;return this.isCloserThroughAntiMeridian(t)&&(e=e.toOppositeHemishpere(),i=i.toOppositeHemishpere()),s.isNeighbor(e,i)}isCloserThroughAntiMeridian(t){return this.toGeo().isCloserThroughAntiMeridian(t.toGeo())}toOppositeHemishpere(){const t=this.toGeo().toOppositeHemisphere();return c.fromGeo(t,this.params)}moveByDiff(t,e){const i=this.i+t,n=this.j+e,o=void 0===this.k?void 0:this.k-(t+e),s=new c(this.params,i,n,o).toGeo();return c.fromGeo(s,this.params)}toPlain(){return{i:this.i,j:this.j,k:this.k}}static fromPlain({i:t,j:e,k:i},n){return new c(n,t,e,i)}}e.CenterPoint=c},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(1),o=i(22),s=i(23);class r{static fromGeo(t,e){const i=o.correctForGrid(t,e),{axes:n}=e,{i:a,j:c,k:h}=n.reduce((t,n)=>(t[n.name]=s.toGrid(i,n,e),t),{});return new r(e,a,c,h)}constructor(t,e,i,n){this.params=t,this.i=e,this.j=i,this.k=n}toFormatted(){return this}isEasternTo(t){return this.toGeo().isEasternTo(t.toGeo())}isWesternTo(t){return this.toGeo().isWesternTo(t.toGeo())}isNorthernTo(t){return this.toGeo().isNorthernTo(t.toGeo())}isSouthernTo(t){return this.toGeo().isSouthernTo(t.toGeo())}isEqual(t){const{i:e,j:i,k:n}=this.toFormatted(),{i:o,j:s,k:r}=t.toFormatted();return e===o&&i===s&&n===r}toGeo(){const{geoAxes:t}=this.params,{lat:e,lng:i}=t.reduce((t,e)=>(t[e.name]=s.toGeo(this,e),t),{}),r=new n.GeoPoint(e,i);return o.correctForGeo(r,this.params)}onSameAxis(t,e){let i=(this.i-t.i)*(this.j-e.j)-(this.i-e.i)*(this.j-t.j);return"hex"===this.params.type&&(i*=3),0===Math.round(i)}}e.GridPoint=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(1);e.correctForGrid=function(t,{correction:e}){if("merc"===e){const{lat:e,lng:i}=t.toSemiSphere();return new n.GeoPoint(e,i/2)}return t},e.correctForGeo=function(t,e){const{correction:i}=e;if("merc"===i){const{lat:e,lng:i}=t;return new n.GeoPoint(e,2*i).fromSemiSphere().toFormatted()}return t.toFormatted()},e.correctPoly=function(t,{correction:e}){return t}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(2);e.toGrid=function(t,e,i){return function(t,e){const i=e.initSize;return 1e7*t/i}(function(t,e,i){const o=i?"lat":"lng",s=t[i?"lng":"lat"],r=t[o],a=e.angle,c=n.sinDeg(a),h=n.cosDeg(a);return r*c+s*h}(t,e,i.isHorizontal),i)},e.toGeo=function(t,e){return function(t,e){const i=e.initSize;return t*i/1e7}(function(t,e){const{isHorizontal:i}=t.params,o=i?"lng":"lat",s=i?"lat":"lng",r=e.angle,a=n.sinDeg(r),c=n.cosDeg(r);let h;switch(e.name){case o:h=(t.i-t.j*a)/c;break;case s:h=(t.j-t.i*c)/a;break;default:h=t.j*a+t.i*c}return h}(t,e),t.params)}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getNextCenterByCellSide=function(t,e){const{i:i,j:n,k:o}=t,{averagePoint:{i:s,j:r,k:a}}=e;return{i:Math.round(i+2*(s-i)),j:Math.round(n+2*(r-n)),k:void 0!==o&&void 0!==a?Math.round(o+2*(a-o)):void 0}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isNeighbor=function(t,e){const{type:i}=t.params;return"hex"===i?function({i:t,j:e,k:i},{i:n,j:o,k:s}){const r=[t-n,e-o,i-s];return r.includes(0)&&r.includes(1)&&r.includes(-1)}(t,e):function({i:t,j:e},{i:i,j:n}){const o=[Math.abs(t-i),Math.abs(e-n)];return o.includes(0)&&o.includes(1)}(t,e)}},function(t,e,i){"use strict";function n(t){const{type:e,geoAxes:i}=t.params,n=i[0].name;let{i:o,j:s}=t;const{k:r}=t;return"rect"===e&&"lat"===n?(o+=1,s-=1):"rect"===e&&"lng"===n?(o-=1,s+=1):"hex"===e&&"lat"===n?(o+=1,s-=1):"hex"===e&&"lng"===n&&(o-=1,s+=1),{northWest:{i:o,j:s,k:r}}}function o(t){const{type:e}=t.params;let{i:i,j:n,k:o}=t;return"rect"===e?(i+=1,n+=1):"hex"===e&&(i+=1,o-=1),{northEast:{i:i,j:n,k:o}}}function s(t){const{type:e}=t.params;let{i:i,j:n,k:o}=t;return"rect"===e?(i-=1,n-=1):"hex"===e&&(i-=1,o+=1),{southWest:{i:i,j:n,k:o}}}function r(t){const{type:e,geoAxes:i}=t.params,n=i[0].name;let{i:o,j:s}=t;const{k:r}=t;return"rect"===e&&"lat"===n?(o-=1,s+=1):"rect"===e&&"lng"===n?(o+=1,s-=1):"hex"===e&&"lat"===n?(o-=1,s+=1):"hex"===e&&"lng"===n&&(o+=1,s-=1),{southEast:{i:o,j:s,k:r}}}function a(t){const{type:e,geoAxes:i}=t.params,s=i[0].name;let{i:r,j:a,k:c}=t;if("rect"===e&&"lat"===s)r+=1;else if("rect"===e&&"lng"===s)a+=1;else if("hex"===e&&"lat"===s)a+=1,c-=1;else if("hex"===e&&"lng"===s)return Object.assign({},o(t),n(t));return{north:{i:r,j:a,k:c}}}function c(t){const{type:e,geoAxes:i}=t.params,n=i[0].name;let{i:o,j:a,k:c}=t;if("rect"===e&&"lat"===n)o-=1;else if("rect"===e&&"lng"===n)a-=1;else if("hex"===e&&"lng"===n)a-=1,c+=1;else if("hex"===e&&"lat"===n)return Object.assign({},r(t),s(t));return{south:{i:o,j:a,k:c}}}function h(t){const{type:e,geoAxes:i}=t.params,n=i[0].name;let{i:s,j:a,k:c}=t;if("rect"===e&&"lat"===n)a+=1;else if("rect"===e&&"lng"===n)s-=1;else{if("hex"===e&&"lng"===n)return Object.assign({},r(t),o(t));"hex"===e&&"lat"===n&&(a+=1,c-=1)}return{east:{i:s,j:a,k:c}}}function u(t){const{type:e,geoAxes:i}=t.params,o=i[0].name;let{i:r,j:a,k:c}=t;if("rect"===e&&"lat"===o)a-=1;else if("rect"===e&&"lng"===o)r+=1;else{if("hex"===e&&"lng"===o)return Object.assign({},s(t),n(t));"hex"===e&&"lat"===o&&(a-=1,c+=1)}return{west:{i:r,j:a,k:c}}}Object.defineProperty(e,"__esModule",{value:!0}),e.getAll=function(t){const{type:e,geoAxes:i}=t.params,l=i[0].name;return"hex"===e&&"lat"===l?Object.assign({},a(t),c(t),r(t),s(t),o(t),n(t)):"hex"===e&&"lng"===l?Object.assign({},h(t),u(t),r(t),s(t),o(t),n(t)):Object.assign({},a(t),c(t),h(t),u(t),r(t),s(t),o(t),n(t))},e.getNorthWest=n,e.getNorthEast=o,e.getSouthWest=s,e.getSouthEast=r,e.getNorth=a,e.getSouth=c,e.getEast=h,e.getWest=u},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(2);e.round=function(t){const{type:e}=t.params;if("hex"===e){const{i:e,j:i,k:o}=t;return function(t){const e=function(t){return Object.keys(t).reduce((e,i)=>{const o=t[i],s=n.decRemain(o);return e[i]=s,e},{})}(t),i=Object.keys(e).sort((t,i)=>e[i]-e[t]);let o=Object.values(e).reduce((t,e)=>t+e,0);return o=Math.round(o),i.reduce((e,i)=>(o>0?(e[i]=Math.ceil(t[i]),o-=1):e[i]=Math.floor(t[i]),e),{})}({i:e,j:i,k:o})}{const{i:e,j:i}=t;return function(t){return Object.keys(t).reduce((e,i)=>(e[i]=Math.round(t[i]),e),{})}({i:e,j:i})}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(29);e.GeoPolygon=n.GeoPolygon},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(1),o=i(8),s=i(34);class r extends s.GenericPolygon{sideByIndex(t){const{pointA:e,pointB:i}=super.sideByIndex(t);return new o.GeoSegment(e,i)}sideByIndexInversed(t){const{pointA:e,pointB:i}=super.sideByIndexInversed(t);return new o.GeoSegment(e,i)}splitSectionsByLng(t){const e=this.reduceSides((e,i)=>{const o=i.latByLng(t);if(void 0===o)return e;const s=new n.GeoPoint(o,t);return e.find(t=>t.isEqual(s))||e.push(s),e},[]);return o.GeoSegment.segmentsFromPointsByLat(e)}splitSectionsByLat(t){const e=this.reduceSides((e,i)=>{const o=i.lngByLat(t);if(void 0!==o){const i=new n.GeoPoint(t,o);e.push(i)}return e},[]);return o.GeoSegment.segmentsFromPointsByLng(e)}intersectsSegment(t){return super.intersectsSegment(t)}intersectsWithSegment(t){return super.intersectsWithSegment(t)}closestSideToSegment(t){const[e,i]=this.pointsByDistanceToSegment(t),n=this.points.indexOf(e),o=this.points.indexOf(i);return this.sideByIndex(Math.min(n,o))}pointsByDistanceToSegment(t){return[...this.points].sort((e,i)=>{return t.mercDistanceToPoint(e)-t.mercDistanceToPoint(i)})}pointsInsidePoly(t){return this.points.filter(e=>t.containsPoint(e))}pointsOutsidePoly(t){return this.points.filter(e=>!t.containsPoint(e))}arePointsInsidePoly(t){return this.points.every(e=>t.containsPoint(e))}arePointsOutsidePoly(t){return this.points.every(e=>!t.containsPoint(e))}containsPoint(t){return this.splitSectionsByLat(t.lat).reduce((e,i)=>e||i.containsLng(t.lng),!1)}isValidForFigure(t){if(this.outmapPoints.length>0)return!1;if(this.points.length<3)return!1;const{selfIntersections:e}=this;return!(e.length>0)}get outmapPoints(){return this.points.filter(t=>{const{y:e}=t.toMerc();return e>1||e<0})}get easternPoint(){return this.points.reduce((t,e)=>e.isEasternTo(t)?e:t,this.points[0])}get westernPoint(){return this.points.reduce((t,e)=>e.isWesternTo(t)?e:t,this.points[0])}get northernPoint(){return this.points.reduce((t,e)=>e.isNorthernTo(t)?e:t,this.points[0])}get southernPoint(){return this.points.reduce((t,e)=>e.isSouthernTo(t)?e:t,this.points[0])}toPlain(){return this.points.map(t=>t.toPlain())}toGeoJSON(){return{type:"Polygon",coordinates:[[...this.points,this.points[0]].map(({lat:t,lng:e})=>[e,t])]}}static fromGeoJSON({coordinates:[t]}){const e=n.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[0]}),i=n.GeoPoint.fromGeoJSON({type:"Point",coordinates:t[t.length-1]});if(!e.isEqual(i))throw new Error("Loop is not closed");return r.fromPlain(t.slice(0,-1).map(([t,e])=>({lat:e,lng:t})))}static fromPlain(t){return new r(t.map(({lat:t,lng:e})=>new n.GeoPoint(t,e)))}}e.GeoPolygon=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(6),o=i(10),s=i(11);class r extends s.MercLine{static fromTwoGeoPoints(t,e){const i=t.isCloserThroughAntiMeridian(e);i&&(t=t.toOppositeHemisphere(),e=e.toOppositeHemisphere());const{a:n,b:o,c:a}=s.MercLine.fromTwoPoints(t.toMerc(),e.toMerc());return new r(n,o,a,i)}constructor(t,e,i,n){super(t,e,i),this.isAntiMeridian=n}lngByLat(t){const e=n.latToY(t),i=this.xByY(e);if(void 0===i)return;let s=o.xToLng(i);return this.isAntiMeridian&&(s=n.reduceLng(s-180)),s}latByLng(t){this.isAntiMeridian&&(t=n.reduceLng(t-180));const e=n.lngToX(t),i=this.yByX(e);if(void 0!==i)return o.yToLat(i)}}e.RhumbLine=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Vector=class{constructor(t,e){this.x=t,this.y=e}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(11),o=i(4),s=i(33);class r extends s.Segment{constructor(t,e){super(t,e),this.pointA=t,this.pointB=e,this.line=n.MercLine.fromTwoPoints(t,e)}toOppositeHemisphere(){const t=this.pointA.toOppositeHemisphere(),e=this.pointB.toOppositeHemisphere();return new r(t,e)}intersectionPoint(t){if(!this.isAntiMeridian&&!t.isAntiMeridian){const e=super.intersectionPoint(t);return e&&new o.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere(),i=t.toOppositeHemisphere(),n=e.intersectionPoint(i);return n&&n.toOppositeHemisphere()}closestToPoint(t){if(!this.isAntiMeridian){const e=super.closestToPoint(t);return new o.MercPoint(e.x,e.y)}const e=this.toOppositeHemisphere();return t=t.toOppositeHemisphere(),e.closestToPoint(t).toOppositeHemisphere()}get isAntiMeridian(){return this.pointA.isCloserThroughAntiMeridian(this.pointB)}get isParallelToAxisX(){return this.line.isParallelToAxisX}get isParallelToAxisY(){return this.line.isParallelToAxisY}get easternPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isEasternTo(this.pointB)?this.pointA:this.pointB}get westernPoint(){return this.isParallelToAxisY?this.pointA:this.pointA.isWesternTo(this.pointB)?this.pointA:this.pointB}get northernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isNorthernTo(this.pointB)?this.pointA:this.pointB}get southernPoint(){return this.isParallelToAxisX?this.pointA:this.pointA.isSouthernTo(this.pointB)?this.pointA:this.pointB}}e.MercSegment=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(12);e.Segment=class{constructor(t,e){this.pointA=t,this.pointB=e,this.line=n.Line.fromTwoPoints(t,e)}get minX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.min(t,e)}get maxX(){const{pointA:{x:t},pointB:{x:e}}=this;return Math.max(t,e)}get minY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.min(t,e)}get maxY(){const{pointA:{y:t},pointB:{y:e}}=this;return Math.max(t,e)}get minXPoint(){const{x:t}=this.pointA;return this.minX===t?this.pointA:this.pointB}get maxXPoint(){const{x:t}=this.pointA;return this.maxX===t?this.pointA:this.pointB}get minYPoint(){const{y:t}=this.pointA;return this.minY===t?this.pointA:this.pointB}get maxYPoint(){const{y:t}=this.pointA;return this.maxY===t?this.pointA:this.pointB}closestToPoint(t){const e=this.line.closestToPoint(t).toFormatted(),{x:i,y:n}=this.pointA.toFormatted(),{x:o,y:s}=this.pointB.toFormatted();return e.x<Math.min(i,o)?this.minXPoint:e.x>Math.max(i,o)?this.maxXPoint:e.y<Math.min(n,s)?this.minYPoint:e.y>Math.max(n,s)?this.maxYPoint:e}hasPoint(t){const{pointA:e,pointB:i}=this,{x:n,y:o}=t.toFormatted(),{x:s,y:r}=e.toFormatted(),{x:a,y:c}=i.toFormatted();return this.line.hasPoint(t)&&Math.max(s,a)>=n&&Math.min(s,a)<=n&&Math.max(r,c)>=o&&Math.min(r,c)<=o}intersectionPoint(t){if(this.line.a===t.line.a||this.line.b===t.line.b)return;const e=this.line.intersectionPoint(t.line);if(!e)return;let i,n;const o=Math.max(this.pointA.x,this.pointB.x),s=Math.min(this.pointA.x,this.pointB.x),r=Math.max(this.pointA.y,this.pointB.y),a=Math.min(this.pointA.y,this.pointB.y),c=Math.max(t.pointA.x,t.pointB.x),h=Math.min(t.pointA.x,t.pointB.x),u=Math.max(t.pointA.y,t.pointB.y),l=Math.min(t.pointA.y,t.pointB.y);return i=0===this.line.a?e.x<=o&&e.x>=s&&u>=r&&l<=a:0===this.line.b?e.y<=r&&e.y>=a&&c>=o&&h<=s:this.hasPoint(e),n=0===t.line.a?e.x<=c&&e.x>=h&&r>=u&&a<=l:0===t.line.b?e.y<=u&&e.y>=l&&o>=c&&s<=h:t.hasPoint(e),i&&n?e:void 0}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.GenericPolygon=class{constructor(t){this.points=t}intersectsPoly(t){return this.reduceSides((e,i,n)=>t.reduceSides((t,e,n)=>{const o=i.intersectionPoint(e);return o&&t.push(o),t},e),[])}intersectsSegment(t){return this.reduceSides((e,i)=>!!e||!!i.intersectionPoint(t),!1)}intersectsWithSegment(t){return this.reduceSides((e,i)=>{const n=i.intersectionPoint(t);return n&&e.push(n),e},[])}get selfIntersections(){return this.reduceOppositeSidesPairs((t,e,i)=>{const n=e.intersectionPoint(i);return n&&t.push(n),t},[])}sideByIndex(t){return{pointA:this.points[t],pointB:this.nextPointByIndex(t)}}sideByIndexInversed(t){return{pointA:this.points[t],pointB:this.prevPointByIndex(t)}}nextIndex(t){return t===this.points.length-1?0:t+1}prevIndex(t){const{length:e}=this.points;return 0===t?e-1:t-1}nextPointByIndex(t){const e=this.nextIndex(t);return this.points[e]}prevPointByIndex(t){const e=this.prevIndex(t);return this.points[e]}forEachSide(t){this.points.forEach((e,i)=>{const n=this.sideByIndex(i);t(n,i)})}mapSides(t){return this.points.map((e,i)=>{const n=this.sideByIndex(i);return t(n,i)})}reduceSides(t,e){return this.points.reduce((e,i,n)=>{const o=this.sideByIndex(n);return t(e,o,n)},e)}forEachSidesPair(t){this.forEachSide((e,i)=>{this.forEachSide((n,o)=>{o<=i||t(e,n)})})}reduceSidesPairs(t,e){return this.reduceSides((e,i,n)=>this.reduceSides((e,o,s)=>s<=n?e:t(e,i,o),e),e)}reduceNeighboringSidesPairs(t,e){return this.points.reduce((e,i,n)=>{const o=this.sideByIndexInversed(n),s=this.sideByIndex(n);return t(e,o,s)},e)}reduceOppositeSidesPairs(t,e){const i=this.points.length-1;return this.reduceSides((e,n,o)=>this.reduceSides((e,s,r)=>0===o&&r===i||r-1<=o?e:t(e,n,s),e),e)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(5),o=i(3),s=i(0),r=i(7);e.expandTile=function(t,e,i,a,c){const{northWestNeighbors:{northWest:h}}=n.CenterPoint.fromGeo(t,c);let u;return u="hex"===c.type?function(t){const{i:e,j:i,params:n}=t,o=t.k;return n.isHorizontal?[[{i:e,j:i-.5,k:o+.5},{i:e+1/3,j:i-2/3,k:o+1/3},{i:e+2/3,j:i-1/3,k:o-1/3},{i:e+4/3,j:i-2/3,k:o-2/3},{i:e+5/3,j:i-4/3,k:o-1/3},{i:e+2,j:i-1.5,k:o-.5}],[{i:e+1/3,j:i-2/3,k:o+1/3},{i:e+2/3,j:i-4/3,k:o+2/3},{i:e+4/3,j:i-5/3,k:o+1/3},{i:e+5/3,j:i-4/3,k:o-1/3}]]:[[{i:e,j:i+.5,k:o-.5},{i:e-1/3,j:i+2/3,k:o-1/3},{i:e-2/3,j:i+1/3,k:o+1/3},{i:e-4/3,j:i+2/3,k:o+2/3},{i:e-5/3,j:i+4/3,k:o+1/3},{i:e-2,j:i+1.5,k:o+.5}],[{i:e-1/3,j:i+2/3,k:o-1/3},{i:e-2/3,j:i+4/3,k:o-2/3},{i:e-4/3,j:i+5/3,k:o-1/3},{i:e-5/3,j:i+4/3,k:o+1/3}]]}(h):function({i:t,j:e,params:i}){return i.isHorizontal?[[{i:t,j:e-.5},{i:t+2,j:e-.5}],[{i:t+.5,j:e},{i:t+.5,j:e-2}],[{i:t+1.5,j:e},{i:t+1.5,j:e-2}],[{i:t,j:e-1.5},{i:t+2,j:e-1.5}]]:[[{i:t-.5,j:e},{i:t-.5,j:e+2}],[{i:t,j:e+.5},{i:t-2,j:e+.5}],[{i:t-1.5,j:e},{i:t-1.5,j:e+2}],[{i:t,j:e+1.5},{i:t-2,j:e+1.5}]]}(h),u.map(t=>t.map(({i:t,j:n,k:h})=>{const u=new o.GridPoint(c,t,n,h).toGeo().toMerc(),l=r.TileMercPoint.fromMerc(u,e.tileWidth,e.tileHeight,e.zoom);let p=l.tileX-e.tileX;if(p>1){const t=Math.abs(Math.ceil(l.tileX)-(l.tileX-e.tileX));p=Math.min(p,t)}const d=p/i,m=(l.tileY-e.tileY)/a;return new s.Point(d,m)}))}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.CtxService=class{constructor(t){this.worker=t,this.handleMessage=t=>{"terminate"!==t.data?this.messageHandler&&this.messageHandler(t):this.close()},this.handleError=t=>{this.errorHandler&&this.errorHandler(t)},this.worker.addEventListener("message",this.handleMessage),this.worker.addEventListener("error",this.handleError)}post(t){this.worker.postMessage(t)}onMessage(t){this.messageHandler=t}onError(t){this.errorHandler=t}close(){this.unmount(),close()}unmount(){this.worker.removeEventListener("message",this.handleMessage),this.worker.removeEventListener("error",this.handleError)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(5);e.CenterPoint=n.CenterPoint;var o=i(3);e.GridPoint=o.GridPoint;var s=i(1);e.GeoPoint=s.GeoPoint;var r=i(4);e.MercPoint=r.MercPoint;var a=i(38);e.PeakPoint=a.PeakPoint;var c=i(0);e.Point=c.Point;var h=i(7);e.TileMercPoint=h.TileMercPoint},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=i(39);e.PeakPoint=n.PeakPoint},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(40),o=i(3),s=i(41);class r extends o.GridPoint{get nearestPeaks(){return s.calcNearestPeaks(this).map(({i:t,j:e,k:i})=>{const n=new r(this.params,t,e,i).toGeo(),s=o.GridPoint.fromGeo(n,this.params);return new r(this.params,s.i,s.j,s.k)})}get nearestPeaksGeo(){return this.nearestPeaks.map(t=>t.toGeo())}static fromGeo(t,e){const{i:i,j:n,k:s}=o.GridPoint.fromGeo(t,e);return new r(e,i,n,s)}toFormatted(){const{params:t,i:e,j:i,k:n}=this;return new r(t,+e.toFixed(6),+i.toFixed(6),n&&+n.toFixed(6))}nearestNotSeparatedByPoly(t){const{nearestPeaks:e}=this;return e.reduce((e,i)=>{const o=n.CellSide.fromPeaks(this,i);return!t.intersectsSegment(o)&&e.push(i),e},[])}}e.PeakPoint=r},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(3),o=i(8);class s extends o.GeoSegment{constructor(t,e,i,n,o){super(t,e),this.peakA=i,this.peakB=n,this.params=o}get averagePoint(){const{i:t,j:e,k:i,params:o}=this.peakA,{i:s,j:r,k:a}=this.peakB;return new n.GridPoint(o,(t+s)/2,(e+r)/2,void 0!==i&&void 0!==a?(i+a)/2:void 0)}static fromPeaks(t,e){const i=t.toGeo(),n=e.toGeo();return new s(i,n,t,e,t.params)}}e.CellSide=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calcNearestPeaks=function(t){const{type:e}=t.params;return"hex"===e?function({i:t,j:e,k:i}){return 2===Math.round(t%1*3)?[{i:t+2/3,j:e-1/3,k:i-1/3},{i:t-1/3,j:e+2/3,k:i-1/3},{i:t-1/3,j:e-1/3,k:i+2/3}]:[{i:t-2/3,j:e+1/3,k:i+1/3},{i:t+1/3,j:e-2/3,k:i+1/3},{i:t+1/3,j:e+1/3,k:i-2/3}]}(t):function({i:t,j:e}){return[{i:t+1,j:e-1},{i:t+1,j:e+1},{i:t-1,j:e+1},{i:t-1,j:e-1}]}(t)}}]);',null)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(95);e.CellConnection=i.CellConnection},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(96);e.CellConnection=i.CellConnection},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const i=n(3),s=n(30);class o{constructor(t,e,n,i){this.centerA=t,this.centerB=e,this.path=n,this.innerCenters=i}static fromCenters(t,e){const n=t.toGeo(),r=e.toGeo(),a=i.Cell.fromCenter(e),c=[],u=[n];let h=new s.GeoSegment(n,r),l=i.Cell.fromCenter(t).nextCellOnSegment(h);for(;l&&!l.isEqual(a);){const t=l.center.toGeo();h=new s.GeoSegment(t,r),c.push(l.center),u.push(t),l=l.nextCellOnSegment(h)}return u.push(r),new o(t,e,u,c)}}e.CellConnection=o}])}));